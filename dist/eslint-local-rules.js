var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match3 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match3) {
        return;
      }
      var n = parseFloat(match3[1]);
      var type = (match3[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js"(exports, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match3, format) => {
            if (match3 === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match3 = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match3;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match3) => {
        if (match3 === "%%") {
          return;
        }
        index++;
        if (match3 === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/.pnpm/has-flag@3.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/.pnpm/has-flag@3.0.0/node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/.pnpm/supports-color@5.5.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/.pnpm/supports-color@5.5.0/node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty");
    var util = require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/internal/constants.js"(exports, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/internal/debug.js"(exports, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/internal/re.js"(exports, module2) {
    var { MAX_SAFE_COMPONENT_LENGTH } = require_constants();
    var debug = require_debug();
    exports = module2.exports = {};
    var re = exports.re = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;
    var createToken = (name, value, isGlobal) => {
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/internal/parse-options.js"(exports, module2) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/internal/identifiers.js"(exports, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/classes/semver.js"(exports, module2) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid Version: ${require("util").inspect(version)}`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/parse.js"(exports, module2) {
    var SemVer = require_semver();
    var parse2 = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse2;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/valid.js"(exports, module2) {
    var parse2 = require_parse();
    var valid = (version, options) => {
      const v = parse2(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/clean.js"(exports, module2) {
    var parse2 = require_parse();
    var clean = (version, options) => {
      const s = parse2(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/inc.js"(exports, module2) {
    var SemVer = require_semver();
    var inc = (version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/diff.js"(exports, module2) {
    var parse2 = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse2(version1, null, true);
      const v2 = parse2(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      if (highHasPre) {
        return "prerelease";
      }
      if (lowVersion.patch) {
        return "patch";
      }
      if (lowVersion.minor) {
        return "minor";
      }
      return "major";
    };
    module2.exports = diff;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/major.js"(exports, module2) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/minor.js"(exports, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/patch.js"(exports, module2) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/prerelease.js"(exports, module2) {
    var parse2 = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse2(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/compare.js"(exports, module2) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/rcompare.js"(exports, module2) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/compare-loose.js"(exports, module2) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/compare-build.js"(exports, module2) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/sort.js"(exports, module2) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/rsort.js"(exports, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/gt.js"(exports, module2) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/lt.js"(exports, module2) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/eq.js"(exports, module2) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/neq.js"(exports, module2) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/gte.js"(exports, module2) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/lte.js"(exports, module2) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/cmp.js"(exports, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/coerce.js"(exports, module2) {
    var SemVer = require_semver();
    var parse2 = require_parse();
    var { re, t } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match3 = null;
      if (!options.rtl) {
        match3 = version.match(re[t.COERCE]);
      } else {
        let next;
        while ((next = re[t.COERCERTL].exec(version)) && (!match3 || match3.index + match3[0].length !== version.length)) {
          if (!match3 || next.index + next[0].length !== match3.index + match3[0].length) {
            match3 = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match3 === null) {
        return null;
      }
      return parse2(`${match3[2]}.${match3[3] || "0"}.${match3[4] || "0"}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js"(exports, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js"(exports, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/.pnpm/lru-cache@6.0.0/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/.pnpm/lru-cache@6.0.0/node_modules/lru-cache/index.js"(exports, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/classes/range.js"(exports, module2) {
    var Range = class {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range;
        this.set = range.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${range}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => {
          return comps.join(" ").trim();
        }).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        range = range.trim();
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache2.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        range = range.split(/\s+/).join(" ");
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache2.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lru_cache();
    var cache2 = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((c) => {
      return replaceTilde(c, options);
    }).join(" ");
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((c) => {
      return replaceCaret(c, options);
    }).join(" ");
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => {
        return replaceXRange(c, options);
      }).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/classes/comparator.js"(exports, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/functions/satisfies.js"(exports, module2) {
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/to-comparators.js"(exports, module2) {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/max-satisfying.js"(exports, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/min-satisfying.js"(exports, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/min-version.js"(exports, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/valid.js"(exports, module2) {
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/outside.js"(exports, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/gtr.js"(exports, module2) {
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/ltr.js"(exports, module2) {
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/intersects.js"(exports, module2) {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/simplify.js"(exports, module2) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/ranges/subset.js"(exports, module2) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/.pnpm/semver@7.5.0/node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/.pnpm/semver@7.5.0/node_modules/semver/index.js"(exports, module2) {
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse2 = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse: parse2,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/version-check.js
var require_version_check = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/version-check.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.typescriptVersionIsAtLeast = void 0;
    var semver = __importStar2(require_semver2());
    var ts6 = __importStar2(require("typescript"));
    function semverCheck(version) {
      return semver.satisfies(ts6.version, `>= ${version}.0 || >= ${version}.1-rc || >= ${version}.0-beta`, {
        includePrerelease: true
      });
    }
    var versions = [
      "3.7",
      "3.8",
      "3.9",
      "4.0",
      "4.1",
      "4.2",
      "4.3",
      "4.4",
      "4.5",
      "4.6",
      "4.7",
      "4.8",
      "4.9",
      "5.0"
    ];
    var typescriptVersionIsAtLeast = {};
    exports.typescriptVersionIsAtLeast = typescriptVersionIsAtLeast;
    for (const version of versions) {
      typescriptVersionIsAtLeast[version] = semverCheck(version);
    }
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/getModifiers.js
var require_getModifiers = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/getModifiers.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDecorators = exports.getModifiers = void 0;
    var ts6 = __importStar2(require("typescript"));
    var version_check_1 = require_version_check();
    var isAtLeast48 = version_check_1.typescriptVersionIsAtLeast["4.8"];
    function getModifiers(node) {
      var _a2;
      if (node == null) {
        return void 0;
      }
      if (isAtLeast48) {
        if (ts6.canHaveModifiers(node)) {
          const modifiers = ts6.getModifiers(node);
          return modifiers ? Array.from(modifiers) : void 0;
        }
        return void 0;
      }
      return (
        // @ts-expect-error intentional fallback for older TS versions
        (_a2 = node.modifiers) === null || _a2 === void 0 ? void 0 : _a2.filter((m) => !ts6.isDecorator(m))
      );
    }
    exports.getModifiers = getModifiers;
    function getDecorators(node) {
      var _a2;
      if (node == null) {
        return void 0;
      }
      if (isAtLeast48) {
        if (ts6.canHaveDecorators(node)) {
          const decorators = ts6.getDecorators(node);
          return decorators ? Array.from(decorators) : void 0;
        }
        return void 0;
      }
      return (
        // @ts-expect-error intentional fallback for older TS versions
        (_a2 = node.decorators) === null || _a2 === void 0 ? void 0 : _a2.filter(ts6.isDecorator)
      );
    }
    exports.getDecorators = getDecorators;
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/jsx/xhtml-entities.js
var require_xhtml_entities = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/jsx/xhtml-entities.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.xhtmlEntities = void 0;
    exports.xhtmlEntities = {
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      times: "\xD7",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      divide: "\xF7",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      frasl: "\u2044",
      euro: "\u20AC",
      image: "\u2111",
      weierp: "\u2118",
      real: "\u211C",
      trade: "\u2122",
      alefsym: "\u2135",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lArr: "\u21D0",
      uArr: "\u21D1",
      rArr: "\u21D2",
      dArr: "\u21D3",
      hArr: "\u21D4",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      int: "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      lang: "\u2329",
      rang: "\u232A",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+types@5.59.2/node_modules/@typescript-eslint/types/dist/generated/ast-spec.js
var require_ast_spec = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+types@5.59.2/node_modules/@typescript-eslint/types/dist/generated/ast-spec.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AST_TOKEN_TYPES = exports.AST_NODE_TYPES = void 0;
    var AST_NODE_TYPES;
    (function(AST_NODE_TYPES2) {
      AST_NODE_TYPES2["AccessorProperty"] = "AccessorProperty";
      AST_NODE_TYPES2["ArrayExpression"] = "ArrayExpression";
      AST_NODE_TYPES2["ArrayPattern"] = "ArrayPattern";
      AST_NODE_TYPES2["ArrowFunctionExpression"] = "ArrowFunctionExpression";
      AST_NODE_TYPES2["AssignmentExpression"] = "AssignmentExpression";
      AST_NODE_TYPES2["AssignmentPattern"] = "AssignmentPattern";
      AST_NODE_TYPES2["AwaitExpression"] = "AwaitExpression";
      AST_NODE_TYPES2["BinaryExpression"] = "BinaryExpression";
      AST_NODE_TYPES2["BlockStatement"] = "BlockStatement";
      AST_NODE_TYPES2["BreakStatement"] = "BreakStatement";
      AST_NODE_TYPES2["CallExpression"] = "CallExpression";
      AST_NODE_TYPES2["CatchClause"] = "CatchClause";
      AST_NODE_TYPES2["ChainExpression"] = "ChainExpression";
      AST_NODE_TYPES2["ClassBody"] = "ClassBody";
      AST_NODE_TYPES2["ClassDeclaration"] = "ClassDeclaration";
      AST_NODE_TYPES2["ClassExpression"] = "ClassExpression";
      AST_NODE_TYPES2["ConditionalExpression"] = "ConditionalExpression";
      AST_NODE_TYPES2["ContinueStatement"] = "ContinueStatement";
      AST_NODE_TYPES2["DebuggerStatement"] = "DebuggerStatement";
      AST_NODE_TYPES2["Decorator"] = "Decorator";
      AST_NODE_TYPES2["DoWhileStatement"] = "DoWhileStatement";
      AST_NODE_TYPES2["EmptyStatement"] = "EmptyStatement";
      AST_NODE_TYPES2["ExportAllDeclaration"] = "ExportAllDeclaration";
      AST_NODE_TYPES2["ExportDefaultDeclaration"] = "ExportDefaultDeclaration";
      AST_NODE_TYPES2["ExportNamedDeclaration"] = "ExportNamedDeclaration";
      AST_NODE_TYPES2["ExportSpecifier"] = "ExportSpecifier";
      AST_NODE_TYPES2["ExpressionStatement"] = "ExpressionStatement";
      AST_NODE_TYPES2["ForInStatement"] = "ForInStatement";
      AST_NODE_TYPES2["ForOfStatement"] = "ForOfStatement";
      AST_NODE_TYPES2["ForStatement"] = "ForStatement";
      AST_NODE_TYPES2["FunctionDeclaration"] = "FunctionDeclaration";
      AST_NODE_TYPES2["FunctionExpression"] = "FunctionExpression";
      AST_NODE_TYPES2["Identifier"] = "Identifier";
      AST_NODE_TYPES2["IfStatement"] = "IfStatement";
      AST_NODE_TYPES2["ImportAttribute"] = "ImportAttribute";
      AST_NODE_TYPES2["ImportDeclaration"] = "ImportDeclaration";
      AST_NODE_TYPES2["ImportDefaultSpecifier"] = "ImportDefaultSpecifier";
      AST_NODE_TYPES2["ImportExpression"] = "ImportExpression";
      AST_NODE_TYPES2["ImportNamespaceSpecifier"] = "ImportNamespaceSpecifier";
      AST_NODE_TYPES2["ImportSpecifier"] = "ImportSpecifier";
      AST_NODE_TYPES2["JSXAttribute"] = "JSXAttribute";
      AST_NODE_TYPES2["JSXClosingElement"] = "JSXClosingElement";
      AST_NODE_TYPES2["JSXClosingFragment"] = "JSXClosingFragment";
      AST_NODE_TYPES2["JSXElement"] = "JSXElement";
      AST_NODE_TYPES2["JSXEmptyExpression"] = "JSXEmptyExpression";
      AST_NODE_TYPES2["JSXExpressionContainer"] = "JSXExpressionContainer";
      AST_NODE_TYPES2["JSXFragment"] = "JSXFragment";
      AST_NODE_TYPES2["JSXIdentifier"] = "JSXIdentifier";
      AST_NODE_TYPES2["JSXMemberExpression"] = "JSXMemberExpression";
      AST_NODE_TYPES2["JSXNamespacedName"] = "JSXNamespacedName";
      AST_NODE_TYPES2["JSXOpeningElement"] = "JSXOpeningElement";
      AST_NODE_TYPES2["JSXOpeningFragment"] = "JSXOpeningFragment";
      AST_NODE_TYPES2["JSXSpreadAttribute"] = "JSXSpreadAttribute";
      AST_NODE_TYPES2["JSXSpreadChild"] = "JSXSpreadChild";
      AST_NODE_TYPES2["JSXText"] = "JSXText";
      AST_NODE_TYPES2["LabeledStatement"] = "LabeledStatement";
      AST_NODE_TYPES2["Literal"] = "Literal";
      AST_NODE_TYPES2["LogicalExpression"] = "LogicalExpression";
      AST_NODE_TYPES2["MemberExpression"] = "MemberExpression";
      AST_NODE_TYPES2["MetaProperty"] = "MetaProperty";
      AST_NODE_TYPES2["MethodDefinition"] = "MethodDefinition";
      AST_NODE_TYPES2["NewExpression"] = "NewExpression";
      AST_NODE_TYPES2["ObjectExpression"] = "ObjectExpression";
      AST_NODE_TYPES2["ObjectPattern"] = "ObjectPattern";
      AST_NODE_TYPES2["PrivateIdentifier"] = "PrivateIdentifier";
      AST_NODE_TYPES2["Program"] = "Program";
      AST_NODE_TYPES2["Property"] = "Property";
      AST_NODE_TYPES2["PropertyDefinition"] = "PropertyDefinition";
      AST_NODE_TYPES2["RestElement"] = "RestElement";
      AST_NODE_TYPES2["ReturnStatement"] = "ReturnStatement";
      AST_NODE_TYPES2["SequenceExpression"] = "SequenceExpression";
      AST_NODE_TYPES2["SpreadElement"] = "SpreadElement";
      AST_NODE_TYPES2["StaticBlock"] = "StaticBlock";
      AST_NODE_TYPES2["Super"] = "Super";
      AST_NODE_TYPES2["SwitchCase"] = "SwitchCase";
      AST_NODE_TYPES2["SwitchStatement"] = "SwitchStatement";
      AST_NODE_TYPES2["TaggedTemplateExpression"] = "TaggedTemplateExpression";
      AST_NODE_TYPES2["TemplateElement"] = "TemplateElement";
      AST_NODE_TYPES2["TemplateLiteral"] = "TemplateLiteral";
      AST_NODE_TYPES2["ThisExpression"] = "ThisExpression";
      AST_NODE_TYPES2["ThrowStatement"] = "ThrowStatement";
      AST_NODE_TYPES2["TryStatement"] = "TryStatement";
      AST_NODE_TYPES2["UnaryExpression"] = "UnaryExpression";
      AST_NODE_TYPES2["UpdateExpression"] = "UpdateExpression";
      AST_NODE_TYPES2["VariableDeclaration"] = "VariableDeclaration";
      AST_NODE_TYPES2["VariableDeclarator"] = "VariableDeclarator";
      AST_NODE_TYPES2["WhileStatement"] = "WhileStatement";
      AST_NODE_TYPES2["WithStatement"] = "WithStatement";
      AST_NODE_TYPES2["YieldExpression"] = "YieldExpression";
      AST_NODE_TYPES2["TSAbstractAccessorProperty"] = "TSAbstractAccessorProperty";
      AST_NODE_TYPES2["TSAbstractKeyword"] = "TSAbstractKeyword";
      AST_NODE_TYPES2["TSAbstractMethodDefinition"] = "TSAbstractMethodDefinition";
      AST_NODE_TYPES2["TSAbstractPropertyDefinition"] = "TSAbstractPropertyDefinition";
      AST_NODE_TYPES2["TSAnyKeyword"] = "TSAnyKeyword";
      AST_NODE_TYPES2["TSArrayType"] = "TSArrayType";
      AST_NODE_TYPES2["TSAsExpression"] = "TSAsExpression";
      AST_NODE_TYPES2["TSAsyncKeyword"] = "TSAsyncKeyword";
      AST_NODE_TYPES2["TSBigIntKeyword"] = "TSBigIntKeyword";
      AST_NODE_TYPES2["TSBooleanKeyword"] = "TSBooleanKeyword";
      AST_NODE_TYPES2["TSCallSignatureDeclaration"] = "TSCallSignatureDeclaration";
      AST_NODE_TYPES2["TSClassImplements"] = "TSClassImplements";
      AST_NODE_TYPES2["TSConditionalType"] = "TSConditionalType";
      AST_NODE_TYPES2["TSConstructorType"] = "TSConstructorType";
      AST_NODE_TYPES2["TSConstructSignatureDeclaration"] = "TSConstructSignatureDeclaration";
      AST_NODE_TYPES2["TSDeclareFunction"] = "TSDeclareFunction";
      AST_NODE_TYPES2["TSDeclareKeyword"] = "TSDeclareKeyword";
      AST_NODE_TYPES2["TSEmptyBodyFunctionExpression"] = "TSEmptyBodyFunctionExpression";
      AST_NODE_TYPES2["TSEnumDeclaration"] = "TSEnumDeclaration";
      AST_NODE_TYPES2["TSEnumMember"] = "TSEnumMember";
      AST_NODE_TYPES2["TSExportAssignment"] = "TSExportAssignment";
      AST_NODE_TYPES2["TSExportKeyword"] = "TSExportKeyword";
      AST_NODE_TYPES2["TSExternalModuleReference"] = "TSExternalModuleReference";
      AST_NODE_TYPES2["TSFunctionType"] = "TSFunctionType";
      AST_NODE_TYPES2["TSInstantiationExpression"] = "TSInstantiationExpression";
      AST_NODE_TYPES2["TSImportEqualsDeclaration"] = "TSImportEqualsDeclaration";
      AST_NODE_TYPES2["TSImportType"] = "TSImportType";
      AST_NODE_TYPES2["TSIndexedAccessType"] = "TSIndexedAccessType";
      AST_NODE_TYPES2["TSIndexSignature"] = "TSIndexSignature";
      AST_NODE_TYPES2["TSInferType"] = "TSInferType";
      AST_NODE_TYPES2["TSInterfaceBody"] = "TSInterfaceBody";
      AST_NODE_TYPES2["TSInterfaceDeclaration"] = "TSInterfaceDeclaration";
      AST_NODE_TYPES2["TSInterfaceHeritage"] = "TSInterfaceHeritage";
      AST_NODE_TYPES2["TSIntersectionType"] = "TSIntersectionType";
      AST_NODE_TYPES2["TSIntrinsicKeyword"] = "TSIntrinsicKeyword";
      AST_NODE_TYPES2["TSLiteralType"] = "TSLiteralType";
      AST_NODE_TYPES2["TSMappedType"] = "TSMappedType";
      AST_NODE_TYPES2["TSMethodSignature"] = "TSMethodSignature";
      AST_NODE_TYPES2["TSModuleBlock"] = "TSModuleBlock";
      AST_NODE_TYPES2["TSModuleDeclaration"] = "TSModuleDeclaration";
      AST_NODE_TYPES2["TSNamedTupleMember"] = "TSNamedTupleMember";
      AST_NODE_TYPES2["TSNamespaceExportDeclaration"] = "TSNamespaceExportDeclaration";
      AST_NODE_TYPES2["TSNeverKeyword"] = "TSNeverKeyword";
      AST_NODE_TYPES2["TSNonNullExpression"] = "TSNonNullExpression";
      AST_NODE_TYPES2["TSNullKeyword"] = "TSNullKeyword";
      AST_NODE_TYPES2["TSNumberKeyword"] = "TSNumberKeyword";
      AST_NODE_TYPES2["TSObjectKeyword"] = "TSObjectKeyword";
      AST_NODE_TYPES2["TSOptionalType"] = "TSOptionalType";
      AST_NODE_TYPES2["TSParameterProperty"] = "TSParameterProperty";
      AST_NODE_TYPES2["TSPrivateKeyword"] = "TSPrivateKeyword";
      AST_NODE_TYPES2["TSPropertySignature"] = "TSPropertySignature";
      AST_NODE_TYPES2["TSProtectedKeyword"] = "TSProtectedKeyword";
      AST_NODE_TYPES2["TSPublicKeyword"] = "TSPublicKeyword";
      AST_NODE_TYPES2["TSQualifiedName"] = "TSQualifiedName";
      AST_NODE_TYPES2["TSReadonlyKeyword"] = "TSReadonlyKeyword";
      AST_NODE_TYPES2["TSRestType"] = "TSRestType";
      AST_NODE_TYPES2["TSSatisfiesExpression"] = "TSSatisfiesExpression";
      AST_NODE_TYPES2["TSStaticKeyword"] = "TSStaticKeyword";
      AST_NODE_TYPES2["TSStringKeyword"] = "TSStringKeyword";
      AST_NODE_TYPES2["TSSymbolKeyword"] = "TSSymbolKeyword";
      AST_NODE_TYPES2["TSTemplateLiteralType"] = "TSTemplateLiteralType";
      AST_NODE_TYPES2["TSThisType"] = "TSThisType";
      AST_NODE_TYPES2["TSTupleType"] = "TSTupleType";
      AST_NODE_TYPES2["TSTypeAliasDeclaration"] = "TSTypeAliasDeclaration";
      AST_NODE_TYPES2["TSTypeAnnotation"] = "TSTypeAnnotation";
      AST_NODE_TYPES2["TSTypeAssertion"] = "TSTypeAssertion";
      AST_NODE_TYPES2["TSTypeLiteral"] = "TSTypeLiteral";
      AST_NODE_TYPES2["TSTypeOperator"] = "TSTypeOperator";
      AST_NODE_TYPES2["TSTypeParameter"] = "TSTypeParameter";
      AST_NODE_TYPES2["TSTypeParameterDeclaration"] = "TSTypeParameterDeclaration";
      AST_NODE_TYPES2["TSTypeParameterInstantiation"] = "TSTypeParameterInstantiation";
      AST_NODE_TYPES2["TSTypePredicate"] = "TSTypePredicate";
      AST_NODE_TYPES2["TSTypeQuery"] = "TSTypeQuery";
      AST_NODE_TYPES2["TSTypeReference"] = "TSTypeReference";
      AST_NODE_TYPES2["TSUndefinedKeyword"] = "TSUndefinedKeyword";
      AST_NODE_TYPES2["TSUnionType"] = "TSUnionType";
      AST_NODE_TYPES2["TSUnknownKeyword"] = "TSUnknownKeyword";
      AST_NODE_TYPES2["TSVoidKeyword"] = "TSVoidKeyword";
    })(AST_NODE_TYPES = exports.AST_NODE_TYPES || (exports.AST_NODE_TYPES = {}));
    var AST_TOKEN_TYPES;
    (function(AST_TOKEN_TYPES2) {
      AST_TOKEN_TYPES2["Boolean"] = "Boolean";
      AST_TOKEN_TYPES2["Identifier"] = "Identifier";
      AST_TOKEN_TYPES2["JSXIdentifier"] = "JSXIdentifier";
      AST_TOKEN_TYPES2["JSXText"] = "JSXText";
      AST_TOKEN_TYPES2["Keyword"] = "Keyword";
      AST_TOKEN_TYPES2["Null"] = "Null";
      AST_TOKEN_TYPES2["Numeric"] = "Numeric";
      AST_TOKEN_TYPES2["Punctuator"] = "Punctuator";
      AST_TOKEN_TYPES2["RegularExpression"] = "RegularExpression";
      AST_TOKEN_TYPES2["String"] = "String";
      AST_TOKEN_TYPES2["Template"] = "Template";
      AST_TOKEN_TYPES2["Block"] = "Block";
      AST_TOKEN_TYPES2["Line"] = "Line";
    })(AST_TOKEN_TYPES = exports.AST_TOKEN_TYPES || (exports.AST_TOKEN_TYPES = {}));
  }
});

// node_modules/.pnpm/@typescript-eslint+types@5.59.2/node_modules/@typescript-eslint/types/dist/lib.js
var require_lib = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+types@5.59.2/node_modules/@typescript-eslint/types/dist/lib.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/@typescript-eslint+types@5.59.2/node_modules/@typescript-eslint/types/dist/parser-options.js
var require_parser_options = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+types@5.59.2/node_modules/@typescript-eslint/types/dist/parser-options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/@typescript-eslint+types@5.59.2/node_modules/@typescript-eslint/types/dist/ts-estree.js
var require_ts_estree = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+types@5.59.2/node_modules/@typescript-eslint/types/dist/ts-estree.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TSESTree = void 0;
    exports.TSESTree = __importStar2(require_ast_spec());
  }
});

// node_modules/.pnpm/@typescript-eslint+types@5.59.2/node_modules/@typescript-eslint/types/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+types@5.59.2/node_modules/@typescript-eslint/types/dist/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding2(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AST_TOKEN_TYPES = exports.AST_NODE_TYPES = void 0;
    var ast_spec_1 = require_ast_spec();
    Object.defineProperty(exports, "AST_NODE_TYPES", { enumerable: true, get: function() {
      return ast_spec_1.AST_NODE_TYPES;
    } });
    Object.defineProperty(exports, "AST_TOKEN_TYPES", { enumerable: true, get: function() {
      return ast_spec_1.AST_TOKEN_TYPES;
    } });
    __exportStar2(require_lib(), exports);
    __exportStar2(require_parser_options(), exports);
    __exportStar2(require_ts_estree(), exports);
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/ts-estree/ts-nodes.js
var require_ts_nodes = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/ts-estree/ts-nodes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/ts-estree/estree-to-ts-node-types.js
var require_estree_to_ts_node_types = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/ts-estree/estree-to-ts-node-types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/ts-estree/index.js
var require_ts_estree2 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/ts-estree/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding2(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TSESTree = exports.AST_TOKEN_TYPES = exports.AST_NODE_TYPES = void 0;
    var types_1 = require_dist();
    Object.defineProperty(exports, "AST_NODE_TYPES", { enumerable: true, get: function() {
      return types_1.AST_NODE_TYPES;
    } });
    Object.defineProperty(exports, "AST_TOKEN_TYPES", { enumerable: true, get: function() {
      return types_1.AST_TOKEN_TYPES;
    } });
    Object.defineProperty(exports, "TSESTree", { enumerable: true, get: function() {
      return types_1.TSESTree;
    } });
    __exportStar2(require_ts_nodes(), exports);
    __exportStar2(require_estree_to_ts_node_types(), exports);
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/node-utils.js
var require_node_utils = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/node-utils.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isThisInTypeQuery = exports.isThisIdentifier = exports.identifierIsThisKeyword = exports.firstDefined = exports.nodeHasTokens = exports.createError = exports.TSError = exports.convertTokens = exports.convertToken = exports.getTokenType = exports.isChildUnwrappableOptionalChain = exports.isChainExpression = exports.isOptional = exports.isComputedProperty = exports.unescapeStringLiteralText = exports.hasJSXAncestor = exports.findFirstMatchingAncestor = exports.findNextToken = exports.getTSNodeAccessibility = exports.getDeclarationKind = exports.isJSXToken = exports.isToken = exports.getRange = exports.canContainDirective = exports.getLocFor = exports.getLineAndCharacterFor = exports.getBinaryExpressionType = exports.isJSDocComment = exports.isComment = exports.isComma = exports.getLastModifier = exports.hasModifier = exports.isESTreeClassMember = exports.getTextForTokenKind = exports.isLogicalOperator = exports.isAssignmentOperator = void 0;
    var ts6 = __importStar2(require("typescript"));
    var getModifiers_1 = require_getModifiers();
    var xhtml_entities_1 = require_xhtml_entities();
    var ts_estree_1 = require_ts_estree2();
    var version_check_1 = require_version_check();
    var isAtLeast50 = version_check_1.typescriptVersionIsAtLeast["5.0"];
    var SyntaxKind = ts6.SyntaxKind;
    var LOGICAL_OPERATORS = [
      SyntaxKind.BarBarToken,
      SyntaxKind.AmpersandAmpersandToken,
      SyntaxKind.QuestionQuestionToken
    ];
    function isAssignmentOperator(operator) {
      return operator.kind >= SyntaxKind.FirstAssignment && operator.kind <= SyntaxKind.LastAssignment;
    }
    exports.isAssignmentOperator = isAssignmentOperator;
    function isLogicalOperator(operator) {
      return LOGICAL_OPERATORS.includes(operator.kind);
    }
    exports.isLogicalOperator = isLogicalOperator;
    function getTextForTokenKind(kind) {
      return ts6.tokenToString(kind);
    }
    exports.getTextForTokenKind = getTextForTokenKind;
    function isESTreeClassMember(node) {
      return node.kind !== SyntaxKind.SemicolonClassElement;
    }
    exports.isESTreeClassMember = isESTreeClassMember;
    function hasModifier(modifierKind, node) {
      const modifiers = (0, getModifiers_1.getModifiers)(node);
      return (modifiers === null || modifiers === void 0 ? void 0 : modifiers.some((modifier) => modifier.kind === modifierKind)) === true;
    }
    exports.hasModifier = hasModifier;
    function getLastModifier(node) {
      var _a2;
      const modifiers = (0, getModifiers_1.getModifiers)(node);
      if (modifiers == null) {
        return null;
      }
      return (_a2 = modifiers[modifiers.length - 1]) !== null && _a2 !== void 0 ? _a2 : null;
    }
    exports.getLastModifier = getLastModifier;
    function isComma(token) {
      return token.kind === SyntaxKind.CommaToken;
    }
    exports.isComma = isComma;
    function isComment(node) {
      return node.kind === SyntaxKind.SingleLineCommentTrivia || node.kind === SyntaxKind.MultiLineCommentTrivia;
    }
    exports.isComment = isComment;
    function isJSDocComment(node) {
      return node.kind === SyntaxKind.JSDocComment;
    }
    exports.isJSDocComment = isJSDocComment;
    function getBinaryExpressionType(operator) {
      if (isAssignmentOperator(operator)) {
        return ts_estree_1.AST_NODE_TYPES.AssignmentExpression;
      } else if (isLogicalOperator(operator)) {
        return ts_estree_1.AST_NODE_TYPES.LogicalExpression;
      }
      return ts_estree_1.AST_NODE_TYPES.BinaryExpression;
    }
    exports.getBinaryExpressionType = getBinaryExpressionType;
    function getLineAndCharacterFor(pos, ast) {
      const loc = ast.getLineAndCharacterOfPosition(pos);
      return {
        line: loc.line + 1,
        column: loc.character
      };
    }
    exports.getLineAndCharacterFor = getLineAndCharacterFor;
    function getLocFor(start, end, ast) {
      return {
        start: getLineAndCharacterFor(start, ast),
        end: getLineAndCharacterFor(end, ast)
      };
    }
    exports.getLocFor = getLocFor;
    function canContainDirective(node) {
      if (node.kind === ts6.SyntaxKind.Block) {
        switch (node.parent.kind) {
          case ts6.SyntaxKind.Constructor:
          case ts6.SyntaxKind.GetAccessor:
          case ts6.SyntaxKind.SetAccessor:
          case ts6.SyntaxKind.ArrowFunction:
          case ts6.SyntaxKind.FunctionExpression:
          case ts6.SyntaxKind.FunctionDeclaration:
          case ts6.SyntaxKind.MethodDeclaration:
            return true;
          default:
            return false;
        }
      }
      return true;
    }
    exports.canContainDirective = canContainDirective;
    function getRange(node, ast) {
      return [node.getStart(ast), node.getEnd()];
    }
    exports.getRange = getRange;
    function isToken(node) {
      return node.kind >= SyntaxKind.FirstToken && node.kind <= SyntaxKind.LastToken;
    }
    exports.isToken = isToken;
    function isJSXToken(node) {
      return node.kind >= SyntaxKind.JsxElement && node.kind <= SyntaxKind.JsxAttribute;
    }
    exports.isJSXToken = isJSXToken;
    function getDeclarationKind(node) {
      if (node.flags & ts6.NodeFlags.Let) {
        return "let";
      }
      if (node.flags & ts6.NodeFlags.Const) {
        return "const";
      }
      return "var";
    }
    exports.getDeclarationKind = getDeclarationKind;
    function getTSNodeAccessibility(node) {
      const modifiers = (0, getModifiers_1.getModifiers)(node);
      if (modifiers == null) {
        return null;
      }
      for (const modifier of modifiers) {
        switch (modifier.kind) {
          case SyntaxKind.PublicKeyword:
            return "public";
          case SyntaxKind.ProtectedKeyword:
            return "protected";
          case SyntaxKind.PrivateKeyword:
            return "private";
          default:
            break;
        }
      }
      return null;
    }
    exports.getTSNodeAccessibility = getTSNodeAccessibility;
    function findNextToken(previousToken, parent, ast) {
      return find(parent);
      function find(n) {
        if (ts6.isToken(n) && n.pos === previousToken.end) {
          return n;
        }
        return firstDefined(n.getChildren(ast), (child) => {
          const shouldDiveInChildNode = (
            // previous token is enclosed somewhere in the child
            child.pos <= previousToken.pos && child.end > previousToken.end || // previous token ends exactly at the beginning of child
            child.pos === previousToken.end
          );
          return shouldDiveInChildNode && nodeHasTokens(child, ast) ? find(child) : void 0;
        });
      }
    }
    exports.findNextToken = findNextToken;
    function findFirstMatchingAncestor(node, predicate) {
      while (node) {
        if (predicate(node)) {
          return node;
        }
        node = node.parent;
      }
      return void 0;
    }
    exports.findFirstMatchingAncestor = findFirstMatchingAncestor;
    function hasJSXAncestor(node) {
      return !!findFirstMatchingAncestor(node, isJSXToken);
    }
    exports.hasJSXAncestor = hasJSXAncestor;
    function unescapeStringLiteralText(text) {
      return text.replace(/&(?:#\d+|#x[\da-fA-F]+|[0-9a-zA-Z]+);/g, (entity) => {
        const item = entity.slice(1, -1);
        if (item[0] === "#") {
          const codePoint = item[1] === "x" ? parseInt(item.slice(2), 16) : parseInt(item.slice(1), 10);
          return codePoint > 1114111 ? entity : String.fromCodePoint(codePoint);
        }
        return xhtml_entities_1.xhtmlEntities[item] || entity;
      });
    }
    exports.unescapeStringLiteralText = unescapeStringLiteralText;
    function isComputedProperty(node) {
      return node.kind === SyntaxKind.ComputedPropertyName;
    }
    exports.isComputedProperty = isComputedProperty;
    function isOptional(node) {
      return node.questionToken ? node.questionToken.kind === SyntaxKind.QuestionToken : false;
    }
    exports.isOptional = isOptional;
    function isChainExpression(node) {
      return node.type === ts_estree_1.AST_NODE_TYPES.ChainExpression;
    }
    exports.isChainExpression = isChainExpression;
    function isChildUnwrappableOptionalChain(node, child) {
      return isChainExpression(child) && // (x?.y).z is semantically different, and as such .z is no longer optional
      node.expression.kind !== ts6.SyntaxKind.ParenthesizedExpression;
    }
    exports.isChildUnwrappableOptionalChain = isChildUnwrappableOptionalChain;
    function getTokenType(token) {
      let keywordKind;
      if (isAtLeast50 && token.kind === SyntaxKind.Identifier) {
        keywordKind = ts6.identifierToKeywordKind(token);
      } else if ("originalKeywordKind" in token) {
        keywordKind = token.originalKeywordKind;
      }
      if (keywordKind) {
        if (keywordKind === SyntaxKind.NullKeyword) {
          return ts_estree_1.AST_TOKEN_TYPES.Null;
        } else if (keywordKind >= SyntaxKind.FirstFutureReservedWord && keywordKind <= SyntaxKind.LastKeyword) {
          return ts_estree_1.AST_TOKEN_TYPES.Identifier;
        }
        return ts_estree_1.AST_TOKEN_TYPES.Keyword;
      }
      if (token.kind >= SyntaxKind.FirstKeyword && token.kind <= SyntaxKind.LastFutureReservedWord) {
        if (token.kind === SyntaxKind.FalseKeyword || token.kind === SyntaxKind.TrueKeyword) {
          return ts_estree_1.AST_TOKEN_TYPES.Boolean;
        }
        return ts_estree_1.AST_TOKEN_TYPES.Keyword;
      }
      if (token.kind >= SyntaxKind.FirstPunctuation && token.kind <= SyntaxKind.LastPunctuation) {
        return ts_estree_1.AST_TOKEN_TYPES.Punctuator;
      }
      if (token.kind >= SyntaxKind.NoSubstitutionTemplateLiteral && token.kind <= SyntaxKind.TemplateTail) {
        return ts_estree_1.AST_TOKEN_TYPES.Template;
      }
      switch (token.kind) {
        case SyntaxKind.NumericLiteral:
          return ts_estree_1.AST_TOKEN_TYPES.Numeric;
        case SyntaxKind.JsxText:
          return ts_estree_1.AST_TOKEN_TYPES.JSXText;
        case SyntaxKind.StringLiteral:
          if (token.parent && (token.parent.kind === SyntaxKind.JsxAttribute || token.parent.kind === SyntaxKind.JsxElement)) {
            return ts_estree_1.AST_TOKEN_TYPES.JSXText;
          }
          return ts_estree_1.AST_TOKEN_TYPES.String;
        case SyntaxKind.RegularExpressionLiteral:
          return ts_estree_1.AST_TOKEN_TYPES.RegularExpression;
        case SyntaxKind.Identifier:
        case SyntaxKind.ConstructorKeyword:
        case SyntaxKind.GetKeyword:
        case SyntaxKind.SetKeyword:
        default:
      }
      if (token.parent && token.kind === SyntaxKind.Identifier) {
        if (isJSXToken(token.parent)) {
          return ts_estree_1.AST_TOKEN_TYPES.JSXIdentifier;
        }
        if (token.parent.kind === SyntaxKind.PropertyAccessExpression && hasJSXAncestor(token)) {
          return ts_estree_1.AST_TOKEN_TYPES.JSXIdentifier;
        }
      }
      return ts_estree_1.AST_TOKEN_TYPES.Identifier;
    }
    exports.getTokenType = getTokenType;
    function convertToken(token, ast) {
      const start = token.kind === SyntaxKind.JsxText ? token.getFullStart() : token.getStart(ast);
      const end = token.getEnd();
      const value = ast.text.slice(start, end);
      const tokenType = getTokenType(token);
      if (tokenType === ts_estree_1.AST_TOKEN_TYPES.RegularExpression) {
        return {
          type: tokenType,
          value,
          range: [start, end],
          loc: getLocFor(start, end, ast),
          regex: {
            pattern: value.slice(1, value.lastIndexOf("/")),
            flags: value.slice(value.lastIndexOf("/") + 1)
          }
        };
      } else {
        return {
          type: tokenType,
          value,
          range: [start, end],
          loc: getLocFor(start, end, ast)
        };
      }
    }
    exports.convertToken = convertToken;
    function convertTokens(ast) {
      const result = [];
      function walk(node) {
        if (isComment(node) || isJSDocComment(node)) {
          return;
        }
        if (isToken(node) && node.kind !== SyntaxKind.EndOfFileToken) {
          const converted = convertToken(node, ast);
          if (converted) {
            result.push(converted);
          }
        } else {
          node.getChildren(ast).forEach(walk);
        }
      }
      walk(ast);
      return result;
    }
    exports.convertTokens = convertTokens;
    var TSError = class extends Error {
      constructor(message, fileName, index, lineNumber, column) {
        super(message);
        this.fileName = fileName;
        this.index = index;
        this.lineNumber = lineNumber;
        this.column = column;
        Object.defineProperty(this, "name", {
          value: new.target.name,
          enumerable: false,
          configurable: true
        });
      }
    };
    exports.TSError = TSError;
    function createError(ast, start, message) {
      const loc = ast.getLineAndCharacterOfPosition(start);
      return new TSError(message, ast.fileName, start, loc.line + 1, loc.character);
    }
    exports.createError = createError;
    function nodeHasTokens(n, ast) {
      return n.kind === SyntaxKind.EndOfFileToken ? !!n.jsDoc : n.getWidth(ast) !== 0;
    }
    exports.nodeHasTokens = nodeHasTokens;
    function firstDefined(array, callback) {
      if (array === void 0) {
        return void 0;
      }
      for (let i = 0; i < array.length; i++) {
        const result = callback(array[i], i);
        if (result !== void 0) {
          return result;
        }
      }
      return void 0;
    }
    exports.firstDefined = firstDefined;
    function identifierIsThisKeyword(id) {
      return (
        // eslint-disable-next-line deprecation/deprecation -- intentional for older TS versions
        (isAtLeast50 ? ts6.identifierToKeywordKind(id) : id.originalKeywordKind) === SyntaxKind.ThisKeyword
      );
    }
    exports.identifierIsThisKeyword = identifierIsThisKeyword;
    function isThisIdentifier(node) {
      return !!node && node.kind === SyntaxKind.Identifier && identifierIsThisKeyword(node);
    }
    exports.isThisIdentifier = isThisIdentifier;
    function isThisInTypeQuery(node) {
      if (!isThisIdentifier(node)) {
        return false;
      }
      while (ts6.isQualifiedName(node.parent) && node.parent.left === node) {
        node = node.parent;
      }
      return node.parent.kind === SyntaxKind.TypeQuery;
    }
    exports.isThisInTypeQuery = isThisInTypeQuery;
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/convert.js
var require_convert = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/convert.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Converter = exports.convertError = void 0;
    var ts6 = __importStar2(require("typescript"));
    var getModifiers_1 = require_getModifiers();
    var node_utils_1 = require_node_utils();
    var ts_estree_1 = require_ts_estree2();
    var version_check_1 = require_version_check();
    var SyntaxKind = ts6.SyntaxKind;
    function convertError(error) {
      return (0, node_utils_1.createError)(error.file, error.start, "message" in error && error.message || error.messageText);
    }
    exports.convertError = convertError;
    var Converter = class {
      /**
       * Converts a TypeScript node into an ESTree node
       * @param ast the full TypeScript AST
       * @param options additional options for the conversion
       * @returns the converted ESTreeNode
       */
      constructor(ast, options) {
        this.esTreeNodeToTSNodeMap = /* @__PURE__ */ new WeakMap();
        this.tsNodeToESTreeNodeMap = /* @__PURE__ */ new WeakMap();
        this.allowPattern = false;
        this.inTypeMode = false;
        this.ast = ast;
        this.options = Object.assign({}, options);
      }
      getASTMaps() {
        return {
          esTreeNodeToTSNodeMap: this.esTreeNodeToTSNodeMap,
          tsNodeToESTreeNodeMap: this.tsNodeToESTreeNodeMap
        };
      }
      convertProgram() {
        return this.converter(this.ast);
      }
      /**
       * Converts a TypeScript node into an ESTree node.
       * @param node the child ts.Node
       * @param parent parentNode
       * @param inTypeMode flag to determine if we are in typeMode
       * @param allowPattern flag to determine if patterns are allowed
       * @returns the converted ESTree node
       */
      converter(node, parent, inTypeMode, allowPattern) {
        if (!node) {
          return null;
        }
        const typeMode = this.inTypeMode;
        const pattern = this.allowPattern;
        if (inTypeMode !== void 0) {
          this.inTypeMode = inTypeMode;
        }
        if (allowPattern !== void 0) {
          this.allowPattern = allowPattern;
        }
        const result = this.convertNode(node, parent !== null && parent !== void 0 ? parent : node.parent);
        this.registerTSNodeInNodeMap(node, result);
        this.inTypeMode = typeMode;
        this.allowPattern = pattern;
        return result;
      }
      /**
       * Fixes the exports of the given ts.Node
       * @param node the ts.Node
       * @param result result
       * @returns the ESTreeNode with fixed exports
       */
      fixExports(node, result) {
        const modifiers = (0, getModifiers_1.getModifiers)(node);
        if ((modifiers === null || modifiers === void 0 ? void 0 : modifiers[0].kind) === SyntaxKind.ExportKeyword) {
          this.registerTSNodeInNodeMap(node, result);
          const exportKeyword = modifiers[0];
          const nextModifier = modifiers[1];
          const declarationIsDefault = nextModifier && nextModifier.kind === SyntaxKind.DefaultKeyword;
          const varToken = declarationIsDefault ? (0, node_utils_1.findNextToken)(nextModifier, this.ast, this.ast) : (0, node_utils_1.findNextToken)(exportKeyword, this.ast, this.ast);
          result.range[0] = varToken.getStart(this.ast);
          result.loc = (0, node_utils_1.getLocFor)(result.range[0], result.range[1], this.ast);
          if (declarationIsDefault) {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ExportDefaultDeclaration,
              declaration: result,
              range: [exportKeyword.getStart(this.ast), result.range[1]],
              exportKind: "value"
            });
          } else {
            const isType = result.type === ts_estree_1.AST_NODE_TYPES.TSInterfaceDeclaration || result.type === ts_estree_1.AST_NODE_TYPES.TSTypeAliasDeclaration;
            const isDeclare = "declare" in result && result.declare === true;
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ExportNamedDeclaration,
              // @ts-expect-error - TODO, narrow the types here
              declaration: result,
              specifiers: [],
              source: null,
              exportKind: isType || isDeclare ? "type" : "value",
              range: [exportKeyword.getStart(this.ast), result.range[1]],
              assertions: []
            });
          }
        }
        return result;
      }
      /**
       * Register specific TypeScript node into map with first ESTree node provided
       */
      registerTSNodeInNodeMap(node, result) {
        if (result && this.options.shouldPreserveNodeMaps) {
          if (!this.tsNodeToESTreeNodeMap.has(node)) {
            this.tsNodeToESTreeNodeMap.set(node, result);
          }
        }
      }
      /**
       * Converts a TypeScript node into an ESTree node.
       * @param child the child ts.Node
       * @param parent parentNode
       * @returns the converted ESTree node
       */
      convertPattern(child, parent) {
        return this.converter(child, parent, this.inTypeMode, true);
      }
      /**
       * Converts a TypeScript node into an ESTree node.
       * @param child the child ts.Node
       * @param parent parentNode
       * @returns the converted ESTree node
       */
      convertChild(child, parent) {
        return this.converter(child, parent, this.inTypeMode, false);
      }
      /**
       * Converts a TypeScript node into an ESTree node.
       * @param child the child ts.Node
       * @param parent parentNode
       * @returns the converted ESTree node
       */
      convertType(child, parent) {
        return this.converter(child, parent, true, false);
      }
      createNode(node, data) {
        const result = data;
        if (!result.range) {
          result.range = (0, node_utils_1.getRange)(
            // this is completely valid, but TS hates it
            node,
            this.ast
          );
        }
        if (!result.loc) {
          result.loc = (0, node_utils_1.getLocFor)(result.range[0], result.range[1], this.ast);
        }
        if (result && this.options.shouldPreserveNodeMaps) {
          this.esTreeNodeToTSNodeMap.set(result, node);
        }
        return result;
      }
      convertBindingNameWithTypeAnnotation(name, tsType, parent) {
        const id = this.convertPattern(name);
        if (tsType) {
          id.typeAnnotation = this.convertTypeAnnotation(tsType, parent);
          this.fixParentLocation(id, id.typeAnnotation.range);
        }
        return id;
      }
      /**
       * Converts a child into a type annotation. This creates an intermediary
       * TypeAnnotation node to match what Flow does.
       * @param child The TypeScript AST node to convert.
       * @param parent parentNode
       * @returns The type annotation node.
       */
      convertTypeAnnotation(child, parent) {
        const offset = (parent === null || parent === void 0 ? void 0 : parent.kind) === SyntaxKind.FunctionType || (parent === null || parent === void 0 ? void 0 : parent.kind) === SyntaxKind.ConstructorType ? 2 : 1;
        const annotationStartCol = child.getFullStart() - offset;
        const loc = (0, node_utils_1.getLocFor)(annotationStartCol, child.end, this.ast);
        return {
          type: ts_estree_1.AST_NODE_TYPES.TSTypeAnnotation,
          loc,
          range: [annotationStartCol, child.end],
          typeAnnotation: this.convertType(child)
        };
      }
      /**
       * Coverts body Nodes and add a directive field to StringLiterals
       * @param nodes of ts.Node
       * @param parent parentNode
       * @returns Array of body statements
       */
      convertBodyExpressions(nodes, parent) {
        let allowDirectives = (0, node_utils_1.canContainDirective)(parent);
        return nodes.map((statement) => {
          const child = this.convertChild(statement);
          if (allowDirectives) {
            if ((child === null || child === void 0 ? void 0 : child.expression) && ts6.isExpressionStatement(statement) && ts6.isStringLiteral(statement.expression)) {
              const raw = child.expression.raw;
              child.directive = raw.slice(1, -1);
              return child;
            } else {
              allowDirectives = false;
            }
          }
          return child;
        }).filter((statement) => statement);
      }
      /**
       * Converts a ts.Node's typeArguments to TSTypeParameterInstantiation node
       * @param typeArguments ts.NodeArray typeArguments
       * @param node parent used to create this node
       * @returns TypeParameterInstantiation node
       */
      convertTypeArgumentsToTypeParameters(typeArguments, node) {
        const greaterThanToken = (0, node_utils_1.findNextToken)(typeArguments, this.ast, this.ast);
        return this.createNode(node, {
          type: ts_estree_1.AST_NODE_TYPES.TSTypeParameterInstantiation,
          range: [typeArguments.pos - 1, greaterThanToken.end],
          params: typeArguments.map((typeArgument) => this.convertType(typeArgument))
        });
      }
      /**
       * Converts a ts.Node's typeParameters to TSTypeParameterDeclaration node
       * @param typeParameters ts.Node typeParameters
       * @returns TypeParameterDeclaration node
       */
      convertTSTypeParametersToTypeParametersDeclaration(typeParameters) {
        const greaterThanToken = (0, node_utils_1.findNextToken)(typeParameters, this.ast, this.ast);
        return {
          type: ts_estree_1.AST_NODE_TYPES.TSTypeParameterDeclaration,
          range: [typeParameters.pos - 1, greaterThanToken.end],
          loc: (0, node_utils_1.getLocFor)(typeParameters.pos - 1, greaterThanToken.end, this.ast),
          params: typeParameters.map((typeParameter) => this.convertType(typeParameter))
        };
      }
      /**
       * Converts an array of ts.Node parameters into an array of ESTreeNode params
       * @param parameters An array of ts.Node params to be converted
       * @returns an array of converted ESTreeNode params
       */
      convertParameters(parameters) {
        if (!(parameters === null || parameters === void 0 ? void 0 : parameters.length)) {
          return [];
        }
        return parameters.map((param) => {
          const convertedParam = this.convertChild(param);
          const decorators = (0, getModifiers_1.getDecorators)(param);
          if (decorators === null || decorators === void 0 ? void 0 : decorators.length) {
            convertedParam.decorators = decorators.map((el) => this.convertChild(el));
          }
          return convertedParam;
        });
      }
      convertChainExpression(node, tsNode) {
        const { child, isOptional } = (() => {
          if (node.type === ts_estree_1.AST_NODE_TYPES.MemberExpression) {
            return { child: node.object, isOptional: node.optional };
          }
          if (node.type === ts_estree_1.AST_NODE_TYPES.CallExpression) {
            return { child: node.callee, isOptional: node.optional };
          }
          return { child: node.expression, isOptional: false };
        })();
        const isChildUnwrappable = (0, node_utils_1.isChildUnwrappableOptionalChain)(tsNode, child);
        if (!isChildUnwrappable && !isOptional) {
          return node;
        }
        if (isChildUnwrappable && (0, node_utils_1.isChainExpression)(child)) {
          const newChild = child.expression;
          if (node.type === ts_estree_1.AST_NODE_TYPES.MemberExpression) {
            node.object = newChild;
          } else if (node.type === ts_estree_1.AST_NODE_TYPES.CallExpression) {
            node.callee = newChild;
          } else {
            node.expression = newChild;
          }
        }
        return this.createNode(tsNode, {
          type: ts_estree_1.AST_NODE_TYPES.ChainExpression,
          expression: node
        });
      }
      /**
       * For nodes that are copied directly from the TypeScript AST into
       * ESTree mostly as-is. The only difference is the addition of a type
       * property instead of a kind property. Recursively copies all children.
       */
      deeplyCopy(node) {
        if (node.kind === ts6.SyntaxKind.JSDocFunctionType) {
          throw (0, node_utils_1.createError)(this.ast, node.pos, "JSDoc types can only be used inside documentation comments.");
        }
        const customType = `TS${SyntaxKind[node.kind]}`;
        if (this.options.errorOnUnknownASTType && !ts_estree_1.AST_NODE_TYPES[customType]) {
          throw new Error(`Unknown AST_NODE_TYPE: "${customType}"`);
        }
        const result = this.createNode(node, {
          type: customType
        });
        if ("type" in node) {
          result.typeAnnotation = node.type && "kind" in node.type && ts6.isTypeNode(node.type) ? this.convertTypeAnnotation(node.type, node) : null;
        }
        if ("typeArguments" in node) {
          result.typeParameters = node.typeArguments && "pos" in node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : null;
        }
        if ("typeParameters" in node) {
          result.typeParameters = node.typeParameters && "pos" in node.typeParameters ? this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters) : null;
        }
        const decorators = (0, getModifiers_1.getDecorators)(node);
        if (decorators === null || decorators === void 0 ? void 0 : decorators.length) {
          result.decorators = decorators.map((el) => this.convertChild(el));
        }
        const KEYS_TO_NOT_COPY = /* @__PURE__ */ new Set([
          "_children",
          "decorators",
          "end",
          "flags",
          "illegalDecorators",
          "heritageClauses",
          "locals",
          "localSymbol",
          "jsDoc",
          "kind",
          "modifierFlagsCache",
          "modifiers",
          "nextContainer",
          "parent",
          "pos",
          "symbol",
          "transformFlags",
          "type",
          "typeArguments",
          "typeParameters"
        ]);
        Object.entries(node).filter(([key]) => !KEYS_TO_NOT_COPY.has(key)).forEach(([key, value]) => {
          if (Array.isArray(value)) {
            result[key] = value.map((el) => this.convertChild(el));
          } else if (value && typeof value === "object" && value.kind) {
            result[key] = this.convertChild(value);
          } else {
            result[key] = value;
          }
        });
        return result;
      }
      convertJSXIdentifier(node) {
        const result = this.createNode(node, {
          type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,
          name: node.getText()
        });
        this.registerTSNodeInNodeMap(node, result);
        return result;
      }
      convertJSXNamespaceOrIdentifier(node) {
        const text = node.getText();
        const colonIndex = text.indexOf(":");
        if (colonIndex > 0) {
          const range = (0, node_utils_1.getRange)(node, this.ast);
          const result = this.createNode(node, {
            type: ts_estree_1.AST_NODE_TYPES.JSXNamespacedName,
            namespace: this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,
              name: text.slice(0, colonIndex),
              range: [range[0], range[0] + colonIndex]
            }),
            name: this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,
              name: text.slice(colonIndex + 1),
              range: [range[0] + colonIndex + 1, range[1]]
            }),
            range
          });
          this.registerTSNodeInNodeMap(node, result);
          return result;
        }
        return this.convertJSXIdentifier(node);
      }
      /**
       * Converts a TypeScript JSX node.tagName into an ESTree node.name
       * @param node the tagName object from a JSX ts.Node
       * @param parent
       * @returns the converted ESTree name object
       */
      convertJSXTagName(node, parent) {
        let result;
        switch (node.kind) {
          case SyntaxKind.PropertyAccessExpression:
            if (node.name.kind === SyntaxKind.PrivateIdentifier) {
              throw new Error("Non-private identifier expected.");
            }
            result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.JSXMemberExpression,
              object: this.convertJSXTagName(node.expression, parent),
              property: this.convertJSXIdentifier(node.name)
            });
            break;
          case SyntaxKind.ThisKeyword:
          case SyntaxKind.Identifier:
          default:
            return this.convertJSXNamespaceOrIdentifier(node);
        }
        this.registerTSNodeInNodeMap(node, result);
        return result;
      }
      convertMethodSignature(node) {
        const result = this.createNode(node, {
          type: ts_estree_1.AST_NODE_TYPES.TSMethodSignature,
          computed: (0, node_utils_1.isComputedProperty)(node.name),
          key: this.convertChild(node.name),
          params: this.convertParameters(node.parameters),
          kind: (() => {
            switch (node.kind) {
              case SyntaxKind.GetAccessor:
                return "get";
              case SyntaxKind.SetAccessor:
                return "set";
              case SyntaxKind.MethodSignature:
                return "method";
            }
          })()
        });
        if ((0, node_utils_1.isOptional)(node)) {
          result.optional = true;
        }
        if (node.type) {
          result.returnType = this.convertTypeAnnotation(node.type, node);
        }
        if ((0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node)) {
          result.readonly = true;
        }
        if (node.typeParameters) {
          result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);
        }
        const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);
        if (accessibility) {
          result.accessibility = accessibility;
        }
        if ((0, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node)) {
          result.export = true;
        }
        if ((0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node)) {
          result.static = true;
        }
        return result;
      }
      convertAssertClasue(node) {
        return node === void 0 ? [] : node.elements.map((element) => this.convertChild(element));
      }
      /**
       * Applies the given TS modifiers to the given result object.
       *
       * This method adds not standardized `modifiers` property in nodes
       *
       * @param result
       * @param modifiers original ts.Nodes from the node.modifiers array
       * @returns the current result object will be mutated
       */
      applyModifiersToResult(result, modifiers) {
        if (!modifiers) {
          return;
        }
        const remainingModifiers = [];
        for (const modifier of modifiers) {
          switch (modifier.kind) {
            case SyntaxKind.ExportKeyword:
            case SyntaxKind.DefaultKeyword:
              break;
            case SyntaxKind.ConstKeyword:
              result.const = true;
              break;
            case SyntaxKind.DeclareKeyword:
              result.declare = true;
              break;
            default:
              remainingModifiers.push(this.convertChild(modifier));
              break;
          }
        }
        if (remainingModifiers.length > 0) {
          result.modifiers = remainingModifiers;
        }
      }
      /**
       * Uses the provided range location to adjust the location data of the given Node
       * @param result The node that will have its location data mutated
       * @param childRange The child node range used to expand location
       */
      fixParentLocation(result, childRange) {
        if (childRange[0] < result.range[0]) {
          result.range[0] = childRange[0];
          result.loc.start = (0, node_utils_1.getLineAndCharacterFor)(result.range[0], this.ast);
        }
        if (childRange[1] > result.range[1]) {
          result.range[1] = childRange[1];
          result.loc.end = (0, node_utils_1.getLineAndCharacterFor)(result.range[1], this.ast);
        }
      }
      assertModuleSpecifier(node, allowNull) {
        var _a2;
        if (!allowNull && node.moduleSpecifier == null) {
          throw (0, node_utils_1.createError)(this.ast, node.pos, "Module specifier must be a string literal.");
        }
        if (node.moduleSpecifier && ((_a2 = node.moduleSpecifier) === null || _a2 === void 0 ? void 0 : _a2.kind) !== SyntaxKind.StringLiteral) {
          throw (0, node_utils_1.createError)(this.ast, node.moduleSpecifier.pos, "Module specifier must be a string literal.");
        }
      }
      /**
       * Converts a TypeScript node into an ESTree node.
       * The core of the conversion logic:
       * Identify and convert each relevant TypeScript SyntaxKind
       * @param node the child ts.Node
       * @param parent parentNode
       * @returns the converted ESTree node
       */
      convertNode(node, parent) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        switch (node.kind) {
          case SyntaxKind.SourceFile: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.Program,
              body: this.convertBodyExpressions(node.statements, node),
              sourceType: node.externalModuleIndicator ? "module" : "script",
              range: [node.getStart(this.ast), node.endOfFileToken.end]
            });
          }
          case SyntaxKind.Block: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.BlockStatement,
              body: this.convertBodyExpressions(node.statements, node)
            });
          }
          case SyntaxKind.Identifier: {
            if ((0, node_utils_1.isThisInTypeQuery)(node)) {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.ThisExpression
              });
            }
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.Identifier,
              name: node.text
            });
          }
          case SyntaxKind.PrivateIdentifier: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.PrivateIdentifier,
              // typescript includes the `#` in the text
              name: node.text.slice(1)
            });
          }
          case SyntaxKind.WithStatement:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.WithStatement,
              object: this.convertChild(node.expression),
              body: this.convertChild(node.statement)
            });
          case SyntaxKind.ReturnStatement:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ReturnStatement,
              argument: this.convertChild(node.expression)
            });
          case SyntaxKind.LabeledStatement:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.LabeledStatement,
              label: this.convertChild(node.label),
              body: this.convertChild(node.statement)
            });
          case SyntaxKind.ContinueStatement:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ContinueStatement,
              label: this.convertChild(node.label)
            });
          case SyntaxKind.BreakStatement:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.BreakStatement,
              label: this.convertChild(node.label)
            });
          case SyntaxKind.IfStatement:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.IfStatement,
              test: this.convertChild(node.expression),
              consequent: this.convertChild(node.thenStatement),
              alternate: this.convertChild(node.elseStatement)
            });
          case SyntaxKind.SwitchStatement:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.SwitchStatement,
              discriminant: this.convertChild(node.expression),
              cases: node.caseBlock.clauses.map((el) => this.convertChild(el))
            });
          case SyntaxKind.CaseClause:
          case SyntaxKind.DefaultClause:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.SwitchCase,
              // expression is present in case only
              test: node.kind === SyntaxKind.CaseClause ? this.convertChild(node.expression) : null,
              consequent: node.statements.map((el) => this.convertChild(el))
            });
          case SyntaxKind.ThrowStatement:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ThrowStatement,
              argument: this.convertChild(node.expression)
            });
          case SyntaxKind.TryStatement:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TryStatement,
              block: this.convertChild(node.tryBlock),
              handler: this.convertChild(node.catchClause),
              finalizer: this.convertChild(node.finallyBlock)
            });
          case SyntaxKind.CatchClause:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.CatchClause,
              param: node.variableDeclaration ? this.convertBindingNameWithTypeAnnotation(node.variableDeclaration.name, node.variableDeclaration.type) : null,
              body: this.convertChild(node.block)
            });
          case SyntaxKind.WhileStatement:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.WhileStatement,
              test: this.convertChild(node.expression),
              body: this.convertChild(node.statement)
            });
          case SyntaxKind.DoStatement:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.DoWhileStatement,
              test: this.convertChild(node.expression),
              body: this.convertChild(node.statement)
            });
          case SyntaxKind.ForStatement:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ForStatement,
              init: this.convertChild(node.initializer),
              test: this.convertChild(node.condition),
              update: this.convertChild(node.incrementor),
              body: this.convertChild(node.statement)
            });
          case SyntaxKind.ForInStatement:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ForInStatement,
              left: this.convertPattern(node.initializer),
              right: this.convertChild(node.expression),
              body: this.convertChild(node.statement)
            });
          case SyntaxKind.ForOfStatement:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ForOfStatement,
              left: this.convertPattern(node.initializer),
              right: this.convertChild(node.expression),
              body: this.convertChild(node.statement),
              await: Boolean(node.awaitModifier && node.awaitModifier.kind === SyntaxKind.AwaitKeyword)
            });
          case SyntaxKind.FunctionDeclaration: {
            const isDeclare = (0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node);
            const result = this.createNode(node, {
              type: isDeclare || !node.body ? ts_estree_1.AST_NODE_TYPES.TSDeclareFunction : ts_estree_1.AST_NODE_TYPES.FunctionDeclaration,
              id: this.convertChild(node.name),
              generator: !!node.asteriskToken,
              expression: false,
              async: (0, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),
              params: this.convertParameters(node.parameters),
              body: this.convertChild(node.body) || void 0
            });
            if (node.type) {
              result.returnType = this.convertTypeAnnotation(node.type, node);
            }
            if (node.typeParameters) {
              result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);
            }
            if (isDeclare) {
              result.declare = true;
            }
            return this.fixExports(node, result);
          }
          case SyntaxKind.VariableDeclaration: {
            const result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.VariableDeclarator,
              id: this.convertBindingNameWithTypeAnnotation(node.name, node.type, node),
              init: this.convertChild(node.initializer)
            });
            if (node.exclamationToken) {
              result.definite = true;
            }
            return result;
          }
          case SyntaxKind.VariableStatement: {
            const result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.VariableDeclaration,
              declarations: node.declarationList.declarations.map((el) => this.convertChild(el)),
              kind: (0, node_utils_1.getDeclarationKind)(node.declarationList)
            });
            if ((0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node)) {
              result.declare = true;
            }
            return this.fixExports(node, result);
          }
          case SyntaxKind.VariableDeclarationList:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.VariableDeclaration,
              declarations: node.declarations.map((el) => this.convertChild(el)),
              kind: (0, node_utils_1.getDeclarationKind)(node)
            });
          case SyntaxKind.ExpressionStatement:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ExpressionStatement,
              expression: this.convertChild(node.expression)
            });
          case SyntaxKind.ThisKeyword:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ThisExpression
            });
          case SyntaxKind.ArrayLiteralExpression: {
            if (this.allowPattern) {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.ArrayPattern,
                elements: node.elements.map((el) => this.convertPattern(el))
              });
            } else {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.ArrayExpression,
                elements: node.elements.map((el) => this.convertChild(el))
              });
            }
          }
          case SyntaxKind.ObjectLiteralExpression: {
            if (this.allowPattern) {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.ObjectPattern,
                properties: node.properties.map((el) => this.convertPattern(el))
              });
            } else {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.ObjectExpression,
                properties: node.properties.map((el) => this.convertChild(el))
              });
            }
          }
          case SyntaxKind.PropertyAssignment:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.Property,
              key: this.convertChild(node.name),
              value: this.converter(node.initializer, node, this.inTypeMode, this.allowPattern),
              computed: (0, node_utils_1.isComputedProperty)(node.name),
              method: false,
              shorthand: false,
              kind: "init"
            });
          case SyntaxKind.ShorthandPropertyAssignment: {
            if (node.objectAssignmentInitializer) {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.Property,
                key: this.convertChild(node.name),
                value: this.createNode(node, {
                  type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,
                  left: this.convertPattern(node.name),
                  right: this.convertChild(node.objectAssignmentInitializer)
                }),
                computed: false,
                method: false,
                shorthand: true,
                kind: "init"
              });
            } else {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.Property,
                key: this.convertChild(node.name),
                value: this.convertChild(node.name),
                computed: false,
                method: false,
                shorthand: true,
                kind: "init"
              });
            }
          }
          case SyntaxKind.ComputedPropertyName:
            return this.convertChild(node.expression);
          case SyntaxKind.PropertyDeclaration: {
            const isAbstract = (0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node);
            const isAccessor = (0, node_utils_1.hasModifier)(SyntaxKind.AccessorKeyword, node);
            const type = (() => {
              if (isAccessor) {
                if (isAbstract) {
                  return ts_estree_1.AST_NODE_TYPES.TSAbstractAccessorProperty;
                }
                return ts_estree_1.AST_NODE_TYPES.AccessorProperty;
              }
              if (isAbstract) {
                return ts_estree_1.AST_NODE_TYPES.TSAbstractPropertyDefinition;
              }
              return ts_estree_1.AST_NODE_TYPES.PropertyDefinition;
            })();
            const result = this.createNode(node, {
              type,
              key: this.convertChild(node.name),
              value: isAbstract ? null : this.convertChild(node.initializer),
              computed: (0, node_utils_1.isComputedProperty)(node.name),
              static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),
              readonly: (0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node) || void 0,
              declare: (0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node),
              override: (0, node_utils_1.hasModifier)(SyntaxKind.OverrideKeyword, node)
            });
            if (node.type) {
              result.typeAnnotation = this.convertTypeAnnotation(node.type, node);
            }
            const decorators = (0, getModifiers_1.getDecorators)(node);
            if (decorators) {
              result.decorators = decorators.map((el) => this.convertChild(el));
            }
            const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);
            if (accessibility) {
              result.accessibility = accessibility;
            }
            if ((node.name.kind === SyntaxKind.Identifier || node.name.kind === SyntaxKind.ComputedPropertyName || node.name.kind === SyntaxKind.PrivateIdentifier) && node.questionToken) {
              result.optional = true;
            }
            if (node.exclamationToken) {
              result.definite = true;
            }
            if (result.key.type === ts_estree_1.AST_NODE_TYPES.Literal && node.questionToken) {
              result.optional = true;
            }
            return result;
          }
          case SyntaxKind.GetAccessor:
          case SyntaxKind.SetAccessor: {
            if (node.parent.kind === SyntaxKind.InterfaceDeclaration || node.parent.kind === SyntaxKind.TypeLiteral) {
              return this.convertMethodSignature(node);
            }
          }
          case SyntaxKind.MethodDeclaration: {
            const method = this.createNode(node, {
              type: !node.body ? ts_estree_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression : ts_estree_1.AST_NODE_TYPES.FunctionExpression,
              id: null,
              generator: !!node.asteriskToken,
              expression: false,
              async: (0, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),
              body: this.convertChild(node.body),
              range: [node.parameters.pos - 1, node.end],
              params: []
            });
            if (node.type) {
              method.returnType = this.convertTypeAnnotation(node.type, node);
            }
            if (node.typeParameters) {
              method.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);
              this.fixParentLocation(method, method.typeParameters.range);
            }
            let result;
            if (parent.kind === SyntaxKind.ObjectLiteralExpression) {
              method.params = node.parameters.map((el) => this.convertChild(el));
              result = this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.Property,
                key: this.convertChild(node.name),
                value: method,
                computed: (0, node_utils_1.isComputedProperty)(node.name),
                method: node.kind === SyntaxKind.MethodDeclaration,
                shorthand: false,
                kind: "init"
              });
            } else {
              method.params = this.convertParameters(node.parameters);
              const methodDefinitionType = (0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node) ? ts_estree_1.AST_NODE_TYPES.TSAbstractMethodDefinition : ts_estree_1.AST_NODE_TYPES.MethodDefinition;
              result = this.createNode(node, {
                type: methodDefinitionType,
                key: this.convertChild(node.name),
                value: method,
                computed: (0, node_utils_1.isComputedProperty)(node.name),
                static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),
                kind: "method",
                override: (0, node_utils_1.hasModifier)(SyntaxKind.OverrideKeyword, node)
              });
              const decorators = (0, getModifiers_1.getDecorators)(node);
              if (decorators) {
                result.decorators = decorators.map((el) => this.convertChild(el));
              }
              const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);
              if (accessibility) {
                result.accessibility = accessibility;
              }
            }
            if (node.questionToken) {
              result.optional = true;
            }
            if (node.kind === SyntaxKind.GetAccessor) {
              result.kind = "get";
            } else if (node.kind === SyntaxKind.SetAccessor) {
              result.kind = "set";
            } else if (!result.static && node.name.kind === SyntaxKind.StringLiteral && node.name.text === "constructor" && result.type !== ts_estree_1.AST_NODE_TYPES.Property) {
              result.kind = "constructor";
            }
            return result;
          }
          case SyntaxKind.Constructor: {
            const lastModifier = (0, node_utils_1.getLastModifier)(node);
            const constructorToken = lastModifier && (0, node_utils_1.findNextToken)(lastModifier, node, this.ast) || node.getFirstToken();
            const constructor = this.createNode(node, {
              type: !node.body ? ts_estree_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression : ts_estree_1.AST_NODE_TYPES.FunctionExpression,
              id: null,
              params: this.convertParameters(node.parameters),
              generator: false,
              expression: false,
              async: false,
              body: this.convertChild(node.body),
              range: [node.parameters.pos - 1, node.end]
            });
            if (node.typeParameters) {
              constructor.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);
              this.fixParentLocation(constructor, constructor.typeParameters.range);
            }
            if (node.type) {
              constructor.returnType = this.convertTypeAnnotation(node.type, node);
            }
            const constructorKey = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.Identifier,
              name: "constructor",
              range: [constructorToken.getStart(this.ast), constructorToken.end]
            });
            const isStatic = (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node);
            const result = this.createNode(node, {
              type: (0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node) ? ts_estree_1.AST_NODE_TYPES.TSAbstractMethodDefinition : ts_estree_1.AST_NODE_TYPES.MethodDefinition,
              key: constructorKey,
              value: constructor,
              computed: false,
              static: isStatic,
              kind: isStatic ? "method" : "constructor",
              override: false
            });
            const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);
            if (accessibility) {
              result.accessibility = accessibility;
            }
            return result;
          }
          case SyntaxKind.FunctionExpression: {
            const result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.FunctionExpression,
              id: this.convertChild(node.name),
              generator: !!node.asteriskToken,
              params: this.convertParameters(node.parameters),
              body: this.convertChild(node.body),
              async: (0, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),
              expression: false
            });
            if (node.type) {
              result.returnType = this.convertTypeAnnotation(node.type, node);
            }
            if (node.typeParameters) {
              result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);
            }
            return result;
          }
          case SyntaxKind.SuperKeyword:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.Super
            });
          case SyntaxKind.ArrayBindingPattern:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ArrayPattern,
              elements: node.elements.map((el) => this.convertPattern(el))
            });
          case SyntaxKind.OmittedExpression:
            return null;
          case SyntaxKind.ObjectBindingPattern:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ObjectPattern,
              properties: node.elements.map((el) => this.convertPattern(el))
            });
          case SyntaxKind.BindingElement: {
            if (parent.kind === SyntaxKind.ArrayBindingPattern) {
              const arrayItem = this.convertChild(node.name, parent);
              if (node.initializer) {
                return this.createNode(node, {
                  type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,
                  left: arrayItem,
                  right: this.convertChild(node.initializer)
                });
              } else if (node.dotDotDotToken) {
                return this.createNode(node, {
                  type: ts_estree_1.AST_NODE_TYPES.RestElement,
                  argument: arrayItem
                });
              } else {
                return arrayItem;
              }
            } else {
              let result;
              if (node.dotDotDotToken) {
                result = this.createNode(node, {
                  type: ts_estree_1.AST_NODE_TYPES.RestElement,
                  argument: this.convertChild((_a2 = node.propertyName) !== null && _a2 !== void 0 ? _a2 : node.name)
                });
              } else {
                result = this.createNode(node, {
                  type: ts_estree_1.AST_NODE_TYPES.Property,
                  key: this.convertChild((_b = node.propertyName) !== null && _b !== void 0 ? _b : node.name),
                  value: this.convertChild(node.name),
                  computed: Boolean(node.propertyName && node.propertyName.kind === SyntaxKind.ComputedPropertyName),
                  method: false,
                  shorthand: !node.propertyName,
                  kind: "init"
                });
              }
              if (node.initializer) {
                result.value = this.createNode(node, {
                  type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,
                  left: this.convertChild(node.name),
                  right: this.convertChild(node.initializer),
                  range: [node.name.getStart(this.ast), node.initializer.end]
                });
              }
              return result;
            }
          }
          case SyntaxKind.ArrowFunction: {
            const result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ArrowFunctionExpression,
              generator: false,
              id: null,
              params: this.convertParameters(node.parameters),
              body: this.convertChild(node.body),
              async: (0, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),
              expression: node.body.kind !== SyntaxKind.Block
            });
            if (node.type) {
              result.returnType = this.convertTypeAnnotation(node.type, node);
            }
            if (node.typeParameters) {
              result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);
            }
            return result;
          }
          case SyntaxKind.YieldExpression:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.YieldExpression,
              delegate: !!node.asteriskToken,
              argument: this.convertChild(node.expression)
            });
          case SyntaxKind.AwaitExpression:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.AwaitExpression,
              argument: this.convertChild(node.expression)
            });
          case SyntaxKind.NoSubstitutionTemplateLiteral:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TemplateLiteral,
              quasis: [
                this.createNode(node, {
                  type: ts_estree_1.AST_NODE_TYPES.TemplateElement,
                  value: {
                    raw: this.ast.text.slice(node.getStart(this.ast) + 1, node.end - 1),
                    cooked: node.text
                  },
                  tail: true
                })
              ],
              expressions: []
            });
          case SyntaxKind.TemplateExpression: {
            const result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TemplateLiteral,
              quasis: [this.convertChild(node.head)],
              expressions: []
            });
            node.templateSpans.forEach((templateSpan) => {
              result.expressions.push(this.convertChild(templateSpan.expression));
              result.quasis.push(this.convertChild(templateSpan.literal));
            });
            return result;
          }
          case SyntaxKind.TaggedTemplateExpression:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TaggedTemplateExpression,
              typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : void 0,
              tag: this.convertChild(node.tag),
              quasi: this.convertChild(node.template)
            });
          case SyntaxKind.TemplateHead:
          case SyntaxKind.TemplateMiddle:
          case SyntaxKind.TemplateTail: {
            const tail = node.kind === SyntaxKind.TemplateTail;
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TemplateElement,
              value: {
                raw: this.ast.text.slice(node.getStart(this.ast) + 1, node.end - (tail ? 1 : 2)),
                cooked: node.text
              },
              tail
            });
          }
          case SyntaxKind.SpreadAssignment:
          case SyntaxKind.SpreadElement: {
            if (this.allowPattern) {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.RestElement,
                argument: this.convertPattern(node.expression)
              });
            } else {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.SpreadElement,
                argument: this.convertChild(node.expression)
              });
            }
          }
          case SyntaxKind.Parameter: {
            let parameter;
            let result;
            if (node.dotDotDotToken) {
              parameter = result = this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.RestElement,
                argument: this.convertChild(node.name)
              });
            } else if (node.initializer) {
              parameter = this.convertChild(node.name);
              result = this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,
                left: parameter,
                right: this.convertChild(node.initializer)
              });
              const modifiers2 = (0, getModifiers_1.getModifiers)(node);
              if (modifiers2) {
                result.range[0] = parameter.range[0];
                result.loc = (0, node_utils_1.getLocFor)(result.range[0], result.range[1], this.ast);
              }
            } else {
              parameter = result = this.convertChild(node.name, parent);
            }
            if (node.type) {
              parameter.typeAnnotation = this.convertTypeAnnotation(node.type, node);
              this.fixParentLocation(parameter, parameter.typeAnnotation.range);
            }
            if (node.questionToken) {
              if (node.questionToken.end > parameter.range[1]) {
                parameter.range[1] = node.questionToken.end;
                parameter.loc.end = (0, node_utils_1.getLineAndCharacterFor)(parameter.range[1], this.ast);
              }
              parameter.optional = true;
            }
            const modifiers = (0, getModifiers_1.getModifiers)(node);
            if (modifiers) {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.TSParameterProperty,
                accessibility: (_c = (0, node_utils_1.getTSNodeAccessibility)(node)) !== null && _c !== void 0 ? _c : void 0,
                readonly: (0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node) || void 0,
                static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node) || void 0,
                export: (0, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node) || void 0,
                override: (0, node_utils_1.hasModifier)(SyntaxKind.OverrideKeyword, node) || void 0,
                parameter: result
              });
            }
            return result;
          }
          case SyntaxKind.ClassDeclaration:
          case SyntaxKind.ClassExpression: {
            const heritageClauses = (_d = node.heritageClauses) !== null && _d !== void 0 ? _d : [];
            const classNodeType = node.kind === SyntaxKind.ClassDeclaration ? ts_estree_1.AST_NODE_TYPES.ClassDeclaration : ts_estree_1.AST_NODE_TYPES.ClassExpression;
            const superClass = heritageClauses.find((clause) => clause.token === SyntaxKind.ExtendsKeyword);
            const implementsClause = heritageClauses.find((clause) => clause.token === SyntaxKind.ImplementsKeyword);
            const result = this.createNode(node, {
              type: classNodeType,
              id: this.convertChild(node.name),
              body: this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.ClassBody,
                body: [],
                range: [node.members.pos - 1, node.end]
              }),
              superClass: (superClass === null || superClass === void 0 ? void 0 : superClass.types[0]) ? this.convertChild(superClass.types[0].expression) : null
            });
            if (superClass) {
              if (superClass.types.length > 1) {
                throw (0, node_utils_1.createError)(this.ast, superClass.types[1].pos, "Classes can only extend a single class.");
              }
              if ((_e = superClass.types[0]) === null || _e === void 0 ? void 0 : _e.typeArguments) {
                result.superTypeParameters = this.convertTypeArgumentsToTypeParameters(superClass.types[0].typeArguments, superClass.types[0]);
              }
            }
            if (node.typeParameters) {
              result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);
            }
            if (implementsClause) {
              result.implements = implementsClause.types.map((el) => this.convertChild(el));
            }
            if ((0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node)) {
              result.abstract = true;
            }
            if ((0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node)) {
              result.declare = true;
            }
            const decorators = (0, getModifiers_1.getDecorators)(node);
            if (decorators) {
              result.decorators = decorators.map((el) => this.convertChild(el));
            }
            const filteredMembers = node.members.filter(node_utils_1.isESTreeClassMember);
            if (filteredMembers.length) {
              result.body.body = filteredMembers.map((el) => this.convertChild(el));
            }
            return this.fixExports(node, result);
          }
          case SyntaxKind.ModuleBlock:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSModuleBlock,
              body: this.convertBodyExpressions(node.statements, node)
            });
          case SyntaxKind.ImportDeclaration: {
            this.assertModuleSpecifier(node, false);
            const result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ImportDeclaration,
              source: this.convertChild(node.moduleSpecifier),
              specifiers: [],
              importKind: "value",
              assertions: this.convertAssertClasue(node.assertClause)
            });
            if (node.importClause) {
              if (node.importClause.isTypeOnly) {
                result.importKind = "type";
              }
              if (node.importClause.name) {
                result.specifiers.push(this.convertChild(node.importClause));
              }
              if (node.importClause.namedBindings) {
                switch (node.importClause.namedBindings.kind) {
                  case SyntaxKind.NamespaceImport:
                    result.specifiers.push(this.convertChild(node.importClause.namedBindings));
                    break;
                  case SyntaxKind.NamedImports:
                    result.specifiers = result.specifiers.concat(node.importClause.namedBindings.elements.map((el) => this.convertChild(el)));
                    break;
                }
              }
            }
            return result;
          }
          case SyntaxKind.NamespaceImport:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ImportNamespaceSpecifier,
              local: this.convertChild(node.name)
            });
          case SyntaxKind.ImportSpecifier:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ImportSpecifier,
              local: this.convertChild(node.name),
              imported: this.convertChild((_f = node.propertyName) !== null && _f !== void 0 ? _f : node.name),
              importKind: node.isTypeOnly ? "type" : "value"
            });
          case SyntaxKind.ImportClause: {
            const local = this.convertChild(node.name);
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ImportDefaultSpecifier,
              local,
              range: local.range
            });
          }
          case SyntaxKind.ExportDeclaration: {
            if (((_g = node.exportClause) === null || _g === void 0 ? void 0 : _g.kind) === SyntaxKind.NamedExports) {
              this.assertModuleSpecifier(node, true);
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.ExportNamedDeclaration,
                source: this.convertChild(node.moduleSpecifier),
                specifiers: node.exportClause.elements.map((el) => this.convertChild(el)),
                exportKind: node.isTypeOnly ? "type" : "value",
                declaration: null,
                assertions: this.convertAssertClasue(node.assertClause)
              });
            } else {
              this.assertModuleSpecifier(node, false);
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.ExportAllDeclaration,
                source: this.convertChild(node.moduleSpecifier),
                exportKind: node.isTypeOnly ? "type" : "value",
                exported: (
                  // note - for compat with 3.7.x, where node.exportClause is always undefined and
                  //        SyntaxKind.NamespaceExport does not exist yet (i.e. is undefined), this
                  //        cannot be shortened to an optional chain, or else you end up with
                  //        undefined === undefined, and the true path will hard error at runtime
                  node.exportClause && node.exportClause.kind === SyntaxKind.NamespaceExport ? this.convertChild(node.exportClause.name) : null
                ),
                assertions: this.convertAssertClasue(node.assertClause)
              });
            }
          }
          case SyntaxKind.ExportSpecifier:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ExportSpecifier,
              local: this.convertChild((_h = node.propertyName) !== null && _h !== void 0 ? _h : node.name),
              exported: this.convertChild(node.name),
              exportKind: node.isTypeOnly ? "type" : "value"
            });
          case SyntaxKind.ExportAssignment:
            if (node.isExportEquals) {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.TSExportAssignment,
                expression: this.convertChild(node.expression)
              });
            } else {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.ExportDefaultDeclaration,
                declaration: this.convertChild(node.expression),
                exportKind: "value"
              });
            }
          case SyntaxKind.PrefixUnaryExpression:
          case SyntaxKind.PostfixUnaryExpression: {
            const operator = (0, node_utils_1.getTextForTokenKind)(node.operator);
            if (operator === "++" || operator === "--") {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.UpdateExpression,
                operator,
                prefix: node.kind === SyntaxKind.PrefixUnaryExpression,
                argument: this.convertChild(node.operand)
              });
            } else {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,
                operator,
                prefix: node.kind === SyntaxKind.PrefixUnaryExpression,
                argument: this.convertChild(node.operand)
              });
            }
          }
          case SyntaxKind.DeleteExpression:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,
              operator: "delete",
              prefix: true,
              argument: this.convertChild(node.expression)
            });
          case SyntaxKind.VoidExpression:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,
              operator: "void",
              prefix: true,
              argument: this.convertChild(node.expression)
            });
          case SyntaxKind.TypeOfExpression:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,
              operator: "typeof",
              prefix: true,
              argument: this.convertChild(node.expression)
            });
          case SyntaxKind.TypeOperator:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSTypeOperator,
              operator: (0, node_utils_1.getTextForTokenKind)(node.operator),
              typeAnnotation: this.convertChild(node.type)
            });
          case SyntaxKind.BinaryExpression: {
            if ((0, node_utils_1.isComma)(node.operatorToken)) {
              const result = this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.SequenceExpression,
                expressions: []
              });
              const left6 = this.convertChild(node.left);
              if (left6.type === ts_estree_1.AST_NODE_TYPES.SequenceExpression && node.left.kind !== SyntaxKind.ParenthesizedExpression) {
                result.expressions = result.expressions.concat(left6.expressions);
              } else {
                result.expressions.push(left6);
              }
              result.expressions.push(this.convertChild(node.right));
              return result;
            } else {
              const type = (0, node_utils_1.getBinaryExpressionType)(node.operatorToken);
              if (this.allowPattern && type === ts_estree_1.AST_NODE_TYPES.AssignmentExpression) {
                return this.createNode(node, {
                  type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,
                  left: this.convertPattern(node.left, node),
                  right: this.convertChild(node.right)
                });
              }
              return this.createNode(node, {
                type,
                operator: (0, node_utils_1.getTextForTokenKind)(node.operatorToken.kind),
                left: this.converter(node.left, node, this.inTypeMode, type === ts_estree_1.AST_NODE_TYPES.AssignmentExpression),
                right: this.convertChild(node.right)
              });
            }
          }
          case SyntaxKind.PropertyAccessExpression: {
            const object = this.convertChild(node.expression);
            const property = this.convertChild(node.name);
            const computed = false;
            const result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.MemberExpression,
              object,
              property,
              computed,
              optional: node.questionDotToken !== void 0
            });
            return this.convertChainExpression(result, node);
          }
          case SyntaxKind.ElementAccessExpression: {
            const object = this.convertChild(node.expression);
            const property = this.convertChild(node.argumentExpression);
            const computed = true;
            const result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.MemberExpression,
              object,
              property,
              computed,
              optional: node.questionDotToken !== void 0
            });
            return this.convertChainExpression(result, node);
          }
          case SyntaxKind.CallExpression: {
            if (node.expression.kind === SyntaxKind.ImportKeyword) {
              if (node.arguments.length !== 1 && node.arguments.length !== 2) {
                throw (0, node_utils_1.createError)(this.ast, node.arguments.pos, "Dynamic import requires exactly one or two arguments.");
              }
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.ImportExpression,
                source: this.convertChild(node.arguments[0]),
                attributes: node.arguments[1] ? this.convertChild(node.arguments[1]) : null
              });
            }
            const callee = this.convertChild(node.expression);
            const args = node.arguments.map((el) => this.convertChild(el));
            const result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.CallExpression,
              callee,
              arguments: args,
              optional: node.questionDotToken !== void 0
            });
            if (node.typeArguments) {
              result.typeParameters = this.convertTypeArgumentsToTypeParameters(node.typeArguments, node);
            }
            return this.convertChainExpression(result, node);
          }
          case SyntaxKind.NewExpression: {
            const result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.NewExpression,
              callee: this.convertChild(node.expression),
              arguments: node.arguments ? node.arguments.map((el) => this.convertChild(el)) : []
            });
            if (node.typeArguments) {
              result.typeParameters = this.convertTypeArgumentsToTypeParameters(node.typeArguments, node);
            }
            return result;
          }
          case SyntaxKind.ConditionalExpression:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ConditionalExpression,
              test: this.convertChild(node.condition),
              consequent: this.convertChild(node.whenTrue),
              alternate: this.convertChild(node.whenFalse)
            });
          case SyntaxKind.MetaProperty: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.MetaProperty,
              meta: this.createNode(
                // TODO: do we really want to convert it to Token?
                node.getFirstToken(),
                {
                  type: ts_estree_1.AST_NODE_TYPES.Identifier,
                  name: (0, node_utils_1.getTextForTokenKind)(node.keywordToken)
                }
              ),
              property: this.convertChild(node.name)
            });
          }
          case SyntaxKind.Decorator: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.Decorator,
              expression: this.convertChild(node.expression)
            });
          }
          case SyntaxKind.StringLiteral: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.Literal,
              value: parent.kind === SyntaxKind.JsxAttribute ? (0, node_utils_1.unescapeStringLiteralText)(node.text) : node.text,
              raw: node.getText()
            });
          }
          case SyntaxKind.NumericLiteral: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.Literal,
              value: Number(node.text),
              raw: node.getText()
            });
          }
          case SyntaxKind.BigIntLiteral: {
            const range = (0, node_utils_1.getRange)(node, this.ast);
            const rawValue = this.ast.text.slice(range[0], range[1]);
            const bigint = rawValue.slice(0, -1).replace(/_/g, "");
            const value = typeof BigInt !== "undefined" ? BigInt(bigint) : null;
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.Literal,
              raw: rawValue,
              value,
              bigint: value == null ? bigint : String(value),
              range
            });
          }
          case SyntaxKind.RegularExpressionLiteral: {
            const pattern = node.text.slice(1, node.text.lastIndexOf("/"));
            const flags = node.text.slice(node.text.lastIndexOf("/") + 1);
            let regex = null;
            try {
              regex = new RegExp(pattern, flags);
            } catch (exception) {
              regex = null;
            }
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.Literal,
              value: regex,
              raw: node.text,
              regex: {
                pattern,
                flags
              }
            });
          }
          case SyntaxKind.TrueKeyword:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.Literal,
              value: true,
              raw: "true"
            });
          case SyntaxKind.FalseKeyword:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.Literal,
              value: false,
              raw: "false"
            });
          case SyntaxKind.NullKeyword: {
            if (!version_check_1.typescriptVersionIsAtLeast["4.0"] && this.inTypeMode) {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.TSNullKeyword
              });
            }
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.Literal,
              value: null,
              raw: "null"
            });
          }
          case SyntaxKind.EmptyStatement:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.EmptyStatement
            });
          case SyntaxKind.DebuggerStatement:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.DebuggerStatement
            });
          case SyntaxKind.JsxElement:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.JSXElement,
              openingElement: this.convertChild(node.openingElement),
              closingElement: this.convertChild(node.closingElement),
              children: node.children.map((el) => this.convertChild(el))
            });
          case SyntaxKind.JsxFragment:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.JSXFragment,
              openingFragment: this.convertChild(node.openingFragment),
              closingFragment: this.convertChild(node.closingFragment),
              children: node.children.map((el) => this.convertChild(el))
            });
          case SyntaxKind.JsxSelfClosingElement: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.JSXElement,
              /**
               * Convert SyntaxKind.JsxSelfClosingElement to SyntaxKind.JsxOpeningElement,
               * TypeScript does not seem to have the idea of openingElement when tag is self-closing
               */
              openingElement: this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.JSXOpeningElement,
                typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : void 0,
                selfClosing: true,
                name: this.convertJSXTagName(node.tagName, node),
                attributes: node.attributes.properties.map((el) => this.convertChild(el)),
                range: (0, node_utils_1.getRange)(node, this.ast)
              }),
              closingElement: null,
              children: []
            });
          }
          case SyntaxKind.JsxOpeningElement:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.JSXOpeningElement,
              typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : void 0,
              selfClosing: false,
              name: this.convertJSXTagName(node.tagName, node),
              attributes: node.attributes.properties.map((el) => this.convertChild(el))
            });
          case SyntaxKind.JsxClosingElement:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.JSXClosingElement,
              name: this.convertJSXTagName(node.tagName, node)
            });
          case SyntaxKind.JsxOpeningFragment:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.JSXOpeningFragment
            });
          case SyntaxKind.JsxClosingFragment:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.JSXClosingFragment
            });
          case SyntaxKind.JsxExpression: {
            const expression = node.expression ? this.convertChild(node.expression) : this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.JSXEmptyExpression,
              range: [node.getStart(this.ast) + 1, node.getEnd() - 1]
            });
            if (node.dotDotDotToken) {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.JSXSpreadChild,
                expression
              });
            } else {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.JSXExpressionContainer,
                expression
              });
            }
          }
          case SyntaxKind.JsxAttribute: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.JSXAttribute,
              name: this.convertJSXNamespaceOrIdentifier(node.name),
              value: this.convertChild(node.initializer)
            });
          }
          case SyntaxKind.JsxText: {
            const start = node.getFullStart();
            const end = node.getEnd();
            const text = this.ast.text.slice(start, end);
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.JSXText,
              value: (0, node_utils_1.unescapeStringLiteralText)(text),
              raw: text,
              range: [start, end]
            });
          }
          case SyntaxKind.JsxSpreadAttribute:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.JSXSpreadAttribute,
              argument: this.convertChild(node.expression)
            });
          case SyntaxKind.QualifiedName: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSQualifiedName,
              left: this.convertChild(node.left),
              right: this.convertChild(node.right)
            });
          }
          case SyntaxKind.TypeReference: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSTypeReference,
              typeName: this.convertType(node.typeName),
              typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : void 0
            });
          }
          case SyntaxKind.TypeParameter: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSTypeParameter,
              name: this.convertType(node.name),
              constraint: node.constraint ? this.convertType(node.constraint) : void 0,
              default: node.default ? this.convertType(node.default) : void 0,
              in: (0, node_utils_1.hasModifier)(SyntaxKind.InKeyword, node),
              out: (0, node_utils_1.hasModifier)(SyntaxKind.OutKeyword, node),
              const: (0, node_utils_1.hasModifier)(SyntaxKind.ConstKeyword, node)
            });
          }
          case SyntaxKind.ThisType:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSThisType
            });
          case SyntaxKind.AnyKeyword:
          case SyntaxKind.BigIntKeyword:
          case SyntaxKind.BooleanKeyword:
          case SyntaxKind.NeverKeyword:
          case SyntaxKind.NumberKeyword:
          case SyntaxKind.ObjectKeyword:
          case SyntaxKind.StringKeyword:
          case SyntaxKind.SymbolKeyword:
          case SyntaxKind.UnknownKeyword:
          case SyntaxKind.VoidKeyword:
          case SyntaxKind.UndefinedKeyword:
          case SyntaxKind.IntrinsicKeyword: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES[`TS${SyntaxKind[node.kind]}`]
            });
          }
          case SyntaxKind.NonNullExpression: {
            const nnExpr = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSNonNullExpression,
              expression: this.convertChild(node.expression)
            });
            return this.convertChainExpression(nnExpr, node);
          }
          case SyntaxKind.TypeLiteral: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSTypeLiteral,
              members: node.members.map((el) => this.convertChild(el))
            });
          }
          case SyntaxKind.ArrayType: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSArrayType,
              elementType: this.convertType(node.elementType)
            });
          }
          case SyntaxKind.IndexedAccessType: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSIndexedAccessType,
              objectType: this.convertType(node.objectType),
              indexType: this.convertType(node.indexType)
            });
          }
          case SyntaxKind.ConditionalType: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSConditionalType,
              checkType: this.convertType(node.checkType),
              extendsType: this.convertType(node.extendsType),
              trueType: this.convertType(node.trueType),
              falseType: this.convertType(node.falseType)
            });
          }
          case SyntaxKind.TypeQuery: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSTypeQuery,
              exprName: this.convertType(node.exprName),
              typeParameters: node.typeArguments && this.convertTypeArgumentsToTypeParameters(node.typeArguments, node)
            });
          }
          case SyntaxKind.MappedType: {
            const result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSMappedType,
              typeParameter: this.convertType(node.typeParameter),
              nameType: (_j = this.convertType(node.nameType)) !== null && _j !== void 0 ? _j : null
            });
            if (node.readonlyToken) {
              if (node.readonlyToken.kind === SyntaxKind.ReadonlyKeyword) {
                result.readonly = true;
              } else {
                result.readonly = (0, node_utils_1.getTextForTokenKind)(node.readonlyToken.kind);
              }
            }
            if (node.questionToken) {
              if (node.questionToken.kind === SyntaxKind.QuestionToken) {
                result.optional = true;
              } else {
                result.optional = (0, node_utils_1.getTextForTokenKind)(node.questionToken.kind);
              }
            }
            if (node.type) {
              result.typeAnnotation = this.convertType(node.type);
            }
            return result;
          }
          case SyntaxKind.ParenthesizedExpression:
            return this.convertChild(node.expression, parent);
          case SyntaxKind.TypeAliasDeclaration: {
            const result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSTypeAliasDeclaration,
              id: this.convertChild(node.name),
              typeAnnotation: this.convertType(node.type)
            });
            if ((0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node)) {
              result.declare = true;
            }
            if (node.typeParameters) {
              result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);
            }
            return this.fixExports(node, result);
          }
          case SyntaxKind.MethodSignature: {
            return this.convertMethodSignature(node);
          }
          case SyntaxKind.PropertySignature: {
            const result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSPropertySignature,
              optional: (0, node_utils_1.isOptional)(node) || void 0,
              computed: (0, node_utils_1.isComputedProperty)(node.name),
              key: this.convertChild(node.name),
              typeAnnotation: node.type ? this.convertTypeAnnotation(node.type, node) : void 0,
              initializer: this.convertChild(
                // @ts-expect-error TODO breaking change remove this from the AST
                node.initializer
              ) || void 0,
              readonly: (0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node) || void 0,
              static: (0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node) || void 0,
              export: (0, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node) || void 0
            });
            const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);
            if (accessibility) {
              result.accessibility = accessibility;
            }
            return result;
          }
          case SyntaxKind.IndexSignature: {
            const result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSIndexSignature,
              parameters: node.parameters.map((el) => this.convertChild(el))
            });
            if (node.type) {
              result.typeAnnotation = this.convertTypeAnnotation(node.type, node);
            }
            if ((0, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node)) {
              result.readonly = true;
            }
            const accessibility = (0, node_utils_1.getTSNodeAccessibility)(node);
            if (accessibility) {
              result.accessibility = accessibility;
            }
            if ((0, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node)) {
              result.export = true;
            }
            if ((0, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node)) {
              result.static = true;
            }
            return result;
          }
          case SyntaxKind.ConstructorType: {
            const result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSConstructorType,
              params: this.convertParameters(node.parameters),
              abstract: (0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node)
            });
            if (node.type) {
              result.returnType = this.convertTypeAnnotation(node.type, node);
            }
            if (node.typeParameters) {
              result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);
            }
            return result;
          }
          case SyntaxKind.FunctionType:
          case SyntaxKind.ConstructSignature:
          case SyntaxKind.CallSignature: {
            const type = node.kind === SyntaxKind.ConstructSignature ? ts_estree_1.AST_NODE_TYPES.TSConstructSignatureDeclaration : node.kind === SyntaxKind.CallSignature ? ts_estree_1.AST_NODE_TYPES.TSCallSignatureDeclaration : ts_estree_1.AST_NODE_TYPES.TSFunctionType;
            const result = this.createNode(node, {
              type,
              params: this.convertParameters(node.parameters)
            });
            if (node.type) {
              result.returnType = this.convertTypeAnnotation(node.type, node);
            }
            if (node.typeParameters) {
              result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);
            }
            return result;
          }
          case SyntaxKind.ExpressionWithTypeArguments: {
            const parentKind = parent.kind;
            const type = parentKind === SyntaxKind.InterfaceDeclaration ? ts_estree_1.AST_NODE_TYPES.TSInterfaceHeritage : parentKind === SyntaxKind.HeritageClause ? ts_estree_1.AST_NODE_TYPES.TSClassImplements : ts_estree_1.AST_NODE_TYPES.TSInstantiationExpression;
            const result = this.createNode(node, {
              type,
              expression: this.convertChild(node.expression)
            });
            if (node.typeArguments) {
              result.typeParameters = this.convertTypeArgumentsToTypeParameters(node.typeArguments, node);
            }
            return result;
          }
          case SyntaxKind.InterfaceDeclaration: {
            const interfaceHeritageClauses = (_k = node.heritageClauses) !== null && _k !== void 0 ? _k : [];
            const result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSInterfaceDeclaration,
              body: this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.TSInterfaceBody,
                body: node.members.map((member) => this.convertChild(member)),
                range: [node.members.pos - 1, node.end]
              }),
              id: this.convertChild(node.name)
            });
            if (node.typeParameters) {
              result.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters);
            }
            if (interfaceHeritageClauses.length > 0) {
              const interfaceExtends = [];
              const interfaceImplements = [];
              for (const heritageClause of interfaceHeritageClauses) {
                if (heritageClause.token === SyntaxKind.ExtendsKeyword) {
                  for (const n of heritageClause.types) {
                    interfaceExtends.push(this.convertChild(n, node));
                  }
                } else {
                  for (const n of heritageClause.types) {
                    interfaceImplements.push(this.convertChild(n, node));
                  }
                }
              }
              if (interfaceExtends.length) {
                result.extends = interfaceExtends;
              }
              if (interfaceImplements.length) {
                result.implements = interfaceImplements;
              }
            }
            if ((0, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node)) {
              result.abstract = true;
            }
            if ((0, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node)) {
              result.declare = true;
            }
            return this.fixExports(node, result);
          }
          case SyntaxKind.TypePredicate: {
            const result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSTypePredicate,
              asserts: node.assertsModifier !== void 0,
              parameterName: this.convertChild(node.parameterName),
              typeAnnotation: null
            });
            if (node.type) {
              result.typeAnnotation = this.convertTypeAnnotation(node.type, node);
              result.typeAnnotation.loc = result.typeAnnotation.typeAnnotation.loc;
              result.typeAnnotation.range = result.typeAnnotation.typeAnnotation.range;
            }
            return result;
          }
          case SyntaxKind.ImportType:
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSImportType,
              isTypeOf: !!node.isTypeOf,
              parameter: this.convertChild(node.argument),
              qualifier: this.convertChild(node.qualifier),
              typeParameters: node.typeArguments ? this.convertTypeArgumentsToTypeParameters(node.typeArguments, node) : null
            });
          case SyntaxKind.EnumDeclaration: {
            const result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSEnumDeclaration,
              id: this.convertChild(node.name),
              members: node.members.map((el) => this.convertChild(el))
            });
            this.applyModifiersToResult(result, (0, getModifiers_1.getModifiers)(node));
            return this.fixExports(node, result);
          }
          case SyntaxKind.EnumMember: {
            const result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSEnumMember,
              id: this.convertChild(node.name)
            });
            if (node.initializer) {
              result.initializer = this.convertChild(node.initializer);
            }
            if (node.name.kind === ts6.SyntaxKind.ComputedPropertyName) {
              result.computed = true;
            }
            return result;
          }
          case SyntaxKind.ModuleDeclaration: {
            const result = this.createNode(node, Object.assign({ type: ts_estree_1.AST_NODE_TYPES.TSModuleDeclaration }, (() => {
              const id = this.convertChild(node.name);
              const body = this.convertChild(node.body);
              if (node.flags & ts6.NodeFlags.GlobalAugmentation) {
                if (body == null || body.type === ts_estree_1.AST_NODE_TYPES.TSModuleDeclaration) {
                  throw new Error("Expected a valid module body");
                }
                if (id.type !== ts_estree_1.AST_NODE_TYPES.Identifier) {
                  throw new Error("global module augmentation must have an Identifier id");
                }
                return {
                  kind: "global",
                  id,
                  body,
                  global: true
                };
              } else if (node.flags & ts6.NodeFlags.Namespace) {
                if (body == null) {
                  throw new Error("Expected a module body");
                }
                if (id.type !== ts_estree_1.AST_NODE_TYPES.Identifier) {
                  throw new Error("`namespace`s must have an Identifier id");
                }
                return {
                  kind: "namespace",
                  id,
                  body
                };
              } else {
                return Object.assign({ kind: "module", id }, body != null ? { body } : {});
              }
            })()));
            this.applyModifiersToResult(result, (0, getModifiers_1.getModifiers)(node));
            return this.fixExports(node, result);
          }
          case SyntaxKind.ParenthesizedType: {
            return this.convertType(node.type);
          }
          case SyntaxKind.UnionType: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSUnionType,
              types: node.types.map((el) => this.convertType(el))
            });
          }
          case SyntaxKind.IntersectionType: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSIntersectionType,
              types: node.types.map((el) => this.convertType(el))
            });
          }
          case SyntaxKind.AsExpression: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSAsExpression,
              expression: this.convertChild(node.expression),
              typeAnnotation: this.convertType(node.type)
            });
          }
          case SyntaxKind.InferType: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSInferType,
              typeParameter: this.convertType(node.typeParameter)
            });
          }
          case SyntaxKind.LiteralType: {
            if (version_check_1.typescriptVersionIsAtLeast["4.0"] && node.literal.kind === SyntaxKind.NullKeyword) {
              return this.createNode(node.literal, {
                type: ts_estree_1.AST_NODE_TYPES.TSNullKeyword
              });
            } else {
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.TSLiteralType,
                literal: this.convertType(node.literal)
              });
            }
          }
          case SyntaxKind.TypeAssertionExpression: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSTypeAssertion,
              typeAnnotation: this.convertType(node.type),
              expression: this.convertChild(node.expression)
            });
          }
          case SyntaxKind.ImportEqualsDeclaration: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSImportEqualsDeclaration,
              id: this.convertChild(node.name),
              moduleReference: this.convertChild(node.moduleReference),
              importKind: node.isTypeOnly ? "type" : "value",
              isExport: (0, node_utils_1.hasModifier)(SyntaxKind.ExportKeyword, node)
            });
          }
          case SyntaxKind.ExternalModuleReference: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSExternalModuleReference,
              expression: this.convertChild(node.expression)
            });
          }
          case SyntaxKind.NamespaceExportDeclaration: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSNamespaceExportDeclaration,
              id: this.convertChild(node.name)
            });
          }
          case SyntaxKind.AbstractKeyword: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSAbstractKeyword
            });
          }
          case SyntaxKind.TupleType: {
            const elementTypes = "elementTypes" in node ? node.elementTypes.map((el) => this.convertType(el)) : node.elements.map((el) => this.convertType(el));
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSTupleType,
              elementTypes
            });
          }
          case SyntaxKind.NamedTupleMember: {
            const member = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSNamedTupleMember,
              elementType: this.convertType(node.type, node),
              label: this.convertChild(node.name, node),
              optional: node.questionToken != null
            });
            if (node.dotDotDotToken) {
              member.range[0] = member.label.range[0];
              member.loc.start = member.label.loc.start;
              return this.createNode(node, {
                type: ts_estree_1.AST_NODE_TYPES.TSRestType,
                typeAnnotation: member
              });
            }
            return member;
          }
          case SyntaxKind.OptionalType: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSOptionalType,
              typeAnnotation: this.convertType(node.type)
            });
          }
          case SyntaxKind.RestType: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSRestType,
              typeAnnotation: this.convertType(node.type)
            });
          }
          case SyntaxKind.TemplateLiteralType: {
            const result = this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSTemplateLiteralType,
              quasis: [this.convertChild(node.head)],
              types: []
            });
            node.templateSpans.forEach((templateSpan) => {
              result.types.push(this.convertChild(templateSpan.type));
              result.quasis.push(this.convertChild(templateSpan.literal));
            });
            return result;
          }
          case SyntaxKind.ClassStaticBlockDeclaration: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.StaticBlock,
              body: this.convertBodyExpressions(node.body.statements, node)
            });
          }
          case SyntaxKind.AssertEntry: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.ImportAttribute,
              key: this.convertChild(node.name),
              value: this.convertChild(node.value)
            });
          }
          case SyntaxKind.SatisfiesExpression: {
            return this.createNode(node, {
              type: ts_estree_1.AST_NODE_TYPES.TSSatisfiesExpression,
              expression: this.convertChild(node.expression),
              typeAnnotation: this.convertChild(node.type)
            });
          }
          default:
            return this.deeplyCopy(node);
        }
      }
    };
    exports.Converter = Converter;
  }
});

// node_modules/.pnpm/tslib@1.14.1/node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __read: () => __read,
  __rest: () => __rest,
  __spread: () => __spread,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o, m, k, k2) {
  if (k2 === void 0)
    k2 = k;
  o[k2] = m[k];
}
function __exportStar(m, exports) {
  for (var p in m)
    if (p !== "default" && !exports.hasOwnProperty(p))
      exports[p] = m[p];
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n])
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod)
      if (Object.hasOwnProperty.call(mod, k))
        result[k] = mod[k];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics, __assign;
var init_tslib_es6 = __esm({
  "node_modules/.pnpm/tslib@1.14.1/node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (b2.hasOwnProperty(p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/2.8/node.js
var require_node2 = __commonJS({
  "node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/2.8/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isExpressionStatement = exports.isExpression = exports.isExportSpecifier = exports.isExportDeclaration = exports.isExportAssignment = exports.isEnumMember = exports.isEnumDeclaration = exports.isEntityNameExpression = exports.isEntityName = exports.isEmptyStatement = exports.isElementAccessExpression = exports.isDoStatement = exports.isDeleteExpression = exports.isDefaultClause = exports.isDecorator = exports.isDebuggerStatement = exports.isComputedPropertyName = exports.isContinueStatement = exports.isConstructSignatureDeclaration = exports.isConstructorTypeNode = exports.isConstructorDeclaration = exports.isConditionalTypeNode = exports.isConditionalExpression = exports.isCommaListExpression = exports.isClassLikeDeclaration = exports.isClassExpression = exports.isClassDeclaration = exports.isCatchClause = exports.isCaseOrDefaultClause = exports.isCaseClause = exports.isCaseBlock = exports.isCallSignatureDeclaration = exports.isCallLikeExpression = exports.isCallExpression = exports.isBreakStatement = exports.isBreakOrContinueStatement = exports.isBooleanLiteral = exports.isBlockLike = exports.isBlock = exports.isBindingPattern = exports.isBindingElement = exports.isBinaryExpression = exports.isAwaitExpression = exports.isAssertionExpression = exports.isAsExpression = exports.isArrowFunction = exports.isArrayTypeNode = exports.isArrayLiteralExpression = exports.isArrayBindingPattern = exports.isAccessorDeclaration = void 0;
    exports.isNamespaceImport = exports.isNamespaceDeclaration = exports.isNamedImports = exports.isNamedExports = exports.isModuleDeclaration = exports.isModuleBlock = exports.isMethodSignature = exports.isMethodDeclaration = exports.isMetaProperty = exports.isMappedTypeNode = exports.isLiteralTypeNode = exports.isLiteralExpression = exports.isLabeledStatement = exports.isJsxText = exports.isJsxSpreadAttribute = exports.isJsxSelfClosingElement = exports.isJsxOpeningLikeElement = exports.isJsxOpeningFragment = exports.isJsxOpeningElement = exports.isJsxFragment = exports.isJsxExpression = exports.isJsxElement = exports.isJsxClosingFragment = exports.isJsxClosingElement = exports.isJsxAttributes = exports.isJsxAttributeLike = exports.isJsxAttribute = exports.isJsDoc = exports.isIterationStatement = exports.isIntersectionTypeNode = exports.isInterfaceDeclaration = exports.isInferTypeNode = exports.isIndexSignatureDeclaration = exports.isIndexedAccessTypeNode = exports.isImportSpecifier = exports.isImportEqualsDeclaration = exports.isImportDeclaration = exports.isImportClause = exports.isIfStatement = exports.isIdentifier = exports.isGetAccessorDeclaration = exports.isFunctionTypeNode = exports.isFunctionExpression = exports.isFunctionDeclaration = exports.isForStatement = exports.isForOfStatement = exports.isForInOrOfStatement = exports.isForInStatement = exports.isExternalModuleReference = exports.isExpressionWithTypeArguments = void 0;
    exports.isVariableStatement = exports.isVariableDeclaration = exports.isUnionTypeNode = exports.isTypeQueryNode = exports.isTypeReferenceNode = exports.isTypePredicateNode = exports.isTypeParameterDeclaration = exports.isTypeOperatorNode = exports.isTypeOfExpression = exports.isTypeLiteralNode = exports.isTypeAssertion = exports.isTypeAliasDeclaration = exports.isTupleTypeNode = exports.isTryStatement = exports.isThrowStatement = exports.isTextualLiteral = exports.isTemplateLiteral = exports.isTemplateExpression = exports.isTaggedTemplateExpression = exports.isSyntaxList = exports.isSwitchStatement = exports.isStringLiteral = exports.isSpreadElement = exports.isSpreadAssignment = exports.isSourceFile = exports.isSignatureDeclaration = exports.isShorthandPropertyAssignment = exports.isSetAccessorDeclaration = exports.isReturnStatement = exports.isRegularExpressionLiteral = exports.isQualifiedName = exports.isPropertySignature = exports.isPropertyDeclaration = exports.isPropertyAssignment = exports.isPropertyAccessExpression = exports.isPrefixUnaryExpression = exports.isPostfixUnaryExpression = exports.isParenthesizedTypeNode = exports.isParenthesizedExpression = exports.isParameterDeclaration = exports.isOmittedExpression = exports.isObjectLiteralExpression = exports.isObjectBindingPattern = exports.isNumericOrStringLikeLiteral = exports.isNumericLiteral = exports.isNullLiteral = exports.isNoSubstitutionTemplateLiteral = exports.isNonNullExpression = exports.isNewExpression = exports.isNamespaceExportDeclaration = void 0;
    exports.isWithStatement = exports.isWhileStatement = exports.isVoidExpression = exports.isVariableDeclarationList = void 0;
    var ts6 = require("typescript");
    function isAccessorDeclaration(node) {
      return node.kind === ts6.SyntaxKind.GetAccessor || node.kind === ts6.SyntaxKind.SetAccessor;
    }
    exports.isAccessorDeclaration = isAccessorDeclaration;
    function isArrayBindingPattern(node) {
      return node.kind === ts6.SyntaxKind.ArrayBindingPattern;
    }
    exports.isArrayBindingPattern = isArrayBindingPattern;
    function isArrayLiteralExpression(node) {
      return node.kind === ts6.SyntaxKind.ArrayLiteralExpression;
    }
    exports.isArrayLiteralExpression = isArrayLiteralExpression;
    function isArrayTypeNode(node) {
      return node.kind === ts6.SyntaxKind.ArrayType;
    }
    exports.isArrayTypeNode = isArrayTypeNode;
    function isArrowFunction(node) {
      return node.kind === ts6.SyntaxKind.ArrowFunction;
    }
    exports.isArrowFunction = isArrowFunction;
    function isAsExpression(node) {
      return node.kind === ts6.SyntaxKind.AsExpression;
    }
    exports.isAsExpression = isAsExpression;
    function isAssertionExpression(node) {
      return node.kind === ts6.SyntaxKind.AsExpression || node.kind === ts6.SyntaxKind.TypeAssertionExpression;
    }
    exports.isAssertionExpression = isAssertionExpression;
    function isAwaitExpression(node) {
      return node.kind === ts6.SyntaxKind.AwaitExpression;
    }
    exports.isAwaitExpression = isAwaitExpression;
    function isBinaryExpression(node) {
      return node.kind === ts6.SyntaxKind.BinaryExpression;
    }
    exports.isBinaryExpression = isBinaryExpression;
    function isBindingElement(node) {
      return node.kind === ts6.SyntaxKind.BindingElement;
    }
    exports.isBindingElement = isBindingElement;
    function isBindingPattern(node) {
      return node.kind === ts6.SyntaxKind.ArrayBindingPattern || node.kind === ts6.SyntaxKind.ObjectBindingPattern;
    }
    exports.isBindingPattern = isBindingPattern;
    function isBlock(node) {
      return node.kind === ts6.SyntaxKind.Block;
    }
    exports.isBlock = isBlock;
    function isBlockLike(node) {
      return node.statements !== void 0;
    }
    exports.isBlockLike = isBlockLike;
    function isBooleanLiteral(node) {
      return node.kind === ts6.SyntaxKind.TrueKeyword || node.kind === ts6.SyntaxKind.FalseKeyword;
    }
    exports.isBooleanLiteral = isBooleanLiteral;
    function isBreakOrContinueStatement(node) {
      return node.kind === ts6.SyntaxKind.BreakStatement || node.kind === ts6.SyntaxKind.ContinueStatement;
    }
    exports.isBreakOrContinueStatement = isBreakOrContinueStatement;
    function isBreakStatement(node) {
      return node.kind === ts6.SyntaxKind.BreakStatement;
    }
    exports.isBreakStatement = isBreakStatement;
    function isCallExpression2(node) {
      return node.kind === ts6.SyntaxKind.CallExpression;
    }
    exports.isCallExpression = isCallExpression2;
    function isCallLikeExpression(node) {
      switch (node.kind) {
        case ts6.SyntaxKind.CallExpression:
        case ts6.SyntaxKind.Decorator:
        case ts6.SyntaxKind.JsxOpeningElement:
        case ts6.SyntaxKind.JsxSelfClosingElement:
        case ts6.SyntaxKind.NewExpression:
        case ts6.SyntaxKind.TaggedTemplateExpression:
          return true;
        default:
          return false;
      }
    }
    exports.isCallLikeExpression = isCallLikeExpression;
    function isCallSignatureDeclaration(node) {
      return node.kind === ts6.SyntaxKind.CallSignature;
    }
    exports.isCallSignatureDeclaration = isCallSignatureDeclaration;
    function isCaseBlock(node) {
      return node.kind === ts6.SyntaxKind.CaseBlock;
    }
    exports.isCaseBlock = isCaseBlock;
    function isCaseClause(node) {
      return node.kind === ts6.SyntaxKind.CaseClause;
    }
    exports.isCaseClause = isCaseClause;
    function isCaseOrDefaultClause(node) {
      return node.kind === ts6.SyntaxKind.CaseClause || node.kind === ts6.SyntaxKind.DefaultClause;
    }
    exports.isCaseOrDefaultClause = isCaseOrDefaultClause;
    function isCatchClause(node) {
      return node.kind === ts6.SyntaxKind.CatchClause;
    }
    exports.isCatchClause = isCatchClause;
    function isClassDeclaration(node) {
      return node.kind === ts6.SyntaxKind.ClassDeclaration;
    }
    exports.isClassDeclaration = isClassDeclaration;
    function isClassExpression(node) {
      return node.kind === ts6.SyntaxKind.ClassExpression;
    }
    exports.isClassExpression = isClassExpression;
    function isClassLikeDeclaration(node) {
      return node.kind === ts6.SyntaxKind.ClassDeclaration || node.kind === ts6.SyntaxKind.ClassExpression;
    }
    exports.isClassLikeDeclaration = isClassLikeDeclaration;
    function isCommaListExpression(node) {
      return node.kind === ts6.SyntaxKind.CommaListExpression;
    }
    exports.isCommaListExpression = isCommaListExpression;
    function isConditionalExpression(node) {
      return node.kind === ts6.SyntaxKind.ConditionalExpression;
    }
    exports.isConditionalExpression = isConditionalExpression;
    function isConditionalTypeNode(node) {
      return node.kind === ts6.SyntaxKind.ConditionalType;
    }
    exports.isConditionalTypeNode = isConditionalTypeNode;
    function isConstructorDeclaration(node) {
      return node.kind === ts6.SyntaxKind.Constructor;
    }
    exports.isConstructorDeclaration = isConstructorDeclaration;
    function isConstructorTypeNode(node) {
      return node.kind === ts6.SyntaxKind.ConstructorType;
    }
    exports.isConstructorTypeNode = isConstructorTypeNode;
    function isConstructSignatureDeclaration(node) {
      return node.kind === ts6.SyntaxKind.ConstructSignature;
    }
    exports.isConstructSignatureDeclaration = isConstructSignatureDeclaration;
    function isContinueStatement(node) {
      return node.kind === ts6.SyntaxKind.ContinueStatement;
    }
    exports.isContinueStatement = isContinueStatement;
    function isComputedPropertyName(node) {
      return node.kind === ts6.SyntaxKind.ComputedPropertyName;
    }
    exports.isComputedPropertyName = isComputedPropertyName;
    function isDebuggerStatement(node) {
      return node.kind === ts6.SyntaxKind.DebuggerStatement;
    }
    exports.isDebuggerStatement = isDebuggerStatement;
    function isDecorator(node) {
      return node.kind === ts6.SyntaxKind.Decorator;
    }
    exports.isDecorator = isDecorator;
    function isDefaultClause(node) {
      return node.kind === ts6.SyntaxKind.DefaultClause;
    }
    exports.isDefaultClause = isDefaultClause;
    function isDeleteExpression(node) {
      return node.kind === ts6.SyntaxKind.DeleteExpression;
    }
    exports.isDeleteExpression = isDeleteExpression;
    function isDoStatement(node) {
      return node.kind === ts6.SyntaxKind.DoStatement;
    }
    exports.isDoStatement = isDoStatement;
    function isElementAccessExpression(node) {
      return node.kind === ts6.SyntaxKind.ElementAccessExpression;
    }
    exports.isElementAccessExpression = isElementAccessExpression;
    function isEmptyStatement(node) {
      return node.kind === ts6.SyntaxKind.EmptyStatement;
    }
    exports.isEmptyStatement = isEmptyStatement;
    function isEntityName(node) {
      return node.kind === ts6.SyntaxKind.Identifier || isQualifiedName(node);
    }
    exports.isEntityName = isEntityName;
    function isEntityNameExpression(node) {
      return node.kind === ts6.SyntaxKind.Identifier || isPropertyAccessExpression2(node) && isEntityNameExpression(node.expression);
    }
    exports.isEntityNameExpression = isEntityNameExpression;
    function isEnumDeclaration(node) {
      return node.kind === ts6.SyntaxKind.EnumDeclaration;
    }
    exports.isEnumDeclaration = isEnumDeclaration;
    function isEnumMember(node) {
      return node.kind === ts6.SyntaxKind.EnumMember;
    }
    exports.isEnumMember = isEnumMember;
    function isExportAssignment(node) {
      return node.kind === ts6.SyntaxKind.ExportAssignment;
    }
    exports.isExportAssignment = isExportAssignment;
    function isExportDeclaration(node) {
      return node.kind === ts6.SyntaxKind.ExportDeclaration;
    }
    exports.isExportDeclaration = isExportDeclaration;
    function isExportSpecifier(node) {
      return node.kind === ts6.SyntaxKind.ExportSpecifier;
    }
    exports.isExportSpecifier = isExportSpecifier;
    function isExpression(node) {
      switch (node.kind) {
        case ts6.SyntaxKind.ArrayLiteralExpression:
        case ts6.SyntaxKind.ArrowFunction:
        case ts6.SyntaxKind.AsExpression:
        case ts6.SyntaxKind.AwaitExpression:
        case ts6.SyntaxKind.BinaryExpression:
        case ts6.SyntaxKind.CallExpression:
        case ts6.SyntaxKind.ClassExpression:
        case ts6.SyntaxKind.CommaListExpression:
        case ts6.SyntaxKind.ConditionalExpression:
        case ts6.SyntaxKind.DeleteExpression:
        case ts6.SyntaxKind.ElementAccessExpression:
        case ts6.SyntaxKind.FalseKeyword:
        case ts6.SyntaxKind.FunctionExpression:
        case ts6.SyntaxKind.Identifier:
        case ts6.SyntaxKind.JsxElement:
        case ts6.SyntaxKind.JsxFragment:
        case ts6.SyntaxKind.JsxExpression:
        case ts6.SyntaxKind.JsxOpeningElement:
        case ts6.SyntaxKind.JsxOpeningFragment:
        case ts6.SyntaxKind.JsxSelfClosingElement:
        case ts6.SyntaxKind.MetaProperty:
        case ts6.SyntaxKind.NewExpression:
        case ts6.SyntaxKind.NonNullExpression:
        case ts6.SyntaxKind.NoSubstitutionTemplateLiteral:
        case ts6.SyntaxKind.NullKeyword:
        case ts6.SyntaxKind.NumericLiteral:
        case ts6.SyntaxKind.ObjectLiteralExpression:
        case ts6.SyntaxKind.OmittedExpression:
        case ts6.SyntaxKind.ParenthesizedExpression:
        case ts6.SyntaxKind.PostfixUnaryExpression:
        case ts6.SyntaxKind.PrefixUnaryExpression:
        case ts6.SyntaxKind.PropertyAccessExpression:
        case ts6.SyntaxKind.RegularExpressionLiteral:
        case ts6.SyntaxKind.SpreadElement:
        case ts6.SyntaxKind.StringLiteral:
        case ts6.SyntaxKind.SuperKeyword:
        case ts6.SyntaxKind.TaggedTemplateExpression:
        case ts6.SyntaxKind.TemplateExpression:
        case ts6.SyntaxKind.ThisKeyword:
        case ts6.SyntaxKind.TrueKeyword:
        case ts6.SyntaxKind.TypeAssertionExpression:
        case ts6.SyntaxKind.TypeOfExpression:
        case ts6.SyntaxKind.VoidExpression:
        case ts6.SyntaxKind.YieldExpression:
          return true;
        default:
          return false;
      }
    }
    exports.isExpression = isExpression;
    function isExpressionStatement(node) {
      return node.kind === ts6.SyntaxKind.ExpressionStatement;
    }
    exports.isExpressionStatement = isExpressionStatement;
    function isExpressionWithTypeArguments(node) {
      return node.kind === ts6.SyntaxKind.ExpressionWithTypeArguments;
    }
    exports.isExpressionWithTypeArguments = isExpressionWithTypeArguments;
    function isExternalModuleReference(node) {
      return node.kind === ts6.SyntaxKind.ExternalModuleReference;
    }
    exports.isExternalModuleReference = isExternalModuleReference;
    function isForInStatement(node) {
      return node.kind === ts6.SyntaxKind.ForInStatement;
    }
    exports.isForInStatement = isForInStatement;
    function isForInOrOfStatement(node) {
      return node.kind === ts6.SyntaxKind.ForOfStatement || node.kind === ts6.SyntaxKind.ForInStatement;
    }
    exports.isForInOrOfStatement = isForInOrOfStatement;
    function isForOfStatement(node) {
      return node.kind === ts6.SyntaxKind.ForOfStatement;
    }
    exports.isForOfStatement = isForOfStatement;
    function isForStatement(node) {
      return node.kind === ts6.SyntaxKind.ForStatement;
    }
    exports.isForStatement = isForStatement;
    function isFunctionDeclaration(node) {
      return node.kind === ts6.SyntaxKind.FunctionDeclaration;
    }
    exports.isFunctionDeclaration = isFunctionDeclaration;
    function isFunctionExpression(node) {
      return node.kind === ts6.SyntaxKind.FunctionExpression;
    }
    exports.isFunctionExpression = isFunctionExpression;
    function isFunctionTypeNode(node) {
      return node.kind === ts6.SyntaxKind.FunctionType;
    }
    exports.isFunctionTypeNode = isFunctionTypeNode;
    function isGetAccessorDeclaration(node) {
      return node.kind === ts6.SyntaxKind.GetAccessor;
    }
    exports.isGetAccessorDeclaration = isGetAccessorDeclaration;
    function isIdentifier3(node) {
      return node.kind === ts6.SyntaxKind.Identifier;
    }
    exports.isIdentifier = isIdentifier3;
    function isIfStatement(node) {
      return node.kind === ts6.SyntaxKind.IfStatement;
    }
    exports.isIfStatement = isIfStatement;
    function isImportClause(node) {
      return node.kind === ts6.SyntaxKind.ImportClause;
    }
    exports.isImportClause = isImportClause;
    function isImportDeclaration2(node) {
      return node.kind === ts6.SyntaxKind.ImportDeclaration;
    }
    exports.isImportDeclaration = isImportDeclaration2;
    function isImportEqualsDeclaration(node) {
      return node.kind === ts6.SyntaxKind.ImportEqualsDeclaration;
    }
    exports.isImportEqualsDeclaration = isImportEqualsDeclaration;
    function isImportSpecifier(node) {
      return node.kind === ts6.SyntaxKind.ImportSpecifier;
    }
    exports.isImportSpecifier = isImportSpecifier;
    function isIndexedAccessTypeNode(node) {
      return node.kind === ts6.SyntaxKind.IndexedAccessType;
    }
    exports.isIndexedAccessTypeNode = isIndexedAccessTypeNode;
    function isIndexSignatureDeclaration(node) {
      return node.kind === ts6.SyntaxKind.IndexSignature;
    }
    exports.isIndexSignatureDeclaration = isIndexSignatureDeclaration;
    function isInferTypeNode(node) {
      return node.kind === ts6.SyntaxKind.InferType;
    }
    exports.isInferTypeNode = isInferTypeNode;
    function isInterfaceDeclaration(node) {
      return node.kind === ts6.SyntaxKind.InterfaceDeclaration;
    }
    exports.isInterfaceDeclaration = isInterfaceDeclaration;
    function isIntersectionTypeNode(node) {
      return node.kind === ts6.SyntaxKind.IntersectionType;
    }
    exports.isIntersectionTypeNode = isIntersectionTypeNode;
    function isIterationStatement(node) {
      switch (node.kind) {
        case ts6.SyntaxKind.ForStatement:
        case ts6.SyntaxKind.ForOfStatement:
        case ts6.SyntaxKind.ForInStatement:
        case ts6.SyntaxKind.WhileStatement:
        case ts6.SyntaxKind.DoStatement:
          return true;
        default:
          return false;
      }
    }
    exports.isIterationStatement = isIterationStatement;
    function isJsDoc(node) {
      return node.kind === ts6.SyntaxKind.JSDocComment;
    }
    exports.isJsDoc = isJsDoc;
    function isJsxAttribute(node) {
      return node.kind === ts6.SyntaxKind.JsxAttribute;
    }
    exports.isJsxAttribute = isJsxAttribute;
    function isJsxAttributeLike(node) {
      return node.kind === ts6.SyntaxKind.JsxAttribute || node.kind === ts6.SyntaxKind.JsxSpreadAttribute;
    }
    exports.isJsxAttributeLike = isJsxAttributeLike;
    function isJsxAttributes(node) {
      return node.kind === ts6.SyntaxKind.JsxAttributes;
    }
    exports.isJsxAttributes = isJsxAttributes;
    function isJsxClosingElement(node) {
      return node.kind === ts6.SyntaxKind.JsxClosingElement;
    }
    exports.isJsxClosingElement = isJsxClosingElement;
    function isJsxClosingFragment(node) {
      return node.kind === ts6.SyntaxKind.JsxClosingFragment;
    }
    exports.isJsxClosingFragment = isJsxClosingFragment;
    function isJsxElement(node) {
      return node.kind === ts6.SyntaxKind.JsxElement;
    }
    exports.isJsxElement = isJsxElement;
    function isJsxExpression(node) {
      return node.kind === ts6.SyntaxKind.JsxExpression;
    }
    exports.isJsxExpression = isJsxExpression;
    function isJsxFragment(node) {
      return node.kind === ts6.SyntaxKind.JsxFragment;
    }
    exports.isJsxFragment = isJsxFragment;
    function isJsxOpeningElement(node) {
      return node.kind === ts6.SyntaxKind.JsxOpeningElement;
    }
    exports.isJsxOpeningElement = isJsxOpeningElement;
    function isJsxOpeningFragment(node) {
      return node.kind === ts6.SyntaxKind.JsxOpeningFragment;
    }
    exports.isJsxOpeningFragment = isJsxOpeningFragment;
    function isJsxOpeningLikeElement(node) {
      return node.kind === ts6.SyntaxKind.JsxOpeningElement || node.kind === ts6.SyntaxKind.JsxSelfClosingElement;
    }
    exports.isJsxOpeningLikeElement = isJsxOpeningLikeElement;
    function isJsxSelfClosingElement(node) {
      return node.kind === ts6.SyntaxKind.JsxSelfClosingElement;
    }
    exports.isJsxSelfClosingElement = isJsxSelfClosingElement;
    function isJsxSpreadAttribute(node) {
      return node.kind === ts6.SyntaxKind.JsxSpreadAttribute;
    }
    exports.isJsxSpreadAttribute = isJsxSpreadAttribute;
    function isJsxText(node) {
      return node.kind === ts6.SyntaxKind.JsxText;
    }
    exports.isJsxText = isJsxText;
    function isLabeledStatement(node) {
      return node.kind === ts6.SyntaxKind.LabeledStatement;
    }
    exports.isLabeledStatement = isLabeledStatement;
    function isLiteralExpression(node) {
      return node.kind >= ts6.SyntaxKind.FirstLiteralToken && node.kind <= ts6.SyntaxKind.LastLiteralToken;
    }
    exports.isLiteralExpression = isLiteralExpression;
    function isLiteralTypeNode(node) {
      return node.kind === ts6.SyntaxKind.LiteralType;
    }
    exports.isLiteralTypeNode = isLiteralTypeNode;
    function isMappedTypeNode(node) {
      return node.kind === ts6.SyntaxKind.MappedType;
    }
    exports.isMappedTypeNode = isMappedTypeNode;
    function isMetaProperty(node) {
      return node.kind === ts6.SyntaxKind.MetaProperty;
    }
    exports.isMetaProperty = isMetaProperty;
    function isMethodDeclaration(node) {
      return node.kind === ts6.SyntaxKind.MethodDeclaration;
    }
    exports.isMethodDeclaration = isMethodDeclaration;
    function isMethodSignature(node) {
      return node.kind === ts6.SyntaxKind.MethodSignature;
    }
    exports.isMethodSignature = isMethodSignature;
    function isModuleBlock(node) {
      return node.kind === ts6.SyntaxKind.ModuleBlock;
    }
    exports.isModuleBlock = isModuleBlock;
    function isModuleDeclaration(node) {
      return node.kind === ts6.SyntaxKind.ModuleDeclaration;
    }
    exports.isModuleDeclaration = isModuleDeclaration;
    function isNamedExports(node) {
      return node.kind === ts6.SyntaxKind.NamedExports;
    }
    exports.isNamedExports = isNamedExports;
    function isNamedImports2(node) {
      return node.kind === ts6.SyntaxKind.NamedImports;
    }
    exports.isNamedImports = isNamedImports2;
    function isNamespaceDeclaration(node) {
      return isModuleDeclaration(node) && node.name.kind === ts6.SyntaxKind.Identifier && node.body !== void 0 && (node.body.kind === ts6.SyntaxKind.ModuleBlock || isNamespaceDeclaration(node.body));
    }
    exports.isNamespaceDeclaration = isNamespaceDeclaration;
    function isNamespaceImport(node) {
      return node.kind === ts6.SyntaxKind.NamespaceImport;
    }
    exports.isNamespaceImport = isNamespaceImport;
    function isNamespaceExportDeclaration(node) {
      return node.kind === ts6.SyntaxKind.NamespaceExportDeclaration;
    }
    exports.isNamespaceExportDeclaration = isNamespaceExportDeclaration;
    function isNewExpression(node) {
      return node.kind === ts6.SyntaxKind.NewExpression;
    }
    exports.isNewExpression = isNewExpression;
    function isNonNullExpression(node) {
      return node.kind === ts6.SyntaxKind.NonNullExpression;
    }
    exports.isNonNullExpression = isNonNullExpression;
    function isNoSubstitutionTemplateLiteral3(node) {
      return node.kind === ts6.SyntaxKind.NoSubstitutionTemplateLiteral;
    }
    exports.isNoSubstitutionTemplateLiteral = isNoSubstitutionTemplateLiteral3;
    function isNullLiteral(node) {
      return node.kind === ts6.SyntaxKind.NullKeyword;
    }
    exports.isNullLiteral = isNullLiteral;
    function isNumericLiteral(node) {
      return node.kind === ts6.SyntaxKind.NumericLiteral;
    }
    exports.isNumericLiteral = isNumericLiteral;
    function isNumericOrStringLikeLiteral(node) {
      switch (node.kind) {
        case ts6.SyntaxKind.StringLiteral:
        case ts6.SyntaxKind.NumericLiteral:
        case ts6.SyntaxKind.NoSubstitutionTemplateLiteral:
          return true;
        default:
          return false;
      }
    }
    exports.isNumericOrStringLikeLiteral = isNumericOrStringLikeLiteral;
    function isObjectBindingPattern(node) {
      return node.kind === ts6.SyntaxKind.ObjectBindingPattern;
    }
    exports.isObjectBindingPattern = isObjectBindingPattern;
    function isObjectLiteralExpression(node) {
      return node.kind === ts6.SyntaxKind.ObjectLiteralExpression;
    }
    exports.isObjectLiteralExpression = isObjectLiteralExpression;
    function isOmittedExpression(node) {
      return node.kind === ts6.SyntaxKind.OmittedExpression;
    }
    exports.isOmittedExpression = isOmittedExpression;
    function isParameterDeclaration(node) {
      return node.kind === ts6.SyntaxKind.Parameter;
    }
    exports.isParameterDeclaration = isParameterDeclaration;
    function isParenthesizedExpression(node) {
      return node.kind === ts6.SyntaxKind.ParenthesizedExpression;
    }
    exports.isParenthesizedExpression = isParenthesizedExpression;
    function isParenthesizedTypeNode(node) {
      return node.kind === ts6.SyntaxKind.ParenthesizedType;
    }
    exports.isParenthesizedTypeNode = isParenthesizedTypeNode;
    function isPostfixUnaryExpression(node) {
      return node.kind === ts6.SyntaxKind.PostfixUnaryExpression;
    }
    exports.isPostfixUnaryExpression = isPostfixUnaryExpression;
    function isPrefixUnaryExpression(node) {
      return node.kind === ts6.SyntaxKind.PrefixUnaryExpression;
    }
    exports.isPrefixUnaryExpression = isPrefixUnaryExpression;
    function isPropertyAccessExpression2(node) {
      return node.kind === ts6.SyntaxKind.PropertyAccessExpression;
    }
    exports.isPropertyAccessExpression = isPropertyAccessExpression2;
    function isPropertyAssignment(node) {
      return node.kind === ts6.SyntaxKind.PropertyAssignment;
    }
    exports.isPropertyAssignment = isPropertyAssignment;
    function isPropertyDeclaration(node) {
      return node.kind === ts6.SyntaxKind.PropertyDeclaration;
    }
    exports.isPropertyDeclaration = isPropertyDeclaration;
    function isPropertySignature2(node) {
      return node.kind === ts6.SyntaxKind.PropertySignature;
    }
    exports.isPropertySignature = isPropertySignature2;
    function isQualifiedName(node) {
      return node.kind === ts6.SyntaxKind.QualifiedName;
    }
    exports.isQualifiedName = isQualifiedName;
    function isRegularExpressionLiteral(node) {
      return node.kind === ts6.SyntaxKind.RegularExpressionLiteral;
    }
    exports.isRegularExpressionLiteral = isRegularExpressionLiteral;
    function isReturnStatement(node) {
      return node.kind === ts6.SyntaxKind.ReturnStatement;
    }
    exports.isReturnStatement = isReturnStatement;
    function isSetAccessorDeclaration(node) {
      return node.kind === ts6.SyntaxKind.SetAccessor;
    }
    exports.isSetAccessorDeclaration = isSetAccessorDeclaration;
    function isShorthandPropertyAssignment(node) {
      return node.kind === ts6.SyntaxKind.ShorthandPropertyAssignment;
    }
    exports.isShorthandPropertyAssignment = isShorthandPropertyAssignment;
    function isSignatureDeclaration(node) {
      return node.parameters !== void 0;
    }
    exports.isSignatureDeclaration = isSignatureDeclaration;
    function isSourceFile(node) {
      return node.kind === ts6.SyntaxKind.SourceFile;
    }
    exports.isSourceFile = isSourceFile;
    function isSpreadAssignment(node) {
      return node.kind === ts6.SyntaxKind.SpreadAssignment;
    }
    exports.isSpreadAssignment = isSpreadAssignment;
    function isSpreadElement(node) {
      return node.kind === ts6.SyntaxKind.SpreadElement;
    }
    exports.isSpreadElement = isSpreadElement;
    function isStringLiteral2(node) {
      return node.kind === ts6.SyntaxKind.StringLiteral;
    }
    exports.isStringLiteral = isStringLiteral2;
    function isSwitchStatement(node) {
      return node.kind === ts6.SyntaxKind.SwitchStatement;
    }
    exports.isSwitchStatement = isSwitchStatement;
    function isSyntaxList(node) {
      return node.kind === ts6.SyntaxKind.SyntaxList;
    }
    exports.isSyntaxList = isSyntaxList;
    function isTaggedTemplateExpression3(node) {
      return node.kind === ts6.SyntaxKind.TaggedTemplateExpression;
    }
    exports.isTaggedTemplateExpression = isTaggedTemplateExpression3;
    function isTemplateExpression3(node) {
      return node.kind === ts6.SyntaxKind.TemplateExpression;
    }
    exports.isTemplateExpression = isTemplateExpression3;
    function isTemplateLiteral(node) {
      return node.kind === ts6.SyntaxKind.TemplateExpression || node.kind === ts6.SyntaxKind.NoSubstitutionTemplateLiteral;
    }
    exports.isTemplateLiteral = isTemplateLiteral;
    function isTextualLiteral(node) {
      return node.kind === ts6.SyntaxKind.StringLiteral || node.kind === ts6.SyntaxKind.NoSubstitutionTemplateLiteral;
    }
    exports.isTextualLiteral = isTextualLiteral;
    function isThrowStatement(node) {
      return node.kind === ts6.SyntaxKind.ThrowStatement;
    }
    exports.isThrowStatement = isThrowStatement;
    function isTryStatement(node) {
      return node.kind === ts6.SyntaxKind.TryStatement;
    }
    exports.isTryStatement = isTryStatement;
    function isTupleTypeNode(node) {
      return node.kind === ts6.SyntaxKind.TupleType;
    }
    exports.isTupleTypeNode = isTupleTypeNode;
    function isTypeAliasDeclaration(node) {
      return node.kind === ts6.SyntaxKind.TypeAliasDeclaration;
    }
    exports.isTypeAliasDeclaration = isTypeAliasDeclaration;
    function isTypeAssertion(node) {
      return node.kind === ts6.SyntaxKind.TypeAssertionExpression;
    }
    exports.isTypeAssertion = isTypeAssertion;
    function isTypeLiteralNode2(node) {
      return node.kind === ts6.SyntaxKind.TypeLiteral;
    }
    exports.isTypeLiteralNode = isTypeLiteralNode2;
    function isTypeOfExpression(node) {
      return node.kind === ts6.SyntaxKind.TypeOfExpression;
    }
    exports.isTypeOfExpression = isTypeOfExpression;
    function isTypeOperatorNode(node) {
      return node.kind === ts6.SyntaxKind.TypeOperator;
    }
    exports.isTypeOperatorNode = isTypeOperatorNode;
    function isTypeParameterDeclaration(node) {
      return node.kind === ts6.SyntaxKind.TypeParameter;
    }
    exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
    function isTypePredicateNode(node) {
      return node.kind === ts6.SyntaxKind.TypePredicate;
    }
    exports.isTypePredicateNode = isTypePredicateNode;
    function isTypeReferenceNode2(node) {
      return node.kind === ts6.SyntaxKind.TypeReference;
    }
    exports.isTypeReferenceNode = isTypeReferenceNode2;
    function isTypeQueryNode(node) {
      return node.kind === ts6.SyntaxKind.TypeQuery;
    }
    exports.isTypeQueryNode = isTypeQueryNode;
    function isUnionTypeNode(node) {
      return node.kind === ts6.SyntaxKind.UnionType;
    }
    exports.isUnionTypeNode = isUnionTypeNode;
    function isVariableDeclaration(node) {
      return node.kind === ts6.SyntaxKind.VariableDeclaration;
    }
    exports.isVariableDeclaration = isVariableDeclaration;
    function isVariableStatement2(node) {
      return node.kind === ts6.SyntaxKind.VariableStatement;
    }
    exports.isVariableStatement = isVariableStatement2;
    function isVariableDeclarationList(node) {
      return node.kind === ts6.SyntaxKind.VariableDeclarationList;
    }
    exports.isVariableDeclarationList = isVariableDeclarationList;
    function isVoidExpression(node) {
      return node.kind === ts6.SyntaxKind.VoidExpression;
    }
    exports.isVoidExpression = isVoidExpression;
    function isWhileStatement(node) {
      return node.kind === ts6.SyntaxKind.WhileStatement;
    }
    exports.isWhileStatement = isWhileStatement;
    function isWithStatement(node) {
      return node.kind === ts6.SyntaxKind.WithStatement;
    }
    exports.isWithStatement = isWithStatement;
  }
});

// node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/2.9/node.js
var require_node3 = __commonJS({
  "node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/2.9/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isImportTypeNode = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_node2(), exports);
    var ts6 = require("typescript");
    function isImportTypeNode(node) {
      return node.kind === ts6.SyntaxKind.ImportType;
    }
    exports.isImportTypeNode = isImportTypeNode;
  }
});

// node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/3.0/node.js
var require_node4 = __commonJS({
  "node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/3.0/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSyntheticExpression = exports.isRestTypeNode = exports.isOptionalTypeNode = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_node3(), exports);
    var ts6 = require("typescript");
    function isOptionalTypeNode(node) {
      return node.kind === ts6.SyntaxKind.OptionalType;
    }
    exports.isOptionalTypeNode = isOptionalTypeNode;
    function isRestTypeNode(node) {
      return node.kind === ts6.SyntaxKind.RestType;
    }
    exports.isRestTypeNode = isRestTypeNode;
    function isSyntheticExpression(node) {
      return node.kind === ts6.SyntaxKind.SyntheticExpression;
    }
    exports.isSyntheticExpression = isSyntheticExpression;
  }
});

// node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/3.2/node.js
var require_node5 = __commonJS({
  "node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/3.2/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBigIntLiteral = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_node4(), exports);
    var ts6 = require("typescript");
    function isBigIntLiteral(node) {
      return node.kind === ts6.SyntaxKind.BigIntLiteral;
    }
    exports.isBigIntLiteral = isBigIntLiteral;
  }
});

// node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/node.js
var require_node6 = __commonJS({
  "node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_node5(), exports);
  }
});

// node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/2.8/type.js
var require_type = __commonJS({
  "node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/2.8/type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isUniqueESSymbolType = exports.isUnionType = exports.isUnionOrIntersectionType = exports.isTypeVariable = exports.isTypeReference = exports.isTypeParameter = exports.isSubstitutionType = exports.isObjectType = exports.isLiteralType = exports.isIntersectionType = exports.isInterfaceType = exports.isInstantiableType = exports.isIndexedAccessype = exports.isIndexedAccessType = exports.isGenericType = exports.isEnumType = exports.isConditionalType = void 0;
    var ts6 = require("typescript");
    function isConditionalType(type) {
      return (type.flags & ts6.TypeFlags.Conditional) !== 0;
    }
    exports.isConditionalType = isConditionalType;
    function isEnumType(type) {
      return (type.flags & ts6.TypeFlags.Enum) !== 0;
    }
    exports.isEnumType = isEnumType;
    function isGenericType(type) {
      return (type.flags & ts6.TypeFlags.Object) !== 0 && (type.objectFlags & ts6.ObjectFlags.ClassOrInterface) !== 0 && (type.objectFlags & ts6.ObjectFlags.Reference) !== 0;
    }
    exports.isGenericType = isGenericType;
    function isIndexedAccessType(type) {
      return (type.flags & ts6.TypeFlags.IndexedAccess) !== 0;
    }
    exports.isIndexedAccessType = isIndexedAccessType;
    function isIndexedAccessype(type) {
      return (type.flags & ts6.TypeFlags.Index) !== 0;
    }
    exports.isIndexedAccessype = isIndexedAccessype;
    function isInstantiableType(type) {
      return (type.flags & ts6.TypeFlags.Instantiable) !== 0;
    }
    exports.isInstantiableType = isInstantiableType;
    function isInterfaceType(type) {
      return (type.flags & ts6.TypeFlags.Object) !== 0 && (type.objectFlags & ts6.ObjectFlags.ClassOrInterface) !== 0;
    }
    exports.isInterfaceType = isInterfaceType;
    function isIntersectionType(type) {
      return (type.flags & ts6.TypeFlags.Intersection) !== 0;
    }
    exports.isIntersectionType = isIntersectionType;
    function isLiteralType(type) {
      return (type.flags & (ts6.TypeFlags.StringOrNumberLiteral | ts6.TypeFlags.BigIntLiteral)) !== 0;
    }
    exports.isLiteralType = isLiteralType;
    function isObjectType(type) {
      return (type.flags & ts6.TypeFlags.Object) !== 0;
    }
    exports.isObjectType = isObjectType;
    function isSubstitutionType(type) {
      return (type.flags & ts6.TypeFlags.Substitution) !== 0;
    }
    exports.isSubstitutionType = isSubstitutionType;
    function isTypeParameter(type) {
      return (type.flags & ts6.TypeFlags.TypeParameter) !== 0;
    }
    exports.isTypeParameter = isTypeParameter;
    function isTypeReference(type) {
      return (type.flags & ts6.TypeFlags.Object) !== 0 && (type.objectFlags & ts6.ObjectFlags.Reference) !== 0;
    }
    exports.isTypeReference = isTypeReference;
    function isTypeVariable(type) {
      return (type.flags & ts6.TypeFlags.TypeVariable) !== 0;
    }
    exports.isTypeVariable = isTypeVariable;
    function isUnionOrIntersectionType(type) {
      return (type.flags & ts6.TypeFlags.UnionOrIntersection) !== 0;
    }
    exports.isUnionOrIntersectionType = isUnionOrIntersectionType;
    function isUnionType(type) {
      return (type.flags & ts6.TypeFlags.Union) !== 0;
    }
    exports.isUnionType = isUnionType;
    function isUniqueESSymbolType(type) {
      return (type.flags & ts6.TypeFlags.UniqueESSymbol) !== 0;
    }
    exports.isUniqueESSymbolType = isUniqueESSymbolType;
  }
});

// node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/2.9/type.js
var require_type2 = __commonJS({
  "node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/2.9/type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_type(), exports);
  }
});

// node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/3.0/type.js
var require_type3 = __commonJS({
  "node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/3.0/type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTupleTypeReference = exports.isTupleType = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_type2(), exports);
    var ts6 = require("typescript");
    var type_1 = require_type2();
    function isTupleType(type) {
      return (type.flags & ts6.TypeFlags.Object && type.objectFlags & ts6.ObjectFlags.Tuple) !== 0;
    }
    exports.isTupleType = isTupleType;
    function isTupleTypeReference(type) {
      return type_1.isTypeReference(type) && isTupleType(type.target);
    }
    exports.isTupleTypeReference = isTupleTypeReference;
  }
});

// node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/3.2/type.js
var require_type4 = __commonJS({
  "node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/3.2/type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_type3(), exports);
  }
});

// node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/3.2/index.js
var require__ = __commonJS({
  "node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/3.2/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_node5(), exports);
    tslib_1.__exportStar(require_type4(), exports);
  }
});

// node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/type.js
var require_type5 = __commonJS({
  "node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/typeguard/type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_type4(), exports);
  }
});

// node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/util/type.js
var require_type6 = __commonJS({
  "node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/util/type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBaseClassMemberOfClassElement = exports.getIteratorYieldResultFromIteratorResult = exports.getInstanceTypeOfClassLikeDeclaration = exports.getConstructorTypeOfClassLikeDeclaration = exports.getSymbolOfClassLikeDeclaration = exports.getPropertyNameFromType = exports.symbolHasReadonlyDeclaration = exports.isPropertyReadonlyInType = exports.getWellKnownSymbolPropertyOfType = exports.getPropertyOfType = exports.isBooleanLiteralType = exports.isFalsyType = exports.isThenableType = exports.someTypePart = exports.intersectionTypeParts = exports.unionTypeParts = exports.getCallSignaturesOfType = exports.isTypeAssignableToString = exports.isTypeAssignableToNumber = exports.isOptionalChainingUndefinedMarkerType = exports.removeOptionalChainingUndefinedMarkerType = exports.removeOptionalityFromType = exports.isEmptyObjectType = void 0;
    var ts6 = require("typescript");
    var type_1 = require_type5();
    var util_1 = require_util();
    var node_1 = require_node6();
    function isEmptyObjectType(type) {
      if (type_1.isObjectType(type) && type.objectFlags & ts6.ObjectFlags.Anonymous && type.getProperties().length === 0 && type.getCallSignatures().length === 0 && type.getConstructSignatures().length === 0 && type.getStringIndexType() === void 0 && type.getNumberIndexType() === void 0) {
        const baseTypes = type.getBaseTypes();
        return baseTypes === void 0 || baseTypes.every(isEmptyObjectType);
      }
      return false;
    }
    exports.isEmptyObjectType = isEmptyObjectType;
    function removeOptionalityFromType(checker, type) {
      if (!containsTypeWithFlag(type, ts6.TypeFlags.Undefined))
        return type;
      const allowsNull = containsTypeWithFlag(type, ts6.TypeFlags.Null);
      type = checker.getNonNullableType(type);
      return allowsNull ? checker.getNullableType(type, ts6.TypeFlags.Null) : type;
    }
    exports.removeOptionalityFromType = removeOptionalityFromType;
    function containsTypeWithFlag(type, flag) {
      for (const t of unionTypeParts(type))
        if (util_1.isTypeFlagSet(t, flag))
          return true;
      return false;
    }
    function removeOptionalChainingUndefinedMarkerType(checker, type) {
      if (!type_1.isUnionType(type))
        return isOptionalChainingUndefinedMarkerType(checker, type) ? type.getNonNullableType() : type;
      let flags = 0;
      let containsUndefinedMarker = false;
      for (const t of type.types) {
        if (isOptionalChainingUndefinedMarkerType(checker, t)) {
          containsUndefinedMarker = true;
        } else {
          flags |= t.flags;
        }
      }
      return containsUndefinedMarker ? checker.getNullableType(type.getNonNullableType(), flags) : type;
    }
    exports.removeOptionalChainingUndefinedMarkerType = removeOptionalChainingUndefinedMarkerType;
    function isOptionalChainingUndefinedMarkerType(checker, t) {
      return util_1.isTypeFlagSet(t, ts6.TypeFlags.Undefined) && checker.getNullableType(t.getNonNullableType(), ts6.TypeFlags.Undefined) !== t;
    }
    exports.isOptionalChainingUndefinedMarkerType = isOptionalChainingUndefinedMarkerType;
    function isTypeAssignableToNumber(checker, type) {
      return isTypeAssignableTo(checker, type, ts6.TypeFlags.NumberLike);
    }
    exports.isTypeAssignableToNumber = isTypeAssignableToNumber;
    function isTypeAssignableToString(checker, type) {
      return isTypeAssignableTo(checker, type, ts6.TypeFlags.StringLike);
    }
    exports.isTypeAssignableToString = isTypeAssignableToString;
    function isTypeAssignableTo(checker, type, flags) {
      flags |= ts6.TypeFlags.Any;
      let typeParametersSeen;
      return function check(t) {
        if (type_1.isTypeParameter(t) && t.symbol !== void 0 && t.symbol.declarations !== void 0) {
          if (typeParametersSeen === void 0) {
            typeParametersSeen = /* @__PURE__ */ new Set([t]);
          } else if (!typeParametersSeen.has(t)) {
            typeParametersSeen.add(t);
          } else {
            return false;
          }
          const declaration = t.symbol.declarations[0];
          if (declaration.constraint === void 0)
            return true;
          return check(checker.getTypeFromTypeNode(declaration.constraint));
        }
        if (type_1.isUnionType(t))
          return t.types.every(check);
        if (type_1.isIntersectionType(t))
          return t.types.some(check);
        return util_1.isTypeFlagSet(t, flags);
      }(type);
    }
    function getCallSignaturesOfType(type) {
      if (type_1.isUnionType(type)) {
        const signatures = [];
        for (const t of type.types)
          signatures.push(...getCallSignaturesOfType(t));
        return signatures;
      }
      if (type_1.isIntersectionType(type)) {
        let signatures;
        for (const t of type.types) {
          const sig = getCallSignaturesOfType(t);
          if (sig.length !== 0) {
            if (signatures !== void 0)
              return [];
            signatures = sig;
          }
        }
        return signatures === void 0 ? [] : signatures;
      }
      return type.getCallSignatures();
    }
    exports.getCallSignaturesOfType = getCallSignaturesOfType;
    function unionTypeParts(type) {
      return type_1.isUnionType(type) ? type.types : [type];
    }
    exports.unionTypeParts = unionTypeParts;
    function intersectionTypeParts(type) {
      return type_1.isIntersectionType(type) ? type.types : [type];
    }
    exports.intersectionTypeParts = intersectionTypeParts;
    function someTypePart(type, predicate, cb) {
      return predicate(type) ? type.types.some(cb) : cb(type);
    }
    exports.someTypePart = someTypePart;
    function isThenableType(checker, node, type = checker.getTypeAtLocation(node)) {
      for (const ty of unionTypeParts(checker.getApparentType(type))) {
        const then = ty.getProperty("then");
        if (then === void 0)
          continue;
        const thenType = checker.getTypeOfSymbolAtLocation(then, node);
        for (const t of unionTypeParts(thenType))
          for (const signature of t.getCallSignatures())
            if (signature.parameters.length !== 0 && isCallback(checker, signature.parameters[0], node))
              return true;
      }
      return false;
    }
    exports.isThenableType = isThenableType;
    function isCallback(checker, param, node) {
      let type = checker.getApparentType(checker.getTypeOfSymbolAtLocation(param, node));
      if (param.valueDeclaration.dotDotDotToken) {
        type = type.getNumberIndexType();
        if (type === void 0)
          return false;
      }
      for (const t of unionTypeParts(type))
        if (t.getCallSignatures().length !== 0)
          return true;
      return false;
    }
    function isFalsyType(type) {
      if (type.flags & (ts6.TypeFlags.Undefined | ts6.TypeFlags.Null | ts6.TypeFlags.Void))
        return true;
      if (type_1.isLiteralType(type))
        return !type.value;
      return isBooleanLiteralType(type, false);
    }
    exports.isFalsyType = isFalsyType;
    function isBooleanLiteralType(type, literal) {
      return util_1.isTypeFlagSet(type, ts6.TypeFlags.BooleanLiteral) && type.intrinsicName === (literal ? "true" : "false");
    }
    exports.isBooleanLiteralType = isBooleanLiteralType;
    function getPropertyOfType(type, name) {
      if (!name.startsWith("__"))
        return type.getProperty(name);
      return type.getProperties().find((s) => s.escapedName === name);
    }
    exports.getPropertyOfType = getPropertyOfType;
    function getWellKnownSymbolPropertyOfType(type, wellKnownSymbolName, checker) {
      const prefix = "__@" + wellKnownSymbolName;
      for (const prop of type.getProperties()) {
        if (!prop.name.startsWith(prefix))
          continue;
        const globalSymbol = checker.getApparentType(checker.getTypeAtLocation(prop.valueDeclaration.name.expression)).symbol;
        if (prop.escapedName === getPropertyNameOfWellKnownSymbol(checker, globalSymbol, wellKnownSymbolName))
          return prop;
      }
      return;
    }
    exports.getWellKnownSymbolPropertyOfType = getWellKnownSymbolPropertyOfType;
    function getPropertyNameOfWellKnownSymbol(checker, symbolConstructor, symbolName) {
      const knownSymbol = symbolConstructor && checker.getTypeOfSymbolAtLocation(symbolConstructor, symbolConstructor.valueDeclaration).getProperty(symbolName);
      const knownSymbolType = knownSymbol && checker.getTypeOfSymbolAtLocation(knownSymbol, knownSymbol.valueDeclaration);
      if (knownSymbolType && type_1.isUniqueESSymbolType(knownSymbolType))
        return knownSymbolType.escapedName;
      return "__@" + symbolName;
    }
    function isPropertyReadonlyInType(type, name, checker) {
      let seenProperty = false;
      let seenReadonlySignature = false;
      for (const t of unionTypeParts(type)) {
        if (getPropertyOfType(t, name) === void 0) {
          const index = (util_1.isNumericPropertyName(name) ? checker.getIndexInfoOfType(t, ts6.IndexKind.Number) : void 0) || checker.getIndexInfoOfType(t, ts6.IndexKind.String);
          if (index !== void 0 && index.isReadonly) {
            if (seenProperty)
              return true;
            seenReadonlySignature = true;
          }
        } else if (seenReadonlySignature || isReadonlyPropertyIntersection(t, name, checker)) {
          return true;
        } else {
          seenProperty = true;
        }
      }
      return false;
    }
    exports.isPropertyReadonlyInType = isPropertyReadonlyInType;
    function isReadonlyPropertyIntersection(type, name, checker) {
      return someTypePart(type, type_1.isIntersectionType, (t) => {
        const prop = getPropertyOfType(t, name);
        if (prop === void 0)
          return false;
        if (prop.flags & ts6.SymbolFlags.Transient) {
          if (/^(?:[1-9]\d*|0)$/.test(name) && type_1.isTupleTypeReference(t))
            return t.target.readonly;
          switch (isReadonlyPropertyFromMappedType(t, name, checker)) {
            case true:
              return true;
            case false:
              return false;
            default:
          }
        }
        return (
          // members of namespace import
          util_1.isSymbolFlagSet(prop, ts6.SymbolFlags.ValueModule) || // we unwrapped every mapped type, now we can check the actual declarations
          symbolHasReadonlyDeclaration(prop, checker)
        );
      });
    }
    function isReadonlyPropertyFromMappedType(type, name, checker) {
      if (!type_1.isObjectType(type) || !util_1.isObjectFlagSet(type, ts6.ObjectFlags.Mapped))
        return;
      const declaration = type.symbol.declarations[0];
      if (declaration.readonlyToken !== void 0 && !/^__@[^@]+$/.test(name))
        return declaration.readonlyToken.kind !== ts6.SyntaxKind.MinusToken;
      return isPropertyReadonlyInType(type.modifiersType, name, checker);
    }
    function symbolHasReadonlyDeclaration(symbol, checker) {
      return (symbol.flags & ts6.SymbolFlags.Accessor) === ts6.SymbolFlags.GetAccessor || symbol.declarations !== void 0 && symbol.declarations.some((node) => util_1.isModifierFlagSet(node, ts6.ModifierFlags.Readonly) || node_1.isVariableDeclaration(node) && util_1.isNodeFlagSet(node.parent, ts6.NodeFlags.Const) || node_1.isCallExpression(node) && util_1.isReadonlyAssignmentDeclaration(node, checker) || node_1.isEnumMember(node) || (node_1.isPropertyAssignment(node) || node_1.isShorthandPropertyAssignment(node)) && util_1.isInConstContext(node.parent));
    }
    exports.symbolHasReadonlyDeclaration = symbolHasReadonlyDeclaration;
    function getPropertyNameFromType(type) {
      if (type.flags & (ts6.TypeFlags.StringLiteral | ts6.TypeFlags.NumberLiteral)) {
        const value = String(type.value);
        return { displayName: value, symbolName: ts6.escapeLeadingUnderscores(value) };
      }
      if (type_1.isUniqueESSymbolType(type))
        return {
          displayName: `[${type.symbol ? `${isKnownSymbol(type.symbol) ? "Symbol." : ""}${type.symbol.name}` : type.escapedName.replace(/^__@|@\d+$/g, "")}]`,
          symbolName: type.escapedName
        };
    }
    exports.getPropertyNameFromType = getPropertyNameFromType;
    function isKnownSymbol(symbol) {
      return util_1.isSymbolFlagSet(symbol, ts6.SymbolFlags.Property) && symbol.valueDeclaration !== void 0 && node_1.isInterfaceDeclaration(symbol.valueDeclaration.parent) && symbol.valueDeclaration.parent.name.text === "SymbolConstructor" && isGlobalDeclaration(symbol.valueDeclaration.parent);
    }
    function isGlobalDeclaration(node) {
      return util_1.isNodeFlagSet(node.parent, ts6.NodeFlags.GlobalAugmentation) || node_1.isSourceFile(node.parent) && !ts6.isExternalModule(node.parent);
    }
    function getSymbolOfClassLikeDeclaration(node, checker) {
      var _a2;
      return checker.getSymbolAtLocation((_a2 = node.name) !== null && _a2 !== void 0 ? _a2 : util_1.getChildOfKind(node, ts6.SyntaxKind.ClassKeyword));
    }
    exports.getSymbolOfClassLikeDeclaration = getSymbolOfClassLikeDeclaration;
    function getConstructorTypeOfClassLikeDeclaration(node, checker) {
      return node.kind === ts6.SyntaxKind.ClassExpression ? checker.getTypeAtLocation(node) : checker.getTypeOfSymbolAtLocation(getSymbolOfClassLikeDeclaration(node, checker), node);
    }
    exports.getConstructorTypeOfClassLikeDeclaration = getConstructorTypeOfClassLikeDeclaration;
    function getInstanceTypeOfClassLikeDeclaration(node, checker) {
      return node.kind === ts6.SyntaxKind.ClassDeclaration ? checker.getTypeAtLocation(node) : checker.getDeclaredTypeOfSymbol(getSymbolOfClassLikeDeclaration(node, checker));
    }
    exports.getInstanceTypeOfClassLikeDeclaration = getInstanceTypeOfClassLikeDeclaration;
    function getIteratorYieldResultFromIteratorResult(type, node, checker) {
      return type_1.isUnionType(type) && type.types.find((t) => {
        const done = t.getProperty("done");
        return done !== void 0 && isBooleanLiteralType(removeOptionalityFromType(checker, checker.getTypeOfSymbolAtLocation(done, node)), false);
      }) || type;
    }
    exports.getIteratorYieldResultFromIteratorResult = getIteratorYieldResultFromIteratorResult;
    function getBaseClassMemberOfClassElement(node, checker) {
      if (!node_1.isClassLikeDeclaration(node.parent))
        return;
      const base = util_1.getBaseOfClassLikeExpression(node.parent);
      if (base === void 0)
        return;
      const name = util_1.getSingleLateBoundPropertyNameOfPropertyName(node.name, checker);
      if (name === void 0)
        return;
      const baseType = checker.getTypeAtLocation(util_1.hasModifier(node.modifiers, ts6.SyntaxKind.StaticKeyword) ? base.expression : base);
      return getPropertyOfType(baseType, name.symbolName);
    }
    exports.getBaseClassMemberOfClassElement = getBaseClassMemberOfClassElement;
  }
});

// node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/util/util.js
var require_util = __commonJS({
  "node_modules/.pnpm/tsutils@3.21.0_typescript@4.9.4/node_modules/tsutils/util/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValidIdentifier = exports.getLineBreakStyle = exports.getLineRanges = exports.forEachComment = exports.forEachTokenWithTrivia = exports.forEachToken = exports.isFunctionWithBody = exports.hasOwnThisReference = exports.isBlockScopeBoundary = exports.isFunctionScopeBoundary = exports.isTypeScopeBoundary = exports.isScopeBoundary = exports.ScopeBoundarySelector = exports.ScopeBoundary = exports.isInSingleStatementContext = exports.isBlockScopedDeclarationStatement = exports.isBlockScopedVariableDeclaration = exports.isBlockScopedVariableDeclarationList = exports.getVariableDeclarationKind = exports.VariableDeclarationKind = exports.forEachDeclaredVariable = exports.forEachDestructuringIdentifier = exports.getPropertyName = exports.getWrappedNodeAtPosition = exports.getAstNodeAtPosition = exports.commentText = exports.isPositionInComment = exports.getCommentAtPosition = exports.getTokenAtPosition = exports.getNextToken = exports.getPreviousToken = exports.getNextStatement = exports.getPreviousStatement = exports.isModifierFlagSet = exports.isObjectFlagSet = exports.isSymbolFlagSet = exports.isTypeFlagSet = exports.isNodeFlagSet = exports.hasAccessModifier = exports.isParameterProperty = exports.hasModifier = exports.getModifier = exports.isThisParameter = exports.isKeywordKind = exports.isJsDocKind = exports.isTypeNodeKind = exports.isAssignmentKind = exports.isNodeKind = exports.isTokenKind = exports.getChildOfKind = void 0;
    exports.getBaseOfClassLikeExpression = exports.hasExhaustiveCaseClauses = exports.formatPseudoBigInt = exports.unwrapParentheses = exports.getSingleLateBoundPropertyNameOfPropertyName = exports.getLateBoundPropertyNamesOfPropertyName = exports.getLateBoundPropertyNames = exports.getPropertyNameOfWellKnownSymbol = exports.isWellKnownSymbolLiterally = exports.isBindableObjectDefinePropertyCall = exports.isReadonlyAssignmentDeclaration = exports.isInConstContext = exports.isConstAssertion = exports.getTsCheckDirective = exports.getCheckJsDirective = exports.isAmbientModule = exports.isCompilerOptionEnabled = exports.isStrictCompilerOptionEnabled = exports.getIIFE = exports.isAmbientModuleBlock = exports.isStatementInAmbientContext = exports.findImportLikeNodes = exports.findImports = exports.ImportKind = exports.parseJsDocOfNode = exports.getJsDoc = exports.canHaveJsDoc = exports.isReassignmentTarget = exports.getAccessKind = exports.AccessKind = exports.isExpressionValueUsed = exports.getDeclarationOfBindingElement = exports.hasSideEffects = exports.SideEffectOptions = exports.isSameLine = exports.isNumericPropertyName = exports.isValidJsxIdentifier = exports.isValidNumericLiteral = exports.isValidPropertyName = exports.isValidPropertyAccess = void 0;
    var ts6 = require("typescript");
    var node_1 = require_node6();
    var _3_2_1 = require__();
    var type_1 = require_type6();
    function getChildOfKind(node, kind, sourceFile) {
      for (const child of node.getChildren(sourceFile))
        if (child.kind === kind)
          return child;
    }
    exports.getChildOfKind = getChildOfKind;
    function isTokenKind(kind) {
      return kind >= ts6.SyntaxKind.FirstToken && kind <= ts6.SyntaxKind.LastToken;
    }
    exports.isTokenKind = isTokenKind;
    function isNodeKind(kind) {
      return kind >= ts6.SyntaxKind.FirstNode;
    }
    exports.isNodeKind = isNodeKind;
    function isAssignmentKind(kind) {
      return kind >= ts6.SyntaxKind.FirstAssignment && kind <= ts6.SyntaxKind.LastAssignment;
    }
    exports.isAssignmentKind = isAssignmentKind;
    function isTypeNodeKind(kind) {
      return kind >= ts6.SyntaxKind.FirstTypeNode && kind <= ts6.SyntaxKind.LastTypeNode;
    }
    exports.isTypeNodeKind = isTypeNodeKind;
    function isJsDocKind(kind) {
      return kind >= ts6.SyntaxKind.FirstJSDocNode && kind <= ts6.SyntaxKind.LastJSDocNode;
    }
    exports.isJsDocKind = isJsDocKind;
    function isKeywordKind(kind) {
      return kind >= ts6.SyntaxKind.FirstKeyword && kind <= ts6.SyntaxKind.LastKeyword;
    }
    exports.isKeywordKind = isKeywordKind;
    function isThisParameter(parameter) {
      return parameter.name.kind === ts6.SyntaxKind.Identifier && parameter.name.originalKeywordKind === ts6.SyntaxKind.ThisKeyword;
    }
    exports.isThisParameter = isThisParameter;
    function getModifier(node, kind) {
      if (node.modifiers !== void 0) {
        for (const modifier of node.modifiers)
          if (modifier.kind === kind)
            return modifier;
      }
    }
    exports.getModifier = getModifier;
    function hasModifier(modifiers, ...kinds) {
      if (modifiers === void 0)
        return false;
      for (const modifier of modifiers)
        if (kinds.includes(modifier.kind))
          return true;
      return false;
    }
    exports.hasModifier = hasModifier;
    function isParameterProperty(node) {
      return hasModifier(node.modifiers, ts6.SyntaxKind.PublicKeyword, ts6.SyntaxKind.ProtectedKeyword, ts6.SyntaxKind.PrivateKeyword, ts6.SyntaxKind.ReadonlyKeyword);
    }
    exports.isParameterProperty = isParameterProperty;
    function hasAccessModifier(node) {
      return isModifierFlagSet(node, ts6.ModifierFlags.AccessibilityModifier);
    }
    exports.hasAccessModifier = hasAccessModifier;
    function isFlagSet(obj, flag) {
      return (obj.flags & flag) !== 0;
    }
    exports.isNodeFlagSet = isFlagSet;
    exports.isTypeFlagSet = isFlagSet;
    exports.isSymbolFlagSet = isFlagSet;
    function isObjectFlagSet(objectType, flag) {
      return (objectType.objectFlags & flag) !== 0;
    }
    exports.isObjectFlagSet = isObjectFlagSet;
    function isModifierFlagSet(node, flag) {
      return (ts6.getCombinedModifierFlags(node) & flag) !== 0;
    }
    exports.isModifierFlagSet = isModifierFlagSet;
    function getPreviousStatement(statement) {
      const parent = statement.parent;
      if (node_1.isBlockLike(parent)) {
        const index = parent.statements.indexOf(statement);
        if (index > 0)
          return parent.statements[index - 1];
      }
    }
    exports.getPreviousStatement = getPreviousStatement;
    function getNextStatement(statement) {
      const parent = statement.parent;
      if (node_1.isBlockLike(parent)) {
        const index = parent.statements.indexOf(statement);
        if (index < parent.statements.length)
          return parent.statements[index + 1];
      }
    }
    exports.getNextStatement = getNextStatement;
    function getPreviousToken(node, sourceFile) {
      const { pos } = node;
      if (pos === 0)
        return;
      do
        node = node.parent;
      while (node.pos === pos);
      return getTokenAtPositionWorker(node, pos - 1, sourceFile !== null && sourceFile !== void 0 ? sourceFile : node.getSourceFile(), false);
    }
    exports.getPreviousToken = getPreviousToken;
    function getNextToken(node, sourceFile) {
      if (node.kind === ts6.SyntaxKind.SourceFile || node.kind === ts6.SyntaxKind.EndOfFileToken)
        return;
      const end = node.end;
      node = node.parent;
      while (node.end === end) {
        if (node.parent === void 0)
          return node.endOfFileToken;
        node = node.parent;
      }
      return getTokenAtPositionWorker(node, end, sourceFile !== null && sourceFile !== void 0 ? sourceFile : node.getSourceFile(), false);
    }
    exports.getNextToken = getNextToken;
    function getTokenAtPosition(parent, pos, sourceFile, allowJsDoc) {
      if (pos < parent.pos || pos >= parent.end)
        return;
      if (isTokenKind(parent.kind))
        return parent;
      return getTokenAtPositionWorker(parent, pos, sourceFile !== null && sourceFile !== void 0 ? sourceFile : parent.getSourceFile(), allowJsDoc === true);
    }
    exports.getTokenAtPosition = getTokenAtPosition;
    function getTokenAtPositionWorker(node, pos, sourceFile, allowJsDoc) {
      if (!allowJsDoc) {
        node = getAstNodeAtPosition(node, pos);
        if (isTokenKind(node.kind))
          return node;
      }
      outer:
        while (true) {
          for (const child of node.getChildren(sourceFile)) {
            if (child.end > pos && (allowJsDoc || child.kind !== ts6.SyntaxKind.JSDocComment)) {
              if (isTokenKind(child.kind))
                return child;
              node = child;
              continue outer;
            }
          }
          return;
        }
    }
    function getCommentAtPosition(sourceFile, pos, parent = sourceFile) {
      const token = getTokenAtPosition(parent, pos, sourceFile);
      if (token === void 0 || token.kind === ts6.SyntaxKind.JsxText || pos >= token.end - (ts6.tokenToString(token.kind) || "").length)
        return;
      const startPos = token.pos === 0 ? (ts6.getShebang(sourceFile.text) || "").length : token.pos;
      return startPos !== 0 && ts6.forEachTrailingCommentRange(sourceFile.text, startPos, commentAtPositionCallback, pos) || ts6.forEachLeadingCommentRange(sourceFile.text, startPos, commentAtPositionCallback, pos);
    }
    exports.getCommentAtPosition = getCommentAtPosition;
    function commentAtPositionCallback(pos, end, kind, _nl, at) {
      return at >= pos && at < end ? { pos, end, kind } : void 0;
    }
    function isPositionInComment(sourceFile, pos, parent) {
      return getCommentAtPosition(sourceFile, pos, parent) !== void 0;
    }
    exports.isPositionInComment = isPositionInComment;
    function commentText(sourceText, comment) {
      return sourceText.substring(comment.pos + 2, comment.kind === ts6.SyntaxKind.SingleLineCommentTrivia ? comment.end : comment.end - 2);
    }
    exports.commentText = commentText;
    function getAstNodeAtPosition(node, pos) {
      if (node.pos > pos || node.end <= pos)
        return;
      while (isNodeKind(node.kind)) {
        const nested = ts6.forEachChild(node, (child) => child.pos <= pos && child.end > pos ? child : void 0);
        if (nested === void 0)
          break;
        node = nested;
      }
      return node;
    }
    exports.getAstNodeAtPosition = getAstNodeAtPosition;
    function getWrappedNodeAtPosition(wrap, pos) {
      if (wrap.node.pos > pos || wrap.node.end <= pos)
        return;
      outer:
        while (true) {
          for (const child of wrap.children) {
            if (child.node.pos > pos)
              return wrap;
            if (child.node.end > pos) {
              wrap = child;
              continue outer;
            }
          }
          return wrap;
        }
    }
    exports.getWrappedNodeAtPosition = getWrappedNodeAtPosition;
    function getPropertyName(propertyName) {
      if (propertyName.kind === ts6.SyntaxKind.ComputedPropertyName) {
        const expression = unwrapParentheses(propertyName.expression);
        if (node_1.isPrefixUnaryExpression(expression)) {
          let negate = false;
          switch (expression.operator) {
            case ts6.SyntaxKind.MinusToken:
              negate = true;
            case ts6.SyntaxKind.PlusToken:
              return node_1.isNumericLiteral(expression.operand) ? `${negate ? "-" : ""}${expression.operand.text}` : _3_2_1.isBigIntLiteral(expression.operand) ? `${negate ? "-" : ""}${expression.operand.text.slice(0, -1)}` : void 0;
            default:
              return;
          }
        }
        if (_3_2_1.isBigIntLiteral(expression))
          return expression.text.slice(0, -1);
        if (node_1.isNumericOrStringLikeLiteral(expression))
          return expression.text;
        return;
      }
      return propertyName.kind === ts6.SyntaxKind.PrivateIdentifier ? void 0 : propertyName.text;
    }
    exports.getPropertyName = getPropertyName;
    function forEachDestructuringIdentifier(pattern, fn) {
      for (const element of pattern.elements) {
        if (element.kind !== ts6.SyntaxKind.BindingElement)
          continue;
        let result;
        if (element.name.kind === ts6.SyntaxKind.Identifier) {
          result = fn(element);
        } else {
          result = forEachDestructuringIdentifier(element.name, fn);
        }
        if (result)
          return result;
      }
    }
    exports.forEachDestructuringIdentifier = forEachDestructuringIdentifier;
    function forEachDeclaredVariable(declarationList, cb) {
      for (const declaration of declarationList.declarations) {
        let result;
        if (declaration.name.kind === ts6.SyntaxKind.Identifier) {
          result = cb(declaration);
        } else {
          result = forEachDestructuringIdentifier(declaration.name, cb);
        }
        if (result)
          return result;
      }
    }
    exports.forEachDeclaredVariable = forEachDeclaredVariable;
    var VariableDeclarationKind;
    (function(VariableDeclarationKind2) {
      VariableDeclarationKind2[VariableDeclarationKind2["Var"] = 0] = "Var";
      VariableDeclarationKind2[VariableDeclarationKind2["Let"] = 1] = "Let";
      VariableDeclarationKind2[VariableDeclarationKind2["Const"] = 2] = "Const";
    })(VariableDeclarationKind = exports.VariableDeclarationKind || (exports.VariableDeclarationKind = {}));
    function getVariableDeclarationKind(declarationList) {
      if (declarationList.flags & ts6.NodeFlags.Let)
        return 1;
      if (declarationList.flags & ts6.NodeFlags.Const)
        return 2;
      return 0;
    }
    exports.getVariableDeclarationKind = getVariableDeclarationKind;
    function isBlockScopedVariableDeclarationList(declarationList) {
      return (declarationList.flags & ts6.NodeFlags.BlockScoped) !== 0;
    }
    exports.isBlockScopedVariableDeclarationList = isBlockScopedVariableDeclarationList;
    function isBlockScopedVariableDeclaration(declaration) {
      const parent = declaration.parent;
      return parent.kind === ts6.SyntaxKind.CatchClause || isBlockScopedVariableDeclarationList(parent);
    }
    exports.isBlockScopedVariableDeclaration = isBlockScopedVariableDeclaration;
    function isBlockScopedDeclarationStatement(statement) {
      switch (statement.kind) {
        case ts6.SyntaxKind.VariableStatement:
          return isBlockScopedVariableDeclarationList(statement.declarationList);
        case ts6.SyntaxKind.ClassDeclaration:
        case ts6.SyntaxKind.EnumDeclaration:
        case ts6.SyntaxKind.InterfaceDeclaration:
        case ts6.SyntaxKind.TypeAliasDeclaration:
          return true;
        default:
          return false;
      }
    }
    exports.isBlockScopedDeclarationStatement = isBlockScopedDeclarationStatement;
    function isInSingleStatementContext(statement) {
      switch (statement.parent.kind) {
        case ts6.SyntaxKind.ForStatement:
        case ts6.SyntaxKind.ForInStatement:
        case ts6.SyntaxKind.ForOfStatement:
        case ts6.SyntaxKind.WhileStatement:
        case ts6.SyntaxKind.DoStatement:
        case ts6.SyntaxKind.IfStatement:
        case ts6.SyntaxKind.WithStatement:
        case ts6.SyntaxKind.LabeledStatement:
          return true;
        default:
          return false;
      }
    }
    exports.isInSingleStatementContext = isInSingleStatementContext;
    var ScopeBoundary;
    (function(ScopeBoundary2) {
      ScopeBoundary2[ScopeBoundary2["None"] = 0] = "None";
      ScopeBoundary2[ScopeBoundary2["Function"] = 1] = "Function";
      ScopeBoundary2[ScopeBoundary2["Block"] = 2] = "Block";
      ScopeBoundary2[ScopeBoundary2["Type"] = 4] = "Type";
      ScopeBoundary2[ScopeBoundary2["ConditionalType"] = 8] = "ConditionalType";
    })(ScopeBoundary = exports.ScopeBoundary || (exports.ScopeBoundary = {}));
    var ScopeBoundarySelector;
    (function(ScopeBoundarySelector2) {
      ScopeBoundarySelector2[ScopeBoundarySelector2["Function"] = 1] = "Function";
      ScopeBoundarySelector2[ScopeBoundarySelector2["Block"] = 3] = "Block";
      ScopeBoundarySelector2[ScopeBoundarySelector2["Type"] = 7] = "Type";
      ScopeBoundarySelector2[ScopeBoundarySelector2["InferType"] = 8] = "InferType";
    })(ScopeBoundarySelector = exports.ScopeBoundarySelector || (exports.ScopeBoundarySelector = {}));
    function isScopeBoundary(node) {
      return isFunctionScopeBoundary(node) || isBlockScopeBoundary(node) || isTypeScopeBoundary(node);
    }
    exports.isScopeBoundary = isScopeBoundary;
    function isTypeScopeBoundary(node) {
      switch (node.kind) {
        case ts6.SyntaxKind.InterfaceDeclaration:
        case ts6.SyntaxKind.TypeAliasDeclaration:
        case ts6.SyntaxKind.MappedType:
          return 4;
        case ts6.SyntaxKind.ConditionalType:
          return 8;
        default:
          return 0;
      }
    }
    exports.isTypeScopeBoundary = isTypeScopeBoundary;
    function isFunctionScopeBoundary(node) {
      switch (node.kind) {
        case ts6.SyntaxKind.FunctionExpression:
        case ts6.SyntaxKind.ArrowFunction:
        case ts6.SyntaxKind.Constructor:
        case ts6.SyntaxKind.ModuleDeclaration:
        case ts6.SyntaxKind.ClassDeclaration:
        case ts6.SyntaxKind.ClassExpression:
        case ts6.SyntaxKind.EnumDeclaration:
        case ts6.SyntaxKind.MethodDeclaration:
        case ts6.SyntaxKind.FunctionDeclaration:
        case ts6.SyntaxKind.GetAccessor:
        case ts6.SyntaxKind.SetAccessor:
        case ts6.SyntaxKind.MethodSignature:
        case ts6.SyntaxKind.CallSignature:
        case ts6.SyntaxKind.ConstructSignature:
        case ts6.SyntaxKind.ConstructorType:
        case ts6.SyntaxKind.FunctionType:
          return 1;
        case ts6.SyntaxKind.SourceFile:
          return ts6.isExternalModule(node) ? 1 : 0;
        default:
          return 0;
      }
    }
    exports.isFunctionScopeBoundary = isFunctionScopeBoundary;
    function isBlockScopeBoundary(node) {
      switch (node.kind) {
        case ts6.SyntaxKind.Block:
          const parent = node.parent;
          return parent.kind !== ts6.SyntaxKind.CatchClause && // blocks inside SourceFile are block scope boundaries
          (parent.kind === ts6.SyntaxKind.SourceFile || // blocks that are direct children of a function scope boundary are no scope boundary
          // for example the FunctionBlock is part of the function scope of the containing function
          !isFunctionScopeBoundary(parent)) ? 2 : 0;
        case ts6.SyntaxKind.ForStatement:
        case ts6.SyntaxKind.ForInStatement:
        case ts6.SyntaxKind.ForOfStatement:
        case ts6.SyntaxKind.CaseBlock:
        case ts6.SyntaxKind.CatchClause:
        case ts6.SyntaxKind.WithStatement:
          return 2;
        default:
          return 0;
      }
    }
    exports.isBlockScopeBoundary = isBlockScopeBoundary;
    function hasOwnThisReference(node) {
      switch (node.kind) {
        case ts6.SyntaxKind.ClassDeclaration:
        case ts6.SyntaxKind.ClassExpression:
        case ts6.SyntaxKind.FunctionExpression:
          return true;
        case ts6.SyntaxKind.FunctionDeclaration:
          return node.body !== void 0;
        case ts6.SyntaxKind.MethodDeclaration:
        case ts6.SyntaxKind.GetAccessor:
        case ts6.SyntaxKind.SetAccessor:
          return node.parent.kind === ts6.SyntaxKind.ObjectLiteralExpression;
        default:
          return false;
      }
    }
    exports.hasOwnThisReference = hasOwnThisReference;
    function isFunctionWithBody(node) {
      switch (node.kind) {
        case ts6.SyntaxKind.GetAccessor:
        case ts6.SyntaxKind.SetAccessor:
        case ts6.SyntaxKind.FunctionDeclaration:
        case ts6.SyntaxKind.MethodDeclaration:
        case ts6.SyntaxKind.Constructor:
          return node.body !== void 0;
        case ts6.SyntaxKind.FunctionExpression:
        case ts6.SyntaxKind.ArrowFunction:
          return true;
        default:
          return false;
      }
    }
    exports.isFunctionWithBody = isFunctionWithBody;
    function forEachToken(node, cb, sourceFile = node.getSourceFile()) {
      const queue = [];
      while (true) {
        if (isTokenKind(node.kind)) {
          cb(node);
        } else if (node.kind !== ts6.SyntaxKind.JSDocComment) {
          const children = node.getChildren(sourceFile);
          if (children.length === 1) {
            node = children[0];
            continue;
          }
          for (let i = children.length - 1; i >= 0; --i)
            queue.push(children[i]);
        }
        if (queue.length === 0)
          break;
        node = queue.pop();
      }
    }
    exports.forEachToken = forEachToken;
    function forEachTokenWithTrivia(node, cb, sourceFile = node.getSourceFile()) {
      const fullText = sourceFile.text;
      const scanner = ts6.createScanner(sourceFile.languageVersion, false, sourceFile.languageVariant, fullText);
      return forEachToken(node, (token) => {
        const tokenStart = token.kind === ts6.SyntaxKind.JsxText || token.pos === token.end ? token.pos : token.getStart(sourceFile);
        if (tokenStart !== token.pos) {
          scanner.setTextPos(token.pos);
          let kind = scanner.scan();
          let pos = scanner.getTokenPos();
          while (pos < tokenStart) {
            const textPos = scanner.getTextPos();
            cb(fullText, kind, { pos, end: textPos }, token.parent);
            if (textPos === tokenStart)
              break;
            kind = scanner.scan();
            pos = scanner.getTokenPos();
          }
        }
        return cb(fullText, token.kind, { end: token.end, pos: tokenStart }, token.parent);
      }, sourceFile);
    }
    exports.forEachTokenWithTrivia = forEachTokenWithTrivia;
    function forEachComment(node, cb, sourceFile = node.getSourceFile()) {
      const fullText = sourceFile.text;
      const notJsx = sourceFile.languageVariant !== ts6.LanguageVariant.JSX;
      return forEachToken(node, (token) => {
        if (token.pos === token.end)
          return;
        if (token.kind !== ts6.SyntaxKind.JsxText)
          ts6.forEachLeadingCommentRange(
            fullText,
            // skip shebang at position 0
            token.pos === 0 ? (ts6.getShebang(fullText) || "").length : token.pos,
            commentCallback
          );
        if (notJsx || canHaveTrailingTrivia(token))
          return ts6.forEachTrailingCommentRange(fullText, token.end, commentCallback);
      }, sourceFile);
      function commentCallback(pos, end, kind) {
        cb(fullText, { pos, end, kind });
      }
    }
    exports.forEachComment = forEachComment;
    function canHaveTrailingTrivia(token) {
      switch (token.kind) {
        case ts6.SyntaxKind.CloseBraceToken:
          return token.parent.kind !== ts6.SyntaxKind.JsxExpression || !isJsxElementOrFragment(token.parent.parent);
        case ts6.SyntaxKind.GreaterThanToken:
          switch (token.parent.kind) {
            case ts6.SyntaxKind.JsxOpeningElement:
              return token.end !== token.parent.end;
            case ts6.SyntaxKind.JsxOpeningFragment:
              return false;
            case ts6.SyntaxKind.JsxSelfClosingElement:
              return token.end !== token.parent.end || // if end is not equal, this is part of the type arguments list
              !isJsxElementOrFragment(token.parent.parent);
            case ts6.SyntaxKind.JsxClosingElement:
            case ts6.SyntaxKind.JsxClosingFragment:
              return !isJsxElementOrFragment(token.parent.parent.parent);
          }
      }
      return true;
    }
    function isJsxElementOrFragment(node) {
      return node.kind === ts6.SyntaxKind.JsxElement || node.kind === ts6.SyntaxKind.JsxFragment;
    }
    function getLineRanges(sourceFile) {
      const lineStarts = sourceFile.getLineStarts();
      const result = [];
      const length = lineStarts.length;
      const sourceText = sourceFile.text;
      let pos = 0;
      for (let i = 1; i < length; ++i) {
        const end = lineStarts[i];
        let lineEnd = end;
        for (; lineEnd > pos; --lineEnd)
          if (!ts6.isLineBreak(sourceText.charCodeAt(lineEnd - 1)))
            break;
        result.push({
          pos,
          end,
          contentLength: lineEnd - pos
        });
        pos = end;
      }
      result.push({
        pos,
        end: sourceFile.end,
        contentLength: sourceFile.end - pos
      });
      return result;
    }
    exports.getLineRanges = getLineRanges;
    function getLineBreakStyle(sourceFile) {
      const lineStarts = sourceFile.getLineStarts();
      return lineStarts.length === 1 || lineStarts[1] < 2 || sourceFile.text[lineStarts[1] - 2] !== "\r" ? "\n" : "\r\n";
    }
    exports.getLineBreakStyle = getLineBreakStyle;
    var cachedScanner;
    function scanToken(text, languageVersion) {
      if (cachedScanner === void 0) {
        cachedScanner = ts6.createScanner(languageVersion, false, void 0, text);
      } else {
        cachedScanner.setScriptTarget(languageVersion);
        cachedScanner.setText(text);
      }
      cachedScanner.scan();
      return cachedScanner;
    }
    function isValidIdentifier(text, languageVersion = ts6.ScriptTarget.Latest) {
      const scan = scanToken(text, languageVersion);
      return scan.isIdentifier() && scan.getTextPos() === text.length && scan.getTokenPos() === 0;
    }
    exports.isValidIdentifier = isValidIdentifier;
    function charSize(ch) {
      return ch >= 65536 ? 2 : 1;
    }
    function isValidPropertyAccess(text, languageVersion = ts6.ScriptTarget.Latest) {
      if (text.length === 0)
        return false;
      let ch = text.codePointAt(0);
      if (!ts6.isIdentifierStart(ch, languageVersion))
        return false;
      for (let i = charSize(ch); i < text.length; i += charSize(ch)) {
        ch = text.codePointAt(i);
        if (!ts6.isIdentifierPart(ch, languageVersion))
          return false;
      }
      return true;
    }
    exports.isValidPropertyAccess = isValidPropertyAccess;
    function isValidPropertyName(text, languageVersion = ts6.ScriptTarget.Latest) {
      if (isValidPropertyAccess(text, languageVersion))
        return true;
      const scan = scanToken(text, languageVersion);
      return scan.getTextPos() === text.length && scan.getToken() === ts6.SyntaxKind.NumericLiteral && scan.getTokenValue() === text;
    }
    exports.isValidPropertyName = isValidPropertyName;
    function isValidNumericLiteral(text, languageVersion = ts6.ScriptTarget.Latest) {
      const scan = scanToken(text, languageVersion);
      return scan.getToken() === ts6.SyntaxKind.NumericLiteral && scan.getTextPos() === text.length && scan.getTokenPos() === 0;
    }
    exports.isValidNumericLiteral = isValidNumericLiteral;
    function isValidJsxIdentifier(text, languageVersion = ts6.ScriptTarget.Latest) {
      if (text.length === 0)
        return false;
      let seenNamespaceSeparator = false;
      let ch = text.codePointAt(0);
      if (!ts6.isIdentifierStart(ch, languageVersion))
        return false;
      for (let i = charSize(ch); i < text.length; i += charSize(ch)) {
        ch = text.codePointAt(i);
        if (!ts6.isIdentifierPart(ch, languageVersion) && ch !== 45) {
          if (!seenNamespaceSeparator && ch === 58 && i + charSize(ch) !== text.length) {
            seenNamespaceSeparator = true;
          } else {
            return false;
          }
        }
      }
      return true;
    }
    exports.isValidJsxIdentifier = isValidJsxIdentifier;
    function isNumericPropertyName(name) {
      return String(+name) === name;
    }
    exports.isNumericPropertyName = isNumericPropertyName;
    function isSameLine(sourceFile, pos1, pos2) {
      return ts6.getLineAndCharacterOfPosition(sourceFile, pos1).line === ts6.getLineAndCharacterOfPosition(sourceFile, pos2).line;
    }
    exports.isSameLine = isSameLine;
    var SideEffectOptions;
    (function(SideEffectOptions2) {
      SideEffectOptions2[SideEffectOptions2["None"] = 0] = "None";
      SideEffectOptions2[SideEffectOptions2["TaggedTemplate"] = 1] = "TaggedTemplate";
      SideEffectOptions2[SideEffectOptions2["Constructor"] = 2] = "Constructor";
      SideEffectOptions2[SideEffectOptions2["JsxElement"] = 4] = "JsxElement";
    })(SideEffectOptions = exports.SideEffectOptions || (exports.SideEffectOptions = {}));
    function hasSideEffects(node, options) {
      var _a2, _b;
      const queue = [];
      while (true) {
        switch (node.kind) {
          case ts6.SyntaxKind.CallExpression:
          case ts6.SyntaxKind.PostfixUnaryExpression:
          case ts6.SyntaxKind.AwaitExpression:
          case ts6.SyntaxKind.YieldExpression:
          case ts6.SyntaxKind.DeleteExpression:
            return true;
          case ts6.SyntaxKind.TypeAssertionExpression:
          case ts6.SyntaxKind.AsExpression:
          case ts6.SyntaxKind.ParenthesizedExpression:
          case ts6.SyntaxKind.NonNullExpression:
          case ts6.SyntaxKind.VoidExpression:
          case ts6.SyntaxKind.TypeOfExpression:
          case ts6.SyntaxKind.PropertyAccessExpression:
          case ts6.SyntaxKind.SpreadElement:
          case ts6.SyntaxKind.PartiallyEmittedExpression:
            node = node.expression;
            continue;
          case ts6.SyntaxKind.BinaryExpression:
            if (isAssignmentKind(node.operatorToken.kind))
              return true;
            queue.push(node.right);
            node = node.left;
            continue;
          case ts6.SyntaxKind.PrefixUnaryExpression:
            switch (node.operator) {
              case ts6.SyntaxKind.PlusPlusToken:
              case ts6.SyntaxKind.MinusMinusToken:
                return true;
              default:
                node = node.operand;
                continue;
            }
          case ts6.SyntaxKind.ElementAccessExpression:
            if (node.argumentExpression !== void 0)
              queue.push(node.argumentExpression);
            node = node.expression;
            continue;
          case ts6.SyntaxKind.ConditionalExpression:
            queue.push(node.whenTrue, node.whenFalse);
            node = node.condition;
            continue;
          case ts6.SyntaxKind.NewExpression:
            if (options & 2)
              return true;
            if (node.arguments !== void 0)
              queue.push(...node.arguments);
            node = node.expression;
            continue;
          case ts6.SyntaxKind.TaggedTemplateExpression:
            if (options & 1)
              return true;
            queue.push(node.tag);
            node = node.template;
            if (node.kind === ts6.SyntaxKind.NoSubstitutionTemplateLiteral)
              break;
          case ts6.SyntaxKind.TemplateExpression:
            for (const child of node.templateSpans)
              queue.push(child.expression);
            break;
          case ts6.SyntaxKind.ClassExpression: {
            if (node.decorators !== void 0)
              return true;
            for (const child of node.members) {
              if (child.decorators !== void 0)
                return true;
              if (!hasModifier(child.modifiers, ts6.SyntaxKind.DeclareKeyword)) {
                if (((_a2 = child.name) === null || _a2 === void 0 ? void 0 : _a2.kind) === ts6.SyntaxKind.ComputedPropertyName)
                  queue.push(child.name.expression);
                if (node_1.isMethodDeclaration(child)) {
                  for (const p of child.parameters)
                    if (p.decorators !== void 0)
                      return true;
                } else if (node_1.isPropertyDeclaration(child) && child.initializer !== void 0 && hasModifier(child.modifiers, ts6.SyntaxKind.StaticKeyword)) {
                  queue.push(child.initializer);
                }
              }
            }
            const base = getBaseOfClassLikeExpression(node);
            if (base === void 0)
              break;
            node = base.expression;
            continue;
          }
          case ts6.SyntaxKind.ArrayLiteralExpression:
            queue.push(...node.elements);
            break;
          case ts6.SyntaxKind.ObjectLiteralExpression:
            for (const child of node.properties) {
              if (((_b = child.name) === null || _b === void 0 ? void 0 : _b.kind) === ts6.SyntaxKind.ComputedPropertyName)
                queue.push(child.name.expression);
              switch (child.kind) {
                case ts6.SyntaxKind.PropertyAssignment:
                  queue.push(child.initializer);
                  break;
                case ts6.SyntaxKind.SpreadAssignment:
                  queue.push(child.expression);
              }
            }
            break;
          case ts6.SyntaxKind.JsxExpression:
            if (node.expression === void 0)
              break;
            node = node.expression;
            continue;
          case ts6.SyntaxKind.JsxElement:
          case ts6.SyntaxKind.JsxFragment:
            for (const child of node.children)
              if (child.kind !== ts6.SyntaxKind.JsxText)
                queue.push(child);
            if (node.kind === ts6.SyntaxKind.JsxFragment)
              break;
            node = node.openingElement;
          case ts6.SyntaxKind.JsxSelfClosingElement:
          case ts6.SyntaxKind.JsxOpeningElement:
            if (options & 4)
              return true;
            for (const child of node.attributes.properties) {
              if (child.kind === ts6.SyntaxKind.JsxSpreadAttribute) {
                queue.push(child.expression);
              } else if (child.initializer !== void 0) {
                queue.push(child.initializer);
              }
            }
            break;
          case ts6.SyntaxKind.CommaListExpression:
            queue.push(...node.elements);
        }
        if (queue.length === 0)
          return false;
        node = queue.pop();
      }
    }
    exports.hasSideEffects = hasSideEffects;
    function getDeclarationOfBindingElement(node) {
      let parent = node.parent.parent;
      while (parent.kind === ts6.SyntaxKind.BindingElement)
        parent = parent.parent.parent;
      return parent;
    }
    exports.getDeclarationOfBindingElement = getDeclarationOfBindingElement;
    function isExpressionValueUsed(node) {
      while (true) {
        const parent = node.parent;
        switch (parent.kind) {
          case ts6.SyntaxKind.CallExpression:
          case ts6.SyntaxKind.NewExpression:
          case ts6.SyntaxKind.ElementAccessExpression:
          case ts6.SyntaxKind.WhileStatement:
          case ts6.SyntaxKind.DoStatement:
          case ts6.SyntaxKind.WithStatement:
          case ts6.SyntaxKind.ThrowStatement:
          case ts6.SyntaxKind.ReturnStatement:
          case ts6.SyntaxKind.JsxExpression:
          case ts6.SyntaxKind.JsxSpreadAttribute:
          case ts6.SyntaxKind.JsxElement:
          case ts6.SyntaxKind.JsxFragment:
          case ts6.SyntaxKind.JsxSelfClosingElement:
          case ts6.SyntaxKind.ComputedPropertyName:
          case ts6.SyntaxKind.ArrowFunction:
          case ts6.SyntaxKind.ExportSpecifier:
          case ts6.SyntaxKind.ExportAssignment:
          case ts6.SyntaxKind.ImportDeclaration:
          case ts6.SyntaxKind.ExternalModuleReference:
          case ts6.SyntaxKind.Decorator:
          case ts6.SyntaxKind.TaggedTemplateExpression:
          case ts6.SyntaxKind.TemplateSpan:
          case ts6.SyntaxKind.ExpressionWithTypeArguments:
          case ts6.SyntaxKind.TypeOfExpression:
          case ts6.SyntaxKind.AwaitExpression:
          case ts6.SyntaxKind.YieldExpression:
          case ts6.SyntaxKind.LiteralType:
          case ts6.SyntaxKind.JsxAttributes:
          case ts6.SyntaxKind.JsxOpeningElement:
          case ts6.SyntaxKind.JsxClosingElement:
          case ts6.SyntaxKind.IfStatement:
          case ts6.SyntaxKind.CaseClause:
          case ts6.SyntaxKind.SwitchStatement:
            return true;
          case ts6.SyntaxKind.PropertyAccessExpression:
            return parent.expression === node;
          case ts6.SyntaxKind.QualifiedName:
            return parent.left === node;
          case ts6.SyntaxKind.ShorthandPropertyAssignment:
            return parent.objectAssignmentInitializer === node || !isInDestructuringAssignment(parent);
          case ts6.SyntaxKind.PropertyAssignment:
            return parent.initializer === node && !isInDestructuringAssignment(parent);
          case ts6.SyntaxKind.SpreadAssignment:
          case ts6.SyntaxKind.SpreadElement:
          case ts6.SyntaxKind.ArrayLiteralExpression:
            return !isInDestructuringAssignment(parent);
          case ts6.SyntaxKind.ParenthesizedExpression:
          case ts6.SyntaxKind.AsExpression:
          case ts6.SyntaxKind.TypeAssertionExpression:
          case ts6.SyntaxKind.PostfixUnaryExpression:
          case ts6.SyntaxKind.PrefixUnaryExpression:
          case ts6.SyntaxKind.NonNullExpression:
            node = parent;
            continue;
          case ts6.SyntaxKind.ForStatement:
            return parent.condition === node;
          case ts6.SyntaxKind.ForInStatement:
          case ts6.SyntaxKind.ForOfStatement:
            return parent.expression === node;
          case ts6.SyntaxKind.ConditionalExpression:
            if (parent.condition === node)
              return true;
            node = parent;
            break;
          case ts6.SyntaxKind.PropertyDeclaration:
          case ts6.SyntaxKind.BindingElement:
          case ts6.SyntaxKind.VariableDeclaration:
          case ts6.SyntaxKind.Parameter:
          case ts6.SyntaxKind.EnumMember:
            return parent.initializer === node;
          case ts6.SyntaxKind.ImportEqualsDeclaration:
            return parent.moduleReference === node;
          case ts6.SyntaxKind.CommaListExpression:
            if (parent.elements[parent.elements.length - 1] !== node)
              return false;
            node = parent;
            break;
          case ts6.SyntaxKind.BinaryExpression:
            if (parent.right === node) {
              if (parent.operatorToken.kind === ts6.SyntaxKind.CommaToken) {
                node = parent;
                break;
              }
              return true;
            }
            switch (parent.operatorToken.kind) {
              case ts6.SyntaxKind.CommaToken:
              case ts6.SyntaxKind.EqualsToken:
                return false;
              case ts6.SyntaxKind.EqualsEqualsEqualsToken:
              case ts6.SyntaxKind.EqualsEqualsToken:
              case ts6.SyntaxKind.ExclamationEqualsEqualsToken:
              case ts6.SyntaxKind.ExclamationEqualsToken:
              case ts6.SyntaxKind.InstanceOfKeyword:
              case ts6.SyntaxKind.PlusToken:
              case ts6.SyntaxKind.MinusToken:
              case ts6.SyntaxKind.AsteriskToken:
              case ts6.SyntaxKind.SlashToken:
              case ts6.SyntaxKind.PercentToken:
              case ts6.SyntaxKind.AsteriskAsteriskToken:
              case ts6.SyntaxKind.GreaterThanToken:
              case ts6.SyntaxKind.GreaterThanGreaterThanToken:
              case ts6.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
              case ts6.SyntaxKind.GreaterThanEqualsToken:
              case ts6.SyntaxKind.LessThanToken:
              case ts6.SyntaxKind.LessThanLessThanToken:
              case ts6.SyntaxKind.LessThanEqualsToken:
              case ts6.SyntaxKind.AmpersandToken:
              case ts6.SyntaxKind.BarToken:
              case ts6.SyntaxKind.CaretToken:
              case ts6.SyntaxKind.BarBarToken:
              case ts6.SyntaxKind.AmpersandAmpersandToken:
              case ts6.SyntaxKind.QuestionQuestionToken:
              case ts6.SyntaxKind.InKeyword:
              case ts6.SyntaxKind.QuestionQuestionEqualsToken:
              case ts6.SyntaxKind.AmpersandAmpersandEqualsToken:
              case ts6.SyntaxKind.BarBarEqualsToken:
                return true;
              default:
                node = parent;
            }
            break;
          default:
            return false;
        }
      }
    }
    exports.isExpressionValueUsed = isExpressionValueUsed;
    function isInDestructuringAssignment(node) {
      switch (node.kind) {
        case ts6.SyntaxKind.ShorthandPropertyAssignment:
          if (node.objectAssignmentInitializer !== void 0)
            return true;
        case ts6.SyntaxKind.PropertyAssignment:
        case ts6.SyntaxKind.SpreadAssignment:
          node = node.parent;
          break;
        case ts6.SyntaxKind.SpreadElement:
          if (node.parent.kind !== ts6.SyntaxKind.ArrayLiteralExpression)
            return false;
          node = node.parent;
      }
      while (true) {
        switch (node.parent.kind) {
          case ts6.SyntaxKind.BinaryExpression:
            return node.parent.left === node && node.parent.operatorToken.kind === ts6.SyntaxKind.EqualsToken;
          case ts6.SyntaxKind.ForOfStatement:
            return node.parent.initializer === node;
          case ts6.SyntaxKind.ArrayLiteralExpression:
          case ts6.SyntaxKind.ObjectLiteralExpression:
            node = node.parent;
            break;
          case ts6.SyntaxKind.SpreadAssignment:
          case ts6.SyntaxKind.PropertyAssignment:
            node = node.parent.parent;
            break;
          case ts6.SyntaxKind.SpreadElement:
            if (node.parent.parent.kind !== ts6.SyntaxKind.ArrayLiteralExpression)
              return false;
            node = node.parent.parent;
            break;
          default:
            return false;
        }
      }
    }
    var AccessKind;
    (function(AccessKind2) {
      AccessKind2[AccessKind2["None"] = 0] = "None";
      AccessKind2[AccessKind2["Read"] = 1] = "Read";
      AccessKind2[AccessKind2["Write"] = 2] = "Write";
      AccessKind2[AccessKind2["Delete"] = 4] = "Delete";
      AccessKind2[AccessKind2["ReadWrite"] = 3] = "ReadWrite";
      AccessKind2[AccessKind2["Modification"] = 6] = "Modification";
    })(AccessKind = exports.AccessKind || (exports.AccessKind = {}));
    function getAccessKind(node) {
      const parent = node.parent;
      switch (parent.kind) {
        case ts6.SyntaxKind.DeleteExpression:
          return 4;
        case ts6.SyntaxKind.PostfixUnaryExpression:
          return 3;
        case ts6.SyntaxKind.PrefixUnaryExpression:
          return parent.operator === ts6.SyntaxKind.PlusPlusToken || parent.operator === ts6.SyntaxKind.MinusMinusToken ? 3 : 1;
        case ts6.SyntaxKind.BinaryExpression:
          return parent.right === node ? 1 : !isAssignmentKind(parent.operatorToken.kind) ? 1 : parent.operatorToken.kind === ts6.SyntaxKind.EqualsToken ? 2 : 3;
        case ts6.SyntaxKind.ShorthandPropertyAssignment:
          return parent.objectAssignmentInitializer === node ? 1 : isInDestructuringAssignment(parent) ? 2 : 1;
        case ts6.SyntaxKind.PropertyAssignment:
          return parent.name === node ? 0 : isInDestructuringAssignment(parent) ? 2 : 1;
        case ts6.SyntaxKind.ArrayLiteralExpression:
        case ts6.SyntaxKind.SpreadElement:
        case ts6.SyntaxKind.SpreadAssignment:
          return isInDestructuringAssignment(parent) ? 2 : 1;
        case ts6.SyntaxKind.ParenthesizedExpression:
        case ts6.SyntaxKind.NonNullExpression:
        case ts6.SyntaxKind.TypeAssertionExpression:
        case ts6.SyntaxKind.AsExpression:
          return getAccessKind(parent);
        case ts6.SyntaxKind.ForOfStatement:
        case ts6.SyntaxKind.ForInStatement:
          return parent.initializer === node ? 2 : 1;
        case ts6.SyntaxKind.ExpressionWithTypeArguments:
          return parent.parent.token === ts6.SyntaxKind.ExtendsKeyword && parent.parent.parent.kind !== ts6.SyntaxKind.InterfaceDeclaration ? 1 : 0;
        case ts6.SyntaxKind.ComputedPropertyName:
        case ts6.SyntaxKind.ExpressionStatement:
        case ts6.SyntaxKind.TypeOfExpression:
        case ts6.SyntaxKind.ElementAccessExpression:
        case ts6.SyntaxKind.ForStatement:
        case ts6.SyntaxKind.IfStatement:
        case ts6.SyntaxKind.DoStatement:
        case ts6.SyntaxKind.WhileStatement:
        case ts6.SyntaxKind.SwitchStatement:
        case ts6.SyntaxKind.WithStatement:
        case ts6.SyntaxKind.ThrowStatement:
        case ts6.SyntaxKind.CallExpression:
        case ts6.SyntaxKind.NewExpression:
        case ts6.SyntaxKind.TaggedTemplateExpression:
        case ts6.SyntaxKind.JsxExpression:
        case ts6.SyntaxKind.Decorator:
        case ts6.SyntaxKind.TemplateSpan:
        case ts6.SyntaxKind.JsxOpeningElement:
        case ts6.SyntaxKind.JsxSelfClosingElement:
        case ts6.SyntaxKind.JsxSpreadAttribute:
        case ts6.SyntaxKind.VoidExpression:
        case ts6.SyntaxKind.ReturnStatement:
        case ts6.SyntaxKind.AwaitExpression:
        case ts6.SyntaxKind.YieldExpression:
        case ts6.SyntaxKind.ConditionalExpression:
        case ts6.SyntaxKind.CaseClause:
        case ts6.SyntaxKind.JsxElement:
          return 1;
        case ts6.SyntaxKind.ArrowFunction:
          return parent.body === node ? 1 : 2;
        case ts6.SyntaxKind.PropertyDeclaration:
        case ts6.SyntaxKind.VariableDeclaration:
        case ts6.SyntaxKind.Parameter:
        case ts6.SyntaxKind.EnumMember:
        case ts6.SyntaxKind.BindingElement:
        case ts6.SyntaxKind.JsxAttribute:
          return parent.initializer === node ? 1 : 0;
        case ts6.SyntaxKind.PropertyAccessExpression:
          return parent.expression === node ? 1 : 0;
        case ts6.SyntaxKind.ExportAssignment:
          return parent.isExportEquals ? 1 : 0;
      }
      return 0;
    }
    exports.getAccessKind = getAccessKind;
    function isReassignmentTarget(node) {
      return (getAccessKind(node) & 2) !== 0;
    }
    exports.isReassignmentTarget = isReassignmentTarget;
    function canHaveJsDoc(node) {
      const kind = node.kind;
      switch (kind) {
        case ts6.SyntaxKind.Parameter:
        case ts6.SyntaxKind.CallSignature:
        case ts6.SyntaxKind.ConstructSignature:
        case ts6.SyntaxKind.MethodSignature:
        case ts6.SyntaxKind.PropertySignature:
        case ts6.SyntaxKind.ArrowFunction:
        case ts6.SyntaxKind.ParenthesizedExpression:
        case ts6.SyntaxKind.SpreadAssignment:
        case ts6.SyntaxKind.ShorthandPropertyAssignment:
        case ts6.SyntaxKind.PropertyAssignment:
        case ts6.SyntaxKind.FunctionExpression:
        case ts6.SyntaxKind.LabeledStatement:
        case ts6.SyntaxKind.ExpressionStatement:
        case ts6.SyntaxKind.VariableStatement:
        case ts6.SyntaxKind.FunctionDeclaration:
        case ts6.SyntaxKind.Constructor:
        case ts6.SyntaxKind.MethodDeclaration:
        case ts6.SyntaxKind.PropertyDeclaration:
        case ts6.SyntaxKind.GetAccessor:
        case ts6.SyntaxKind.SetAccessor:
        case ts6.SyntaxKind.ClassDeclaration:
        case ts6.SyntaxKind.ClassExpression:
        case ts6.SyntaxKind.InterfaceDeclaration:
        case ts6.SyntaxKind.TypeAliasDeclaration:
        case ts6.SyntaxKind.EnumMember:
        case ts6.SyntaxKind.EnumDeclaration:
        case ts6.SyntaxKind.ModuleDeclaration:
        case ts6.SyntaxKind.ImportEqualsDeclaration:
        case ts6.SyntaxKind.ImportDeclaration:
        case ts6.SyntaxKind.NamespaceExportDeclaration:
        case ts6.SyntaxKind.ExportAssignment:
        case ts6.SyntaxKind.IndexSignature:
        case ts6.SyntaxKind.FunctionType:
        case ts6.SyntaxKind.ConstructorType:
        case ts6.SyntaxKind.JSDocFunctionType:
        case ts6.SyntaxKind.ExportDeclaration:
        case ts6.SyntaxKind.NamedTupleMember:
        case ts6.SyntaxKind.EndOfFileToken:
          return true;
        default:
          return false;
      }
    }
    exports.canHaveJsDoc = canHaveJsDoc;
    function getJsDoc(node, sourceFile) {
      const result = [];
      for (const child of node.getChildren(sourceFile)) {
        if (!node_1.isJsDoc(child))
          break;
        result.push(child);
      }
      return result;
    }
    exports.getJsDoc = getJsDoc;
    function parseJsDocOfNode(node, considerTrailingComments, sourceFile = node.getSourceFile()) {
      if (canHaveJsDoc(node) && node.kind !== ts6.SyntaxKind.EndOfFileToken) {
        const result = getJsDoc(node, sourceFile);
        if (result.length !== 0 || !considerTrailingComments)
          return result;
      }
      return parseJsDocWorker(node, node.getStart(sourceFile), sourceFile, considerTrailingComments);
    }
    exports.parseJsDocOfNode = parseJsDocOfNode;
    function parseJsDocWorker(node, nodeStart, sourceFile, considerTrailingComments) {
      const start = ts6[considerTrailingComments && isSameLine(sourceFile, node.pos, nodeStart) ? "forEachTrailingCommentRange" : "forEachLeadingCommentRange"](
        sourceFile.text,
        node.pos,
        // return object to make `0` a truthy value
        (pos, _end, kind) => kind === ts6.SyntaxKind.MultiLineCommentTrivia && sourceFile.text[pos + 2] === "*" ? { pos } : void 0
      );
      if (start === void 0)
        return [];
      const startPos = start.pos;
      const text = sourceFile.text.slice(startPos, nodeStart);
      const newSourceFile = ts6.createSourceFile("jsdoc.ts", `${text}var a;`, sourceFile.languageVersion);
      const result = getJsDoc(newSourceFile.statements[0], newSourceFile);
      for (const doc of result)
        updateNode(doc, node);
      return result;
      function updateNode(n, parent) {
        n.pos += startPos;
        n.end += startPos;
        n.parent = parent;
        return ts6.forEachChild(n, (child) => updateNode(child, n), (children) => {
          children.pos += startPos;
          children.end += startPos;
          for (const child of children)
            updateNode(child, n);
        });
      }
    }
    var ImportKind;
    (function(ImportKind2) {
      ImportKind2[ImportKind2["ImportDeclaration"] = 1] = "ImportDeclaration";
      ImportKind2[ImportKind2["ImportEquals"] = 2] = "ImportEquals";
      ImportKind2[ImportKind2["ExportFrom"] = 4] = "ExportFrom";
      ImportKind2[ImportKind2["DynamicImport"] = 8] = "DynamicImport";
      ImportKind2[ImportKind2["Require"] = 16] = "Require";
      ImportKind2[ImportKind2["ImportType"] = 32] = "ImportType";
      ImportKind2[ImportKind2["All"] = 63] = "All";
      ImportKind2[ImportKind2["AllImports"] = 59] = "AllImports";
      ImportKind2[ImportKind2["AllStaticImports"] = 3] = "AllStaticImports";
      ImportKind2[ImportKind2["AllImportExpressions"] = 24] = "AllImportExpressions";
      ImportKind2[ImportKind2["AllRequireLike"] = 18] = "AllRequireLike";
      ImportKind2[ImportKind2["AllNestedImports"] = 56] = "AllNestedImports";
      ImportKind2[ImportKind2["AllTopLevelImports"] = 7] = "AllTopLevelImports";
    })(ImportKind = exports.ImportKind || (exports.ImportKind = {}));
    function findImports(sourceFile, kinds, ignoreFileName = true) {
      const result = [];
      for (const node of findImportLikeNodes(sourceFile, kinds, ignoreFileName)) {
        switch (node.kind) {
          case ts6.SyntaxKind.ImportDeclaration:
            addIfTextualLiteral(node.moduleSpecifier);
            break;
          case ts6.SyntaxKind.ImportEqualsDeclaration:
            addIfTextualLiteral(node.moduleReference.expression);
            break;
          case ts6.SyntaxKind.ExportDeclaration:
            addIfTextualLiteral(node.moduleSpecifier);
            break;
          case ts6.SyntaxKind.CallExpression:
            addIfTextualLiteral(node.arguments[0]);
            break;
          case ts6.SyntaxKind.ImportType:
            if (node_1.isLiteralTypeNode(node.argument))
              addIfTextualLiteral(node.argument.literal);
            break;
          default:
            throw new Error("unexpected node");
        }
      }
      return result;
      function addIfTextualLiteral(node) {
        if (node_1.isTextualLiteral(node))
          result.push(node);
      }
    }
    exports.findImports = findImports;
    function findImportLikeNodes(sourceFile, kinds, ignoreFileName = true) {
      return new ImportFinder(sourceFile, kinds, ignoreFileName).find();
    }
    exports.findImportLikeNodes = findImportLikeNodes;
    var ImportFinder = class {
      constructor(_sourceFile, _options, _ignoreFileName) {
        this._sourceFile = _sourceFile;
        this._options = _options;
        this._ignoreFileName = _ignoreFileName;
        this._result = [];
      }
      find() {
        if (this._sourceFile.isDeclarationFile)
          this._options &= ~24;
        if (this._options & 7)
          this._findImports(this._sourceFile.statements);
        if (this._options & 56)
          this._findNestedImports();
        return this._result;
      }
      _findImports(statements) {
        for (const statement of statements) {
          if (node_1.isImportDeclaration(statement)) {
            if (this._options & 1)
              this._result.push(statement);
          } else if (node_1.isImportEqualsDeclaration(statement)) {
            if (this._options & 2 && statement.moduleReference.kind === ts6.SyntaxKind.ExternalModuleReference)
              this._result.push(statement);
          } else if (node_1.isExportDeclaration(statement)) {
            if (statement.moduleSpecifier !== void 0 && this._options & 4)
              this._result.push(statement);
          } else if (node_1.isModuleDeclaration(statement)) {
            this._findImportsInModule(statement);
          }
        }
      }
      _findImportsInModule(declaration) {
        if (declaration.body === void 0)
          return;
        if (declaration.body.kind === ts6.SyntaxKind.ModuleDeclaration)
          return this._findImportsInModule(declaration.body);
        this._findImports(declaration.body.statements);
      }
      _findNestedImports() {
        const isJavaScriptFile = this._ignoreFileName || (this._sourceFile.flags & ts6.NodeFlags.JavaScriptFile) !== 0;
        let re;
        let includeJsDoc;
        if ((this._options & 56) === 16) {
          if (!isJavaScriptFile)
            return;
          re = /\brequire\s*[</(]/g;
          includeJsDoc = false;
        } else if (this._options & 16 && isJavaScriptFile) {
          re = /\b(?:import|require)\s*[</(]/g;
          includeJsDoc = (this._options & 32) !== 0;
        } else {
          re = /\bimport\s*[</(]/g;
          includeJsDoc = isJavaScriptFile && (this._options & 32) !== 0;
        }
        for (let match3 = re.exec(this._sourceFile.text); match3 !== null; match3 = re.exec(this._sourceFile.text)) {
          const token = getTokenAtPositionWorker(
            this._sourceFile,
            match3.index,
            this._sourceFile,
            // only look for ImportTypeNode within JSDoc in JS files
            match3[0][0] === "i" && includeJsDoc
          );
          if (token.kind === ts6.SyntaxKind.ImportKeyword) {
            if (token.end - "import".length !== match3.index)
              continue;
            switch (token.parent.kind) {
              case ts6.SyntaxKind.ImportType:
                this._result.push(token.parent);
                break;
              case ts6.SyntaxKind.CallExpression:
                if (token.parent.arguments.length > 1)
                  this._result.push(token.parent);
            }
          } else if (token.kind === ts6.SyntaxKind.Identifier && token.end - "require".length === match3.index && token.parent.kind === ts6.SyntaxKind.CallExpression && token.parent.expression === token && token.parent.arguments.length === 1) {
            this._result.push(token.parent);
          }
        }
      }
    };
    function isStatementInAmbientContext(node) {
      while (node.flags & ts6.NodeFlags.NestedNamespace)
        node = node.parent;
      return hasModifier(node.modifiers, ts6.SyntaxKind.DeclareKeyword) || isAmbientModuleBlock(node.parent);
    }
    exports.isStatementInAmbientContext = isStatementInAmbientContext;
    function isAmbientModuleBlock(node) {
      while (node.kind === ts6.SyntaxKind.ModuleBlock) {
        do
          node = node.parent;
        while (node.flags & ts6.NodeFlags.NestedNamespace);
        if (hasModifier(node.modifiers, ts6.SyntaxKind.DeclareKeyword))
          return true;
        node = node.parent;
      }
      return false;
    }
    exports.isAmbientModuleBlock = isAmbientModuleBlock;
    function getIIFE(func) {
      let node = func.parent;
      while (node.kind === ts6.SyntaxKind.ParenthesizedExpression)
        node = node.parent;
      return node_1.isCallExpression(node) && func.end <= node.expression.end ? node : void 0;
    }
    exports.getIIFE = getIIFE;
    function isStrictCompilerOptionEnabled(options, option) {
      return (options.strict ? options[option] !== false : options[option] === true) && (option !== "strictPropertyInitialization" || isStrictCompilerOptionEnabled(options, "strictNullChecks"));
    }
    exports.isStrictCompilerOptionEnabled = isStrictCompilerOptionEnabled;
    function isCompilerOptionEnabled(options, option) {
      switch (option) {
        case "stripInternal":
        case "declarationMap":
        case "emitDeclarationOnly":
          return options[option] === true && isCompilerOptionEnabled(options, "declaration");
        case "declaration":
          return options.declaration || isCompilerOptionEnabled(options, "composite");
        case "incremental":
          return options.incremental === void 0 ? isCompilerOptionEnabled(options, "composite") : options.incremental;
        case "skipDefaultLibCheck":
          return options.skipDefaultLibCheck || isCompilerOptionEnabled(options, "skipLibCheck");
        case "suppressImplicitAnyIndexErrors":
          return options.suppressImplicitAnyIndexErrors === true && isCompilerOptionEnabled(options, "noImplicitAny");
        case "allowSyntheticDefaultImports":
          return options.allowSyntheticDefaultImports !== void 0 ? options.allowSyntheticDefaultImports : isCompilerOptionEnabled(options, "esModuleInterop") || options.module === ts6.ModuleKind.System;
        case "noUncheckedIndexedAccess":
          return options.noUncheckedIndexedAccess === true && isCompilerOptionEnabled(options, "strictNullChecks");
        case "allowJs":
          return options.allowJs === void 0 ? isCompilerOptionEnabled(options, "checkJs") : options.allowJs;
        case "noImplicitAny":
        case "noImplicitThis":
        case "strictNullChecks":
        case "strictFunctionTypes":
        case "strictPropertyInitialization":
        case "alwaysStrict":
        case "strictBindCallApply":
          return isStrictCompilerOptionEnabled(options, option);
      }
      return options[option] === true;
    }
    exports.isCompilerOptionEnabled = isCompilerOptionEnabled;
    function isAmbientModule(node) {
      return node.name.kind === ts6.SyntaxKind.StringLiteral || (node.flags & ts6.NodeFlags.GlobalAugmentation) !== 0;
    }
    exports.isAmbientModule = isAmbientModule;
    function getCheckJsDirective(source) {
      return getTsCheckDirective(source);
    }
    exports.getCheckJsDirective = getCheckJsDirective;
    function getTsCheckDirective(source) {
      let directive;
      ts6.forEachLeadingCommentRange(source, (ts6.getShebang(source) || "").length, (pos, end, kind) => {
        if (kind === ts6.SyntaxKind.SingleLineCommentTrivia) {
          const text = source.slice(pos, end);
          const match3 = /^\/{2,3}\s*@ts-(no)?check(?:\s|$)/i.exec(text);
          if (match3 !== null)
            directive = { pos, end, enabled: match3[1] === void 0 };
        }
      });
      return directive;
    }
    exports.getTsCheckDirective = getTsCheckDirective;
    function isConstAssertion(node) {
      return node_1.isTypeReferenceNode(node.type) && node.type.typeName.kind === ts6.SyntaxKind.Identifier && node.type.typeName.escapedText === "const";
    }
    exports.isConstAssertion = isConstAssertion;
    function isInConstContext(node) {
      let current = node;
      while (true) {
        const parent = current.parent;
        outer:
          switch (parent.kind) {
            case ts6.SyntaxKind.TypeAssertionExpression:
            case ts6.SyntaxKind.AsExpression:
              return isConstAssertion(parent);
            case ts6.SyntaxKind.PrefixUnaryExpression:
              if (current.kind !== ts6.SyntaxKind.NumericLiteral)
                return false;
              switch (parent.operator) {
                case ts6.SyntaxKind.PlusToken:
                case ts6.SyntaxKind.MinusToken:
                  current = parent;
                  break outer;
                default:
                  return false;
              }
            case ts6.SyntaxKind.PropertyAssignment:
              if (parent.initializer !== current)
                return false;
              current = parent.parent;
              break;
            case ts6.SyntaxKind.ShorthandPropertyAssignment:
              current = parent.parent;
              break;
            case ts6.SyntaxKind.ParenthesizedExpression:
            case ts6.SyntaxKind.ArrayLiteralExpression:
            case ts6.SyntaxKind.ObjectLiteralExpression:
            case ts6.SyntaxKind.TemplateExpression:
              current = parent;
              break;
            default:
              return false;
          }
      }
    }
    exports.isInConstContext = isInConstContext;
    function isReadonlyAssignmentDeclaration(node, checker) {
      if (!isBindableObjectDefinePropertyCall(node))
        return false;
      const descriptorType = checker.getTypeAtLocation(node.arguments[2]);
      if (descriptorType.getProperty("value") === void 0)
        return descriptorType.getProperty("set") === void 0;
      const writableProp = descriptorType.getProperty("writable");
      if (writableProp === void 0)
        return false;
      const writableType = writableProp.valueDeclaration !== void 0 && node_1.isPropertyAssignment(writableProp.valueDeclaration) ? checker.getTypeAtLocation(writableProp.valueDeclaration.initializer) : checker.getTypeOfSymbolAtLocation(writableProp, node.arguments[2]);
      return type_1.isBooleanLiteralType(writableType, false);
    }
    exports.isReadonlyAssignmentDeclaration = isReadonlyAssignmentDeclaration;
    function isBindableObjectDefinePropertyCall(node) {
      return node.arguments.length === 3 && node_1.isEntityNameExpression(node.arguments[0]) && node_1.isNumericOrStringLikeLiteral(node.arguments[1]) && node_1.isPropertyAccessExpression(node.expression) && node.expression.name.escapedText === "defineProperty" && node_1.isIdentifier(node.expression.expression) && node.expression.expression.escapedText === "Object";
    }
    exports.isBindableObjectDefinePropertyCall = isBindableObjectDefinePropertyCall;
    function isWellKnownSymbolLiterally(node) {
      return ts6.isPropertyAccessExpression(node) && ts6.isIdentifier(node.expression) && node.expression.escapedText === "Symbol";
    }
    exports.isWellKnownSymbolLiterally = isWellKnownSymbolLiterally;
    function getPropertyNameOfWellKnownSymbol(node) {
      return {
        displayName: `[Symbol.${node.name.text}]`,
        symbolName: "__@" + node.name.text
      };
    }
    exports.getPropertyNameOfWellKnownSymbol = getPropertyNameOfWellKnownSymbol;
    var isTsBefore43 = (([major, minor]) => major < "4" || major === "4" && minor < "3")(ts6.versionMajorMinor.split("."));
    function getLateBoundPropertyNames(node, checker) {
      const result = {
        known: true,
        names: []
      };
      node = unwrapParentheses(node);
      if (isTsBefore43 && isWellKnownSymbolLiterally(node)) {
        result.names.push(getPropertyNameOfWellKnownSymbol(node));
      } else {
        const type = checker.getTypeAtLocation(node);
        for (const key of type_1.unionTypeParts(checker.getBaseConstraintOfType(type) || type)) {
          const propertyName = type_1.getPropertyNameFromType(key);
          if (propertyName) {
            result.names.push(propertyName);
          } else {
            result.known = false;
          }
        }
      }
      return result;
    }
    exports.getLateBoundPropertyNames = getLateBoundPropertyNames;
    function getLateBoundPropertyNamesOfPropertyName(node, checker) {
      const staticName = getPropertyName(node);
      return staticName !== void 0 ? { known: true, names: [{ displayName: staticName, symbolName: ts6.escapeLeadingUnderscores(staticName) }] } : node.kind === ts6.SyntaxKind.PrivateIdentifier ? { known: true, names: [{ displayName: node.text, symbolName: checker.getSymbolAtLocation(node).escapedName }] } : getLateBoundPropertyNames(node.expression, checker);
    }
    exports.getLateBoundPropertyNamesOfPropertyName = getLateBoundPropertyNamesOfPropertyName;
    function getSingleLateBoundPropertyNameOfPropertyName(node, checker) {
      const staticName = getPropertyName(node);
      if (staticName !== void 0)
        return { displayName: staticName, symbolName: ts6.escapeLeadingUnderscores(staticName) };
      if (node.kind === ts6.SyntaxKind.PrivateIdentifier)
        return { displayName: node.text, symbolName: checker.getSymbolAtLocation(node).escapedName };
      const { expression } = node;
      return isTsBefore43 && isWellKnownSymbolLiterally(expression) ? getPropertyNameOfWellKnownSymbol(expression) : type_1.getPropertyNameFromType(checker.getTypeAtLocation(expression));
    }
    exports.getSingleLateBoundPropertyNameOfPropertyName = getSingleLateBoundPropertyNameOfPropertyName;
    function unwrapParentheses(node) {
      while (node.kind === ts6.SyntaxKind.ParenthesizedExpression)
        node = node.expression;
      return node;
    }
    exports.unwrapParentheses = unwrapParentheses;
    function formatPseudoBigInt(v) {
      return `${v.negative ? "-" : ""}${v.base10Value}n`;
    }
    exports.formatPseudoBigInt = formatPseudoBigInt;
    function hasExhaustiveCaseClauses(node, checker) {
      const caseClauses = node.caseBlock.clauses.filter(node_1.isCaseClause);
      if (caseClauses.length === 0)
        return false;
      const typeParts = type_1.unionTypeParts(checker.getTypeAtLocation(node.expression));
      if (typeParts.length > caseClauses.length)
        return false;
      const types = new Set(typeParts.map(getPrimitiveLiteralFromType));
      if (types.has(void 0))
        return false;
      const seen = /* @__PURE__ */ new Set();
      for (const clause of caseClauses) {
        const expressionType = checker.getTypeAtLocation(clause.expression);
        if (exports.isTypeFlagSet(expressionType, ts6.TypeFlags.Never))
          continue;
        const type = getPrimitiveLiteralFromType(expressionType);
        if (types.has(type)) {
          seen.add(type);
        } else if (type !== "null" && type !== "undefined") {
          return false;
        }
      }
      return types.size === seen.size;
    }
    exports.hasExhaustiveCaseClauses = hasExhaustiveCaseClauses;
    function getPrimitiveLiteralFromType(t) {
      if (exports.isTypeFlagSet(t, ts6.TypeFlags.Null))
        return "null";
      if (exports.isTypeFlagSet(t, ts6.TypeFlags.Undefined))
        return "undefined";
      if (exports.isTypeFlagSet(t, ts6.TypeFlags.NumberLiteral))
        return `${exports.isTypeFlagSet(t, ts6.TypeFlags.EnumLiteral) ? "enum:" : ""}${t.value}`;
      if (exports.isTypeFlagSet(t, ts6.TypeFlags.StringLiteral))
        return `${exports.isTypeFlagSet(t, ts6.TypeFlags.EnumLiteral) ? "enum:" : ""}string:${t.value}`;
      if (exports.isTypeFlagSet(t, ts6.TypeFlags.BigIntLiteral))
        return formatPseudoBigInt(t.value);
      if (_3_2_1.isUniqueESSymbolType(t))
        return t.escapedName;
      if (type_1.isBooleanLiteralType(t, true))
        return "true";
      if (type_1.isBooleanLiteralType(t, false))
        return "false";
    }
    function getBaseOfClassLikeExpression(node) {
      var _a2;
      if (((_a2 = node.heritageClauses) === null || _a2 === void 0 ? void 0 : _a2[0].token) === ts6.SyntaxKind.ExtendsKeyword)
        return node.heritageClauses[0].types[0];
    }
    exports.getBaseOfClassLikeExpression = getBaseOfClassLikeExpression;
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/convert-comments.js
var require_convert_comments = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/convert-comments.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertComments = void 0;
    var util_1 = require_util();
    var ts6 = __importStar2(require("typescript"));
    var node_utils_1 = require_node_utils();
    var ts_estree_1 = require_ts_estree2();
    function convertComments(ast, code) {
      const comments = [];
      (0, util_1.forEachComment)(ast, (_, comment) => {
        const type = comment.kind === ts6.SyntaxKind.SingleLineCommentTrivia ? ts_estree_1.AST_TOKEN_TYPES.Line : ts_estree_1.AST_TOKEN_TYPES.Block;
        const range = [comment.pos, comment.end];
        const loc = (0, node_utils_1.getLocFor)(range[0], range[1], ast);
        const textStart = range[0] + 2;
        const textEnd = comment.kind === ts6.SyntaxKind.SingleLineCommentTrivia ? (
          // single line comments end at the end
          range[1] - textStart
        ) : (
          // multiline comments end 2 characters early
          range[1] - textStart - 2
        );
        comments.push({
          type,
          value: code.slice(textStart, textStart + textEnd),
          range,
          loc
        });
      }, ast);
      return comments;
    }
    exports.convertComments = convertComments;
  }
});

// node_modules/.pnpm/eslint-visitor-keys@3.4.1/node_modules/eslint-visitor-keys/dist/eslint-visitor-keys.cjs
var require_eslint_visitor_keys = __commonJS({
  "node_modules/.pnpm/eslint-visitor-keys@3.4.1/node_modules/eslint-visitor-keys/dist/eslint-visitor-keys.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var KEYS = {
      ArrayExpression: [
        "elements"
      ],
      ArrayPattern: [
        "elements"
      ],
      ArrowFunctionExpression: [
        "params",
        "body"
      ],
      AssignmentExpression: [
        "left",
        "right"
      ],
      AssignmentPattern: [
        "left",
        "right"
      ],
      AwaitExpression: [
        "argument"
      ],
      BinaryExpression: [
        "left",
        "right"
      ],
      BlockStatement: [
        "body"
      ],
      BreakStatement: [
        "label"
      ],
      CallExpression: [
        "callee",
        "arguments"
      ],
      CatchClause: [
        "param",
        "body"
      ],
      ChainExpression: [
        "expression"
      ],
      ClassBody: [
        "body"
      ],
      ClassDeclaration: [
        "id",
        "superClass",
        "body"
      ],
      ClassExpression: [
        "id",
        "superClass",
        "body"
      ],
      ConditionalExpression: [
        "test",
        "consequent",
        "alternate"
      ],
      ContinueStatement: [
        "label"
      ],
      DebuggerStatement: [],
      DoWhileStatement: [
        "body",
        "test"
      ],
      EmptyStatement: [],
      ExperimentalRestProperty: [
        "argument"
      ],
      ExperimentalSpreadProperty: [
        "argument"
      ],
      ExportAllDeclaration: [
        "exported",
        "source"
      ],
      ExportDefaultDeclaration: [
        "declaration"
      ],
      ExportNamedDeclaration: [
        "declaration",
        "specifiers",
        "source"
      ],
      ExportSpecifier: [
        "exported",
        "local"
      ],
      ExpressionStatement: [
        "expression"
      ],
      ForInStatement: [
        "left",
        "right",
        "body"
      ],
      ForOfStatement: [
        "left",
        "right",
        "body"
      ],
      ForStatement: [
        "init",
        "test",
        "update",
        "body"
      ],
      FunctionDeclaration: [
        "id",
        "params",
        "body"
      ],
      FunctionExpression: [
        "id",
        "params",
        "body"
      ],
      Identifier: [],
      IfStatement: [
        "test",
        "consequent",
        "alternate"
      ],
      ImportDeclaration: [
        "specifiers",
        "source"
      ],
      ImportDefaultSpecifier: [
        "local"
      ],
      ImportExpression: [
        "source"
      ],
      ImportNamespaceSpecifier: [
        "local"
      ],
      ImportSpecifier: [
        "imported",
        "local"
      ],
      JSXAttribute: [
        "name",
        "value"
      ],
      JSXClosingElement: [
        "name"
      ],
      JSXClosingFragment: [],
      JSXElement: [
        "openingElement",
        "children",
        "closingElement"
      ],
      JSXEmptyExpression: [],
      JSXExpressionContainer: [
        "expression"
      ],
      JSXFragment: [
        "openingFragment",
        "children",
        "closingFragment"
      ],
      JSXIdentifier: [],
      JSXMemberExpression: [
        "object",
        "property"
      ],
      JSXNamespacedName: [
        "namespace",
        "name"
      ],
      JSXOpeningElement: [
        "name",
        "attributes"
      ],
      JSXOpeningFragment: [],
      JSXSpreadAttribute: [
        "argument"
      ],
      JSXSpreadChild: [
        "expression"
      ],
      JSXText: [],
      LabeledStatement: [
        "label",
        "body"
      ],
      Literal: [],
      LogicalExpression: [
        "left",
        "right"
      ],
      MemberExpression: [
        "object",
        "property"
      ],
      MetaProperty: [
        "meta",
        "property"
      ],
      MethodDefinition: [
        "key",
        "value"
      ],
      NewExpression: [
        "callee",
        "arguments"
      ],
      ObjectExpression: [
        "properties"
      ],
      ObjectPattern: [
        "properties"
      ],
      PrivateIdentifier: [],
      Program: [
        "body"
      ],
      Property: [
        "key",
        "value"
      ],
      PropertyDefinition: [
        "key",
        "value"
      ],
      RestElement: [
        "argument"
      ],
      ReturnStatement: [
        "argument"
      ],
      SequenceExpression: [
        "expressions"
      ],
      SpreadElement: [
        "argument"
      ],
      StaticBlock: [
        "body"
      ],
      Super: [],
      SwitchCase: [
        "test",
        "consequent"
      ],
      SwitchStatement: [
        "discriminant",
        "cases"
      ],
      TaggedTemplateExpression: [
        "tag",
        "quasi"
      ],
      TemplateElement: [],
      TemplateLiteral: [
        "quasis",
        "expressions"
      ],
      ThisExpression: [],
      ThrowStatement: [
        "argument"
      ],
      TryStatement: [
        "block",
        "handler",
        "finalizer"
      ],
      UnaryExpression: [
        "argument"
      ],
      UpdateExpression: [
        "argument"
      ],
      VariableDeclaration: [
        "declarations"
      ],
      VariableDeclarator: [
        "id",
        "init"
      ],
      WhileStatement: [
        "test",
        "body"
      ],
      WithStatement: [
        "object",
        "body"
      ],
      YieldExpression: [
        "argument"
      ]
    };
    var NODE_TYPES = Object.keys(KEYS);
    for (const type of NODE_TYPES) {
      Object.freeze(KEYS[type]);
    }
    Object.freeze(KEYS);
    var KEY_BLACKLIST = /* @__PURE__ */ new Set([
      "parent",
      "leadingComments",
      "trailingComments"
    ]);
    function filterKey(key) {
      return !KEY_BLACKLIST.has(key) && key[0] !== "_";
    }
    function getKeys(node) {
      return Object.keys(node).filter(filterKey);
    }
    function unionWith(additionalKeys) {
      const retv = (
        /** @type {{
            [type: string]: ReadonlyArray<string>
        }} */
        Object.assign({}, KEYS)
      );
      for (const type of Object.keys(additionalKeys)) {
        if (Object.prototype.hasOwnProperty.call(retv, type)) {
          const keys = new Set(additionalKeys[type]);
          for (const key of retv[type]) {
            keys.add(key);
          }
          retv[type] = Object.freeze(Array.from(keys));
        } else {
          retv[type] = Object.freeze(Array.from(additionalKeys[type]));
        }
      }
      return Object.freeze(retv);
    }
    exports.KEYS = KEYS;
    exports.getKeys = getKeys;
    exports.unionWith = unionWith;
  }
});

// node_modules/.pnpm/@typescript-eslint+visitor-keys@5.59.2/node_modules/@typescript-eslint/visitor-keys/dist/get-keys.js
var require_get_keys = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+visitor-keys@5.59.2/node_modules/@typescript-eslint/visitor-keys/dist/get-keys.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getKeys = void 0;
    var eslint_visitor_keys_1 = require_eslint_visitor_keys();
    var getKeys = eslint_visitor_keys_1.getKeys;
    exports.getKeys = getKeys;
  }
});

// node_modules/.pnpm/@typescript-eslint+visitor-keys@5.59.2/node_modules/@typescript-eslint/visitor-keys/dist/visitor-keys.js
var require_visitor_keys = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+visitor-keys@5.59.2/node_modules/@typescript-eslint/visitor-keys/dist/visitor-keys.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.visitorKeys = void 0;
    var eslintVisitorKeys = __importStar2(require_eslint_visitor_keys());
    var SharedVisitorKeys = (() => {
      const FunctionType = ["typeParameters", "params", "returnType"];
      const AnonymousFunction = [...FunctionType, "body"];
      const AbstractPropertyDefinition = [
        "decorators",
        "key",
        "typeAnnotation"
      ];
      return {
        AnonymousFunction,
        Function: ["id", ...AnonymousFunction],
        FunctionType,
        ClassDeclaration: [
          "decorators",
          "id",
          "typeParameters",
          "superClass",
          "superTypeParameters",
          "implements",
          "body"
        ],
        AbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"],
        PropertyDefinition: [...AbstractPropertyDefinition, "value"],
        TypeAssertion: ["expression", "typeAnnotation"]
      };
    })();
    var additionalKeys = {
      AccessorProperty: SharedVisitorKeys.PropertyDefinition,
      ArrayPattern: ["decorators", "elements", "typeAnnotation"],
      ArrowFunctionExpression: SharedVisitorKeys.AnonymousFunction,
      AssignmentPattern: ["decorators", "left", "right", "typeAnnotation"],
      CallExpression: ["callee", "typeParameters", "arguments"],
      ClassDeclaration: SharedVisitorKeys.ClassDeclaration,
      ClassExpression: SharedVisitorKeys.ClassDeclaration,
      Decorator: ["expression"],
      ExportAllDeclaration: ["exported", "source", "assertions"],
      ExportNamedDeclaration: ["declaration", "specifiers", "source", "assertions"],
      FunctionDeclaration: SharedVisitorKeys.Function,
      FunctionExpression: SharedVisitorKeys.Function,
      Identifier: ["decorators", "typeAnnotation"],
      ImportAttribute: ["key", "value"],
      ImportDeclaration: ["specifiers", "source", "assertions"],
      ImportExpression: ["source", "attributes"],
      JSXClosingFragment: [],
      JSXOpeningElement: ["name", "typeParameters", "attributes"],
      JSXOpeningFragment: [],
      JSXSpreadChild: ["expression"],
      MethodDefinition: ["decorators", "key", "value", "typeParameters"],
      NewExpression: ["callee", "typeParameters", "arguments"],
      ObjectPattern: ["decorators", "properties", "typeAnnotation"],
      PropertyDefinition: SharedVisitorKeys.PropertyDefinition,
      RestElement: ["decorators", "argument", "typeAnnotation"],
      StaticBlock: ["body"],
      TaggedTemplateExpression: ["tag", "typeParameters", "quasi"],
      TSAbstractAccessorProperty: SharedVisitorKeys.AbstractPropertyDefinition,
      TSAbstractKeyword: [],
      TSAbstractMethodDefinition: ["key", "value"],
      TSAbstractPropertyDefinition: SharedVisitorKeys.AbstractPropertyDefinition,
      TSAnyKeyword: [],
      TSArrayType: ["elementType"],
      TSAsExpression: SharedVisitorKeys.TypeAssertion,
      TSAsyncKeyword: [],
      TSBigIntKeyword: [],
      TSBooleanKeyword: [],
      TSCallSignatureDeclaration: SharedVisitorKeys.FunctionType,
      TSClassImplements: ["expression", "typeParameters"],
      TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"],
      TSConstructorType: SharedVisitorKeys.FunctionType,
      TSConstructSignatureDeclaration: SharedVisitorKeys.FunctionType,
      TSDeclareFunction: SharedVisitorKeys.Function,
      TSDeclareKeyword: [],
      TSEmptyBodyFunctionExpression: ["id", ...SharedVisitorKeys.FunctionType],
      TSEnumDeclaration: ["id", "members"],
      TSEnumMember: ["id", "initializer"],
      TSExportAssignment: ["expression"],
      TSExportKeyword: [],
      TSExternalModuleReference: ["expression"],
      TSFunctionType: SharedVisitorKeys.FunctionType,
      TSImportEqualsDeclaration: ["id", "moduleReference"],
      TSImportType: ["parameter", "qualifier", "typeParameters"],
      TSIndexedAccessType: ["indexType", "objectType"],
      TSIndexSignature: ["parameters", "typeAnnotation"],
      TSInferType: ["typeParameter"],
      TSInstantiationExpression: ["expression", "typeParameters"],
      TSInterfaceBody: ["body"],
      TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"],
      TSInterfaceHeritage: ["expression", "typeParameters"],
      TSIntersectionType: ["types"],
      TSIntrinsicKeyword: [],
      TSLiteralType: ["literal"],
      TSMappedType: ["nameType", "typeParameter", "typeAnnotation"],
      TSMethodSignature: ["typeParameters", "key", "params", "returnType"],
      TSModuleBlock: ["body"],
      TSModuleDeclaration: ["id", "body"],
      TSNamedTupleMember: ["label", "elementType"],
      TSNamespaceExportDeclaration: ["id"],
      TSNeverKeyword: [],
      TSNonNullExpression: ["expression"],
      TSNullKeyword: [],
      TSNumberKeyword: [],
      TSObjectKeyword: [],
      TSOptionalType: ["typeAnnotation"],
      TSParameterProperty: ["decorators", "parameter"],
      TSPrivateKeyword: [],
      TSPropertySignature: ["typeAnnotation", "key", "initializer"],
      TSProtectedKeyword: [],
      TSPublicKeyword: [],
      TSQualifiedName: ["left", "right"],
      TSReadonlyKeyword: [],
      TSRestType: ["typeAnnotation"],
      TSSatisfiesExpression: [
        // this is intentionally different to SharedVisitorKeys.TypeAssertion because
        // the type annotation comes first in the source code
        "typeAnnotation",
        "expression"
      ],
      TSStaticKeyword: [],
      TSStringKeyword: [],
      TSSymbolKeyword: [],
      TSTemplateLiteralType: ["quasis", "types"],
      TSThisType: [],
      TSTupleType: ["elementTypes"],
      TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"],
      TSTypeAnnotation: ["typeAnnotation"],
      TSTypeAssertion: SharedVisitorKeys.TypeAssertion,
      TSTypeLiteral: ["members"],
      TSTypeOperator: ["typeAnnotation"],
      TSTypeParameter: ["name", "constraint", "default"],
      TSTypeParameterDeclaration: ["params"],
      TSTypeParameterInstantiation: ["params"],
      TSTypePredicate: ["typeAnnotation", "parameterName"],
      TSTypeQuery: ["exprName", "typeParameters"],
      TSTypeReference: ["typeName", "typeParameters"],
      TSUndefinedKeyword: [],
      TSUnionType: ["types"],
      TSUnknownKeyword: [],
      TSVoidKeyword: []
    };
    var visitorKeys = eslintVisitorKeys.unionWith(additionalKeys);
    exports.visitorKeys = visitorKeys;
  }
});

// node_modules/.pnpm/@typescript-eslint+visitor-keys@5.59.2/node_modules/@typescript-eslint/visitor-keys/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+visitor-keys@5.59.2/node_modules/@typescript-eslint/visitor-keys/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.visitorKeys = exports.getKeys = void 0;
    var get_keys_1 = require_get_keys();
    Object.defineProperty(exports, "getKeys", { enumerable: true, get: function() {
      return get_keys_1.getKeys;
    } });
    var visitor_keys_1 = require_visitor_keys();
    Object.defineProperty(exports, "visitorKeys", { enumerable: true, get: function() {
      return visitor_keys_1.visitorKeys;
    } });
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/simple-traverse.js
var require_simple_traverse = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/simple-traverse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.simpleTraverse = void 0;
    var visitor_keys_1 = require_dist2();
    function isValidNode(x) {
      return x != null && typeof x === "object" && typeof x.type === "string";
    }
    function getVisitorKeysForNode(allVisitorKeys, node) {
      const keys = allVisitorKeys[node.type];
      return keys !== null && keys !== void 0 ? keys : [];
    }
    var SimpleTraverser = class {
      constructor(selectors, setParentPointers = false) {
        this.allVisitorKeys = visitor_keys_1.visitorKeys;
        this.selectors = selectors;
        this.setParentPointers = setParentPointers;
      }
      traverse(node, parent) {
        if (!isValidNode(node)) {
          return;
        }
        if (this.setParentPointers) {
          node.parent = parent;
        }
        if ("enter" in this.selectors) {
          this.selectors.enter(node, parent);
        } else if (node.type in this.selectors) {
          this.selectors[node.type](node, parent);
        }
        const keys = getVisitorKeysForNode(this.allVisitorKeys, node);
        if (keys.length < 1) {
          return;
        }
        for (const key of keys) {
          const childOrChildren = node[key];
          if (Array.isArray(childOrChildren)) {
            for (const child of childOrChildren) {
              this.traverse(child, node);
            }
          } else {
            this.traverse(childOrChildren, node);
          }
        }
      }
    };
    function simpleTraverse(startingNode, options, setParentPointers = false) {
      new SimpleTraverser(options, setParentPointers).traverse(startingNode, void 0);
    }
    exports.simpleTraverse = simpleTraverse;
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/ast-converter.js
var require_ast_converter = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/ast-converter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.astConverter = void 0;
    var convert_1 = require_convert();
    var convert_comments_1 = require_convert_comments();
    var node_utils_1 = require_node_utils();
    var simple_traverse_1 = require_simple_traverse();
    function astConverter(ast, parseSettings, shouldPreserveNodeMaps) {
      const { parseDiagnostics } = ast;
      if (parseDiagnostics.length) {
        throw (0, convert_1.convertError)(parseDiagnostics[0]);
      }
      const instance = new convert_1.Converter(ast, {
        errorOnUnknownASTType: parseSettings.errorOnUnknownASTType || false,
        shouldPreserveNodeMaps
      });
      const estree = instance.convertProgram();
      if (!parseSettings.range || !parseSettings.loc) {
        (0, simple_traverse_1.simpleTraverse)(estree, {
          enter: (node) => {
            if (!parseSettings.range) {
              delete node.range;
            }
            if (!parseSettings.loc) {
              delete node.loc;
            }
          }
        });
      }
      if (parseSettings.tokens) {
        estree.tokens = (0, node_utils_1.convertTokens)(ast);
      }
      if (parseSettings.comment) {
        estree.comments = (0, convert_comments_1.convertComments)(ast, parseSettings.code);
      }
      const astMaps = instance.getASTMaps();
      return { estree, astMaps };
    }
    exports.astConverter = astConverter;
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/create-program/shared.js
var require_shared = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/create-program/shared.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getModuleResolver = exports.getAstFromProgram = exports.getCanonicalFileName = exports.ensureAbsolutePath = exports.createHash = exports.createDefaultCompilerOptionsFromExtra = exports.canonicalDirname = exports.CORE_COMPILER_OPTIONS = void 0;
    var path_1 = __importDefault2(require("path"));
    var ts6 = __importStar2(require("typescript"));
    var CORE_COMPILER_OPTIONS = {
      noEmit: true,
      /**
       * Flags required to make no-unused-vars work
       */
      noUnusedLocals: true,
      noUnusedParameters: true
    };
    exports.CORE_COMPILER_OPTIONS = CORE_COMPILER_OPTIONS;
    var DEFAULT_COMPILER_OPTIONS = Object.assign(Object.assign({}, CORE_COMPILER_OPTIONS), { allowNonTsExtensions: true, allowJs: true, checkJs: true });
    function createDefaultCompilerOptionsFromExtra(parseSettings) {
      if (parseSettings.debugLevel.has("typescript")) {
        return Object.assign(Object.assign({}, DEFAULT_COMPILER_OPTIONS), { extendedDiagnostics: true });
      }
      return DEFAULT_COMPILER_OPTIONS;
    }
    exports.createDefaultCompilerOptionsFromExtra = createDefaultCompilerOptionsFromExtra;
    var useCaseSensitiveFileNames = ts6.sys !== void 0 ? ts6.sys.useCaseSensitiveFileNames : true;
    var correctPathCasing = useCaseSensitiveFileNames ? (filePath) => filePath : (filePath) => filePath.toLowerCase();
    function getCanonicalFileName(filePath) {
      let normalized = path_1.default.normalize(filePath);
      if (normalized.endsWith(path_1.default.sep)) {
        normalized = normalized.slice(0, -1);
      }
      return correctPathCasing(normalized);
    }
    exports.getCanonicalFileName = getCanonicalFileName;
    function ensureAbsolutePath(p, tsconfigRootDir) {
      return path_1.default.isAbsolute(p) ? p : path_1.default.join(tsconfigRootDir || process.cwd(), p);
    }
    exports.ensureAbsolutePath = ensureAbsolutePath;
    function canonicalDirname(p) {
      return path_1.default.dirname(p);
    }
    exports.canonicalDirname = canonicalDirname;
    var DEFINITION_EXTENSIONS = [
      ts6.Extension.Dts,
      ts6.Extension.Dcts,
      ts6.Extension.Dmts
    ];
    function getExtension(fileName) {
      var _a2;
      if (!fileName) {
        return null;
      }
      return (_a2 = DEFINITION_EXTENSIONS.find((definitionExt) => fileName.endsWith(definitionExt))) !== null && _a2 !== void 0 ? _a2 : path_1.default.extname(fileName);
    }
    function getAstFromProgram(currentProgram, parseSettings) {
      const ast = currentProgram.getSourceFile(parseSettings.filePath);
      const expectedExt = getExtension(parseSettings.filePath);
      const returnedExt = getExtension(ast === null || ast === void 0 ? void 0 : ast.fileName);
      if (expectedExt !== returnedExt) {
        return void 0;
      }
      return ast && { ast, program: currentProgram };
    }
    exports.getAstFromProgram = getAstFromProgram;
    function getModuleResolver(moduleResolverPath) {
      let moduleResolver;
      try {
        moduleResolver = require(moduleResolverPath);
      } catch (error) {
        const errorLines = [
          "Could not find the provided parserOptions.moduleResolver.",
          "Hint: use an absolute path if you are not in control over where the ESLint instance runs."
        ];
        throw new Error(errorLines.join("\n"));
      }
      return moduleResolver;
    }
    exports.getModuleResolver = getModuleResolver;
    function createHash2(content) {
      var _a2;
      if ((_a2 = ts6.sys) === null || _a2 === void 0 ? void 0 : _a2.createHash) {
        return ts6.sys.createHash(content);
      }
      return content;
    }
    exports.createHash = createHash2;
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/create-program/createDefaultProgram.js
var require_createDefaultProgram = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/create-program/createDefaultProgram.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDefaultProgram = void 0;
    var debug_1 = __importDefault2(require_src());
    var path_1 = __importDefault2(require("path"));
    var ts6 = __importStar2(require("typescript"));
    var shared_1 = require_shared();
    var log = (0, debug_1.default)("typescript-eslint:typescript-estree:createDefaultProgram");
    function createDefaultProgram(parseSettings) {
      var _a2;
      log("Getting default program for: %s", parseSettings.filePath || "unnamed file");
      if (((_a2 = parseSettings.projects) === null || _a2 === void 0 ? void 0 : _a2.length) !== 1) {
        return void 0;
      }
      const tsconfigPath = parseSettings.projects[0];
      const commandLine = ts6.getParsedCommandLineOfConfigFile(tsconfigPath, (0, shared_1.createDefaultCompilerOptionsFromExtra)(parseSettings), Object.assign(Object.assign({}, ts6.sys), { onUnRecoverableConfigFileDiagnostic: () => {
      } }));
      if (!commandLine) {
        return void 0;
      }
      const compilerHost = ts6.createCompilerHost(
        commandLine.options,
        /* setParentNodes */
        true
      );
      if (parseSettings.moduleResolver) {
        compilerHost.resolveModuleNames = (0, shared_1.getModuleResolver)(parseSettings.moduleResolver).resolveModuleNames;
      }
      const oldReadFile = compilerHost.readFile;
      compilerHost.readFile = (fileName) => path_1.default.normalize(fileName) === path_1.default.normalize(parseSettings.filePath) ? parseSettings.code : oldReadFile(fileName);
      const program = ts6.createProgram([parseSettings.filePath], commandLine.options, compilerHost);
      const ast = program.getSourceFile(parseSettings.filePath);
      return ast && { ast, program };
    }
    exports.createDefaultProgram = createDefaultProgram;
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/create-program/getScriptKind.js
var require_getScriptKind = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/create-program/getScriptKind.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLanguageVariant = exports.getScriptKind = void 0;
    var path_1 = __importDefault2(require("path"));
    var ts6 = __importStar2(require("typescript"));
    function getScriptKind(filePath, jsx) {
      const extension = path_1.default.extname(filePath).toLowerCase();
      switch (extension) {
        case ts6.Extension.Js:
        case ts6.Extension.Cjs:
        case ts6.Extension.Mjs:
          return ts6.ScriptKind.JS;
        case ts6.Extension.Jsx:
          return ts6.ScriptKind.JSX;
        case ts6.Extension.Ts:
        case ts6.Extension.Cts:
        case ts6.Extension.Mts:
          return ts6.ScriptKind.TS;
        case ts6.Extension.Tsx:
          return ts6.ScriptKind.TSX;
        case ts6.Extension.Json:
          return ts6.ScriptKind.JSON;
        default:
          return jsx ? ts6.ScriptKind.TSX : ts6.ScriptKind.TS;
      }
    }
    exports.getScriptKind = getScriptKind;
    function getLanguageVariant(scriptKind) {
      switch (scriptKind) {
        case ts6.ScriptKind.TSX:
        case ts6.ScriptKind.JSX:
        case ts6.ScriptKind.JS:
        case ts6.ScriptKind.JSON:
          return ts6.LanguageVariant.JSX;
        default:
          return ts6.LanguageVariant.Standard;
      }
    }
    exports.getLanguageVariant = getLanguageVariant;
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/create-program/createIsolatedProgram.js
var require_createIsolatedProgram = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/create-program/createIsolatedProgram.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createIsolatedProgram = void 0;
    var debug_1 = __importDefault2(require_src());
    var ts6 = __importStar2(require("typescript"));
    var getScriptKind_1 = require_getScriptKind();
    var shared_1 = require_shared();
    var log = (0, debug_1.default)("typescript-eslint:typescript-estree:createIsolatedProgram");
    function createIsolatedProgram(parseSettings) {
      log("Getting isolated program in %s mode for: %s", parseSettings.jsx ? "TSX" : "TS", parseSettings.filePath);
      const compilerHost = {
        fileExists() {
          return true;
        },
        getCanonicalFileName() {
          return parseSettings.filePath;
        },
        getCurrentDirectory() {
          return "";
        },
        getDirectories() {
          return [];
        },
        getDefaultLibFileName() {
          return "lib.d.ts";
        },
        // TODO: Support Windows CRLF
        getNewLine() {
          return "\n";
        },
        getSourceFile(filename) {
          return ts6.createSourceFile(
            filename,
            parseSettings.code,
            ts6.ScriptTarget.Latest,
            /* setParentNodes */
            true,
            (0, getScriptKind_1.getScriptKind)(parseSettings.filePath, parseSettings.jsx)
          );
        },
        readFile() {
          return void 0;
        },
        useCaseSensitiveFileNames() {
          return true;
        },
        writeFile() {
          return null;
        }
      };
      const program = ts6.createProgram([parseSettings.filePath], Object.assign({ noResolve: true, target: ts6.ScriptTarget.Latest, jsx: parseSettings.jsx ? ts6.JsxEmit.Preserve : void 0 }, (0, shared_1.createDefaultCompilerOptionsFromExtra)(parseSettings)), compilerHost);
      const ast = program.getSourceFile(parseSettings.filePath);
      if (!ast) {
        throw new Error("Expected an ast to be returned for the single-file isolated program.");
      }
      return { ast, program };
    }
    exports.createIsolatedProgram = createIsolatedProgram;
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/create-program/describeFilePath.js
var require_describeFilePath = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/create-program/describeFilePath.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.describeFilePath = void 0;
    var path_1 = __importDefault2(require("path"));
    function describeFilePath(filePath, tsconfigRootDir) {
      const relative2 = path_1.default.relative(tsconfigRootDir, filePath);
      if (relative2 && !relative2.startsWith("..") && !path_1.default.isAbsolute(relative2)) {
        return `<tsconfigRootDir>/${relative2}`;
      }
      if (/^[(\w+:)\\/~]/.test(filePath)) {
        return filePath;
      }
      if (/\.\.[/\\]\.\./.test(relative2)) {
        return filePath;
      }
      return `<tsconfigRootDir>/${relative2}`;
    }
    exports.describeFilePath = describeFilePath;
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/create-program/getWatchProgramsForProjects.js
var require_getWatchProgramsForProjects = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/create-program/getWatchProgramsForProjects.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWatchProgramsForProjects = exports.clearWatchCaches = void 0;
    var debug_1 = __importDefault2(require_src());
    var fs_1 = __importDefault2(require("fs"));
    var semver_1 = __importDefault2(require_semver2());
    var ts6 = __importStar2(require("typescript"));
    var shared_1 = require_shared();
    var log = (0, debug_1.default)("typescript-eslint:typescript-estree:createWatchProgram");
    var knownWatchProgramMap = /* @__PURE__ */ new Map();
    var fileWatchCallbackTrackingMap = /* @__PURE__ */ new Map();
    var folderWatchCallbackTrackingMap = /* @__PURE__ */ new Map();
    var programFileListCache = /* @__PURE__ */ new Map();
    var tsconfigLastModifiedTimestampCache = /* @__PURE__ */ new Map();
    var parsedFilesSeenHash = /* @__PURE__ */ new Map();
    function clearWatchCaches() {
      knownWatchProgramMap.clear();
      fileWatchCallbackTrackingMap.clear();
      folderWatchCallbackTrackingMap.clear();
      parsedFilesSeenHash.clear();
      programFileListCache.clear();
      tsconfigLastModifiedTimestampCache.clear();
    }
    exports.clearWatchCaches = clearWatchCaches;
    function saveWatchCallback(trackingMap) {
      return (fileName, callback) => {
        const normalizedFileName = (0, shared_1.getCanonicalFileName)(fileName);
        const watchers = (() => {
          let watchers2 = trackingMap.get(normalizedFileName);
          if (!watchers2) {
            watchers2 = /* @__PURE__ */ new Set();
            trackingMap.set(normalizedFileName, watchers2);
          }
          return watchers2;
        })();
        watchers.add(callback);
        return {
          close: () => {
            watchers.delete(callback);
          }
        };
      };
    }
    var currentLintOperationState = {
      code: "",
      filePath: ""
    };
    function diagnosticReporter(diagnostic) {
      throw new Error(ts6.flattenDiagnosticMessageText(diagnostic.messageText, ts6.sys.newLine));
    }
    function updateCachedFileList(tsconfigPath, program, parseSettings) {
      const fileList = parseSettings.EXPERIMENTAL_useSourceOfProjectReferenceRedirect ? new Set(program.getSourceFiles().map((sf) => (0, shared_1.getCanonicalFileName)(sf.fileName))) : new Set(program.getRootFileNames().map((f) => (0, shared_1.getCanonicalFileName)(f)));
      programFileListCache.set(tsconfigPath, fileList);
      return fileList;
    }
    function getWatchProgramsForProjects(parseSettings) {
      const filePath = (0, shared_1.getCanonicalFileName)(parseSettings.filePath);
      const results = [];
      currentLintOperationState.code = parseSettings.code;
      currentLintOperationState.filePath = filePath;
      const fileWatchCallbacks = fileWatchCallbackTrackingMap.get(filePath);
      const codeHash = (0, shared_1.createHash)(parseSettings.code);
      if (parsedFilesSeenHash.get(filePath) !== codeHash && fileWatchCallbacks && fileWatchCallbacks.size > 0) {
        fileWatchCallbacks.forEach((cb) => cb(filePath, ts6.FileWatcherEventKind.Changed));
      }
      const currentProjectsFromSettings = new Set(parseSettings.projects);
      for (const [tsconfigPath, existingWatch] of knownWatchProgramMap.entries()) {
        if (!currentProjectsFromSettings.has(tsconfigPath)) {
          continue;
        }
        let fileList = programFileListCache.get(tsconfigPath);
        let updatedProgram = null;
        if (!fileList) {
          updatedProgram = existingWatch.getProgram().getProgram();
          fileList = updateCachedFileList(tsconfigPath, updatedProgram, parseSettings);
        }
        if (fileList.has(filePath)) {
          log("Found existing program for file. %s", filePath);
          updatedProgram = updatedProgram !== null && updatedProgram !== void 0 ? updatedProgram : existingWatch.getProgram().getProgram();
          updatedProgram.getTypeChecker();
          return [updatedProgram];
        }
      }
      log("File did not belong to any existing programs, moving to create/update. %s", filePath);
      for (const tsconfigPath of parseSettings.projects) {
        const existingWatch = knownWatchProgramMap.get(tsconfigPath);
        if (existingWatch) {
          const updatedProgram = maybeInvalidateProgram(existingWatch, filePath, tsconfigPath);
          if (!updatedProgram) {
            continue;
          }
          updatedProgram.getTypeChecker();
          const fileList2 = updateCachedFileList(tsconfigPath, updatedProgram, parseSettings);
          if (fileList2.has(filePath)) {
            log("Found updated program for file. %s", filePath);
            return [updatedProgram];
          }
          results.push(updatedProgram);
          continue;
        }
        const programWatch = createWatchProgram2(tsconfigPath, parseSettings);
        knownWatchProgramMap.set(tsconfigPath, programWatch);
        const program = programWatch.getProgram().getProgram();
        program.getTypeChecker();
        const fileList = updateCachedFileList(tsconfigPath, program, parseSettings);
        if (fileList.has(filePath)) {
          log("Found program for file. %s", filePath);
          return [program];
        }
        results.push(program);
      }
      return results;
    }
    exports.getWatchProgramsForProjects = getWatchProgramsForProjects;
    var isRunningNoTimeoutFix = semver_1.default.satisfies(ts6.version, ">=3.9.0-beta", {
      includePrerelease: true
    });
    function createWatchProgram2(tsconfigPath, parseSettings) {
      log("Creating watch program for %s.", tsconfigPath);
      const watchCompilerHost = ts6.createWatchCompilerHost(
        tsconfigPath,
        (0, shared_1.createDefaultCompilerOptionsFromExtra)(parseSettings),
        ts6.sys,
        ts6.createAbstractBuilder,
        diagnosticReporter,
        /*reportWatchStatus*/
        () => {
        }
      );
      if (parseSettings.moduleResolver) {
        watchCompilerHost.resolveModuleNames = (0, shared_1.getModuleResolver)(parseSettings.moduleResolver).resolveModuleNames;
      }
      const oldReadFile = watchCompilerHost.readFile;
      watchCompilerHost.readFile = (filePathIn, encoding) => {
        const filePath = (0, shared_1.getCanonicalFileName)(filePathIn);
        const fileContent = filePath === currentLintOperationState.filePath ? currentLintOperationState.code : oldReadFile(filePath, encoding);
        if (fileContent !== void 0) {
          parsedFilesSeenHash.set(filePath, (0, shared_1.createHash)(fileContent));
        }
        return fileContent;
      };
      watchCompilerHost.onUnRecoverableConfigFileDiagnostic = diagnosticReporter;
      watchCompilerHost.afterProgramCreate = (program) => {
        const configFileDiagnostics = program.getConfigFileParsingDiagnostics().filter((diag) => diag.category === ts6.DiagnosticCategory.Error && diag.code !== 18003);
        if (configFileDiagnostics.length > 0) {
          diagnosticReporter(configFileDiagnostics[0]);
        }
      };
      watchCompilerHost.watchFile = saveWatchCallback(fileWatchCallbackTrackingMap);
      watchCompilerHost.watchDirectory = saveWatchCallback(folderWatchCallbackTrackingMap);
      const oldOnDirectoryStructureHostCreate = watchCompilerHost.onCachedDirectoryStructureHostCreate;
      watchCompilerHost.onCachedDirectoryStructureHostCreate = (host) => {
        const oldReadDirectory = host.readDirectory;
        host.readDirectory = (path6, extensions, exclude, include, depth) => oldReadDirectory(path6, !extensions ? void 0 : extensions.concat(parseSettings.extraFileExtensions), exclude, include, depth);
        oldOnDirectoryStructureHostCreate(host);
      };
      watchCompilerHost.extraFileExtensions = parseSettings.extraFileExtensions.map((extension) => ({
        extension,
        isMixedContent: true,
        scriptKind: ts6.ScriptKind.Deferred
      }));
      watchCompilerHost.trace = log;
      watchCompilerHost.useSourceOfProjectReferenceRedirect = () => parseSettings.EXPERIMENTAL_useSourceOfProjectReferenceRedirect;
      let callback;
      if (isRunningNoTimeoutFix) {
        watchCompilerHost.setTimeout = void 0;
        watchCompilerHost.clearTimeout = void 0;
      } else {
        log("Running without timeout fix");
        watchCompilerHost.setTimeout = (cb, _ms, ...args) => {
          callback = cb.bind(
            /*this*/
            void 0,
            ...args
          );
          return callback;
        };
        watchCompilerHost.clearTimeout = () => {
          callback = void 0;
        };
      }
      const watch = ts6.createWatchProgram(watchCompilerHost);
      if (!isRunningNoTimeoutFix) {
        const originalGetProgram = watch.getProgram;
        watch.getProgram = () => {
          if (callback) {
            callback();
          }
          callback = void 0;
          return originalGetProgram.call(watch);
        };
      }
      return watch;
    }
    function hasTSConfigChanged(tsconfigPath) {
      const stat = fs_1.default.statSync(tsconfigPath);
      const lastModifiedAt = stat.mtimeMs;
      const cachedLastModifiedAt = tsconfigLastModifiedTimestampCache.get(tsconfigPath);
      tsconfigLastModifiedTimestampCache.set(tsconfigPath, lastModifiedAt);
      if (cachedLastModifiedAt === void 0) {
        return false;
      }
      return Math.abs(cachedLastModifiedAt - lastModifiedAt) > Number.EPSILON;
    }
    function maybeInvalidateProgram(existingWatch, filePath, tsconfigPath) {
      let updatedProgram = existingWatch.getProgram().getProgram();
      if (process.env.TSESTREE_NO_INVALIDATION === "true") {
        return updatedProgram;
      }
      if (hasTSConfigChanged(tsconfigPath)) {
        log("tsconfig has changed - triggering program update. %s", tsconfigPath);
        fileWatchCallbackTrackingMap.get(tsconfigPath).forEach((cb) => cb(tsconfigPath, ts6.FileWatcherEventKind.Changed));
        programFileListCache.delete(tsconfigPath);
      }
      let sourceFile = updatedProgram.getSourceFile(filePath);
      if (sourceFile) {
        return updatedProgram;
      }
      log("File was not found in program - triggering folder update. %s", filePath);
      const currentDir = (0, shared_1.canonicalDirname)(filePath);
      let current = null;
      let next = currentDir;
      let hasCallback = false;
      while (current !== next) {
        current = next;
        const folderWatchCallbacks = folderWatchCallbackTrackingMap.get(current);
        if (folderWatchCallbacks) {
          folderWatchCallbacks.forEach((cb) => {
            if (currentDir !== current) {
              cb(currentDir, ts6.FileWatcherEventKind.Changed);
            }
            cb(current, ts6.FileWatcherEventKind.Changed);
          });
          hasCallback = true;
        }
        next = (0, shared_1.canonicalDirname)(current);
      }
      if (!hasCallback) {
        log("No callback found for file, not part of this program. %s", filePath);
        return null;
      }
      programFileListCache.delete(tsconfigPath);
      updatedProgram = existingWatch.getProgram().getProgram();
      sourceFile = updatedProgram.getSourceFile(filePath);
      if (sourceFile) {
        return updatedProgram;
      }
      log("File was still not found in program after directory update - checking file deletions. %s", filePath);
      const rootFilenames = updatedProgram.getRootFileNames();
      const deletedFile = rootFilenames.find((file) => !fs_1.default.existsSync(file));
      if (!deletedFile) {
        return null;
      }
      const fileWatchCallbacks = fileWatchCallbackTrackingMap.get((0, shared_1.getCanonicalFileName)(deletedFile));
      if (!fileWatchCallbacks) {
        log("Could not find watch callbacks for root file. %s", deletedFile);
        return updatedProgram;
      }
      log("Marking file as deleted. %s", deletedFile);
      fileWatchCallbacks.forEach((cb) => cb(deletedFile, ts6.FileWatcherEventKind.Deleted));
      programFileListCache.delete(tsconfigPath);
      updatedProgram = existingWatch.getProgram().getProgram();
      sourceFile = updatedProgram.getSourceFile(filePath);
      if (sourceFile) {
        return updatedProgram;
      }
      log("File was still not found in program after deletion check, assuming it is not part of this program. %s", filePath);
      return null;
    }
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/create-program/createProjectProgram.js
var require_createProjectProgram = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/create-program/createProjectProgram.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProjectProgram = void 0;
    var debug_1 = __importDefault2(require_src());
    var path_1 = __importDefault2(require("path"));
    var ts6 = __importStar2(require("typescript"));
    var node_utils_1 = require_node_utils();
    var describeFilePath_1 = require_describeFilePath();
    var getWatchProgramsForProjects_1 = require_getWatchProgramsForProjects();
    var shared_1 = require_shared();
    var log = (0, debug_1.default)("typescript-eslint:typescript-estree:createProjectProgram");
    var DEFAULT_EXTRA_FILE_EXTENSIONS = [
      ts6.Extension.Ts,
      ts6.Extension.Tsx,
      ts6.Extension.Js,
      ts6.Extension.Jsx,
      ts6.Extension.Mjs,
      ts6.Extension.Mts,
      ts6.Extension.Cjs,
      ts6.Extension.Cts
    ];
    function createProjectProgram(parseSettings) {
      log("Creating project program for: %s", parseSettings.filePath);
      const programsForProjects = (0, getWatchProgramsForProjects_1.getWatchProgramsForProjects)(parseSettings);
      const astAndProgram = (0, node_utils_1.firstDefined)(programsForProjects, (currentProgram) => (0, shared_1.getAstFromProgram)(currentProgram, parseSettings));
      if (astAndProgram || parseSettings.createDefaultProgram) {
        return astAndProgram;
      }
      const describeProjectFilePath = (projectFile) => (0, describeFilePath_1.describeFilePath)(projectFile, parseSettings.tsconfigRootDir);
      const describedFilePath = (0, describeFilePath_1.describeFilePath)(parseSettings.filePath, parseSettings.tsconfigRootDir);
      const relativeProjects = parseSettings.projects.map(describeProjectFilePath);
      const describedPrograms = relativeProjects.length === 1 ? relativeProjects[0] : `
${relativeProjects.map((project) => `- ${project}`).join("\n")}`;
      const errorLines = [
        `ESLint was configured to run on \`${describedFilePath}\` using \`parserOptions.project\`: ${describedPrograms}`
      ];
      let hasMatchedAnError = false;
      const extraFileExtensions = parseSettings.extraFileExtensions || [];
      extraFileExtensions.forEach((extraExtension) => {
        if (!extraExtension.startsWith(".")) {
          errorLines.push(`Found unexpected extension \`${extraExtension}\` specified with the \`parserOptions.extraFileExtensions\` option. Did you mean \`.${extraExtension}\`?`);
        }
        if (DEFAULT_EXTRA_FILE_EXTENSIONS.includes(extraExtension)) {
          errorLines.push(`You unnecessarily included the extension \`${extraExtension}\` with the \`parserOptions.extraFileExtensions\` option. This extension is already handled by the parser by default.`);
        }
      });
      const fileExtension = path_1.default.extname(parseSettings.filePath);
      if (!DEFAULT_EXTRA_FILE_EXTENSIONS.includes(fileExtension)) {
        const nonStandardExt = `The extension for the file (\`${fileExtension}\`) is non-standard`;
        if (extraFileExtensions.length > 0) {
          if (!extraFileExtensions.includes(fileExtension)) {
            errorLines.push(`${nonStandardExt}. It should be added to your existing \`parserOptions.extraFileExtensions\`.`);
            hasMatchedAnError = true;
          }
        } else {
          errorLines.push(`${nonStandardExt}. You should add \`parserOptions.extraFileExtensions\` to your config.`);
          hasMatchedAnError = true;
        }
      }
      if (!hasMatchedAnError) {
        const [describedInclusions, describedSpecifiers] = parseSettings.projects.length === 1 ? ["that TSConfig does not", "that TSConfig"] : ["none of those TSConfigs", "one of those TSConfigs"];
        errorLines.push(`However, ${describedInclusions} include this file. Either:`, `- Change ESLint's list of included files to not include this file`, `- Change ${describedSpecifiers} to include this file`, `- Create a new TSConfig that includes this file and include it in your parserOptions.project`, `See the typescript-eslint docs for more info: https://typescript-eslint.io/linting/troubleshooting#i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file`);
      }
      throw new Error(errorLines.join("\n"));
    }
    exports.createProjectProgram = createProjectProgram;
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/create-program/createSourceFile.js
var require_createSourceFile = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/create-program/createSourceFile.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSourceFile = void 0;
    var debug_1 = __importDefault2(require_src());
    var ts6 = __importStar2(require("typescript"));
    var getScriptKind_1 = require_getScriptKind();
    var log = (0, debug_1.default)("typescript-eslint:typescript-estree:createSourceFile");
    function createSourceFile(parseSettings) {
      log("Getting AST without type information in %s mode for: %s", parseSettings.jsx ? "TSX" : "TS", parseSettings.filePath);
      return ts6.createSourceFile(
        parseSettings.filePath,
        parseSettings.code,
        ts6.ScriptTarget.Latest,
        /* setParentNodes */
        true,
        (0, getScriptKind_1.getScriptKind)(parseSettings.filePath, parseSettings.jsx)
      );
    }
    exports.createSourceFile = createSourceFile;
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/create-program/useProvidedPrograms.js
var require_useProvidedPrograms = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/create-program/useProvidedPrograms.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProgramFromConfigFile = exports.useProvidedPrograms = void 0;
    var debug_1 = __importDefault2(require_src());
    var fs5 = __importStar2(require("fs"));
    var path6 = __importStar2(require("path"));
    var ts6 = __importStar2(require("typescript"));
    var shared_1 = require_shared();
    var log = (0, debug_1.default)("typescript-eslint:typescript-estree:useProvidedProgram");
    function useProvidedPrograms(programInstances, parseSettings) {
      log("Retrieving ast for %s from provided program instance(s)", parseSettings.filePath);
      let astAndProgram;
      for (const programInstance of programInstances) {
        astAndProgram = (0, shared_1.getAstFromProgram)(programInstance, parseSettings);
        if (astAndProgram) {
          break;
        }
      }
      if (!astAndProgram) {
        const relativeFilePath = path6.relative(parseSettings.tsconfigRootDir || process.cwd(), parseSettings.filePath);
        const errorLines = [
          '"parserOptions.programs" has been provided for @typescript-eslint/parser.',
          `The file was not found in any of the provided program instance(s): ${relativeFilePath}`
        ];
        throw new Error(errorLines.join("\n"));
      }
      astAndProgram.program.getTypeChecker();
      return astAndProgram;
    }
    exports.useProvidedPrograms = useProvidedPrograms;
    function createProgramFromConfigFile(configFile, projectDirectory) {
      if (ts6.sys === void 0) {
        throw new Error("`createProgramFromConfigFile` is only supported in a Node-like environment.");
      }
      const parsed = ts6.getParsedCommandLineOfConfigFile(configFile, shared_1.CORE_COMPILER_OPTIONS, {
        onUnRecoverableConfigFileDiagnostic: (diag) => {
          throw new Error(formatDiagnostics2([diag]));
        },
        fileExists: fs5.existsSync,
        getCurrentDirectory: () => projectDirectory && path6.resolve(projectDirectory) || process.cwd(),
        readDirectory: ts6.sys.readDirectory,
        readFile: (file) => fs5.readFileSync(file, "utf-8"),
        useCaseSensitiveFileNames: ts6.sys.useCaseSensitiveFileNames
      });
      const result = parsed;
      if (result.errors.length) {
        throw new Error(formatDiagnostics2(result.errors));
      }
      const host = ts6.createCompilerHost(result.options, true);
      return ts6.createProgram(result.fileNames, result.options, host);
    }
    exports.createProgramFromConfigFile = createProgramFromConfigFile;
    function formatDiagnostics2(diagnostics) {
      return ts6.formatDiagnostics(diagnostics, {
        getCanonicalFileName: (f) => f,
        getCurrentDirectory: process.cwd,
        getNewLine: () => "\n"
      });
    }
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/ExpiringCache.js
var require_ExpiringCache = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/ExpiringCache.js"(exports) {
    "use strict";
    var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _ExpiringCache_cacheDurationSeconds;
    var _ExpiringCache_map;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExpiringCache = exports.DEFAULT_TSCONFIG_CACHE_DURATION_SECONDS = void 0;
    exports.DEFAULT_TSCONFIG_CACHE_DURATION_SECONDS = 30;
    var ZERO_HR_TIME = [0, 0];
    var ExpiringCache = class {
      constructor(cacheDurationSeconds) {
        _ExpiringCache_cacheDurationSeconds.set(this, void 0);
        _ExpiringCache_map.set(this, /* @__PURE__ */ new Map());
        __classPrivateFieldSet2(this, _ExpiringCache_cacheDurationSeconds, cacheDurationSeconds, "f");
      }
      set(key, value) {
        __classPrivateFieldGet2(this, _ExpiringCache_map, "f").set(key, {
          value,
          lastSeen: __classPrivateFieldGet2(this, _ExpiringCache_cacheDurationSeconds, "f") === "Infinity" ? (
            // no need to waste time calculating the hrtime in infinity mode as there's no expiry
            ZERO_HR_TIME
          ) : process.hrtime()
        });
        return this;
      }
      get(key) {
        const entry = __classPrivateFieldGet2(this, _ExpiringCache_map, "f").get(key);
        if ((entry === null || entry === void 0 ? void 0 : entry.value) != null) {
          if (__classPrivateFieldGet2(this, _ExpiringCache_cacheDurationSeconds, "f") === "Infinity") {
            return entry.value;
          }
          const ageSeconds = process.hrtime(entry.lastSeen)[0];
          if (ageSeconds < __classPrivateFieldGet2(this, _ExpiringCache_cacheDurationSeconds, "f")) {
            return entry.value;
          } else {
            __classPrivateFieldGet2(this, _ExpiringCache_map, "f").delete(key);
          }
        }
        return void 0;
      }
      clear() {
        __classPrivateFieldGet2(this, _ExpiringCache_map, "f").clear();
      }
    };
    exports.ExpiringCache = ExpiringCache;
    _ExpiringCache_cacheDurationSeconds = /* @__PURE__ */ new WeakMap(), _ExpiringCache_map = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/getProjectConfigFiles.js
var require_getProjectConfigFiles = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/getProjectConfigFiles.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getProjectConfigFiles = void 0;
    var debug_1 = __importDefault2(require_src());
    var fs5 = __importStar2(require("fs"));
    var path6 = __importStar2(require("path"));
    var log = (0, debug_1.default)("typescript-eslint:typescript-estree:getProjectConfigFiles");
    function getProjectConfigFiles(parseSettings, project) {
      var _a2;
      if (project !== true) {
        return project === void 0 || Array.isArray(project) ? project : [project];
      }
      log("Looking for tsconfig.json at or above file: %s", parseSettings.filePath);
      let directory = path6.dirname(parseSettings.filePath);
      const checkedDirectories = [directory];
      do {
        log("Checking tsconfig.json path: %s", directory);
        const tsconfigPath = path6.join(directory, "tsconfig.json");
        const cached = (_a2 = parseSettings.tsconfigMatchCache.get(directory)) !== null && _a2 !== void 0 ? _a2 : fs5.existsSync(tsconfigPath) && tsconfigPath;
        if (cached) {
          for (const directory2 of checkedDirectories) {
            parseSettings.tsconfigMatchCache.set(directory2, cached);
          }
          return [cached];
        }
        directory = path6.dirname(directory);
        checkedDirectories.push(directory);
      } while (directory.length > 1 && directory.length >= parseSettings.tsconfigRootDir.length);
      throw new Error(`project was set to \`true\` but couldn't find any tsconfig.json relative to '${parseSettings.filePath}' within '${parseSettings.tsconfigRootDir}'.`);
    }
    exports.getProjectConfigFiles = getProjectConfigFiles;
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/inferSingleRun.js
var require_inferSingleRun = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/inferSingleRun.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.inferSingleRun = void 0;
    var path_1 = require("path");
    function inferSingleRun(options) {
      if (
        // single-run implies type-aware linting - no projects means we can't be in single-run mode
        (options === null || options === void 0 ? void 0 : options.project) == null || // programs passed via options means the user should be managing the programs, so we shouldn't
        // be creating our own single-run programs accidentally
        (options === null || options === void 0 ? void 0 : options.programs) != null
      ) {
        return false;
      }
      if (process.env.TSESTREE_SINGLE_RUN === "false") {
        return false;
      }
      if (process.env.TSESTREE_SINGLE_RUN === "true") {
        return true;
      }
      if (options === null || options === void 0 ? void 0 : options.allowAutomaticSingleRunInference) {
        if (
          // Default to single runs for CI processes. CI=true is set by most CI providers by default.
          process.env.CI === "true" || // This will be true for invocations such as `npx eslint ...` and `./node_modules/.bin/eslint ...`
          process.argv[1].endsWith((0, path_1.normalize)("node_modules/.bin/eslint"))
        ) {
          return true;
        }
      }
      return false;
    }
    exports.inferSingleRun = inferSingleRun;
  }
});

// node_modules/.pnpm/array-union@2.1.0/node_modules/array-union/index.js
var require_array_union = __commonJS({
  "node_modules/.pnpm/array-union@2.1.0/node_modules/array-union/index.js"(exports, module2) {
    "use strict";
    module2.exports = (...arguments_) => {
      return [...new Set([].concat(...arguments_))];
    };
  }
});

// node_modules/.pnpm/merge2@1.4.1/node_modules/merge2/index.js
var require_merge2 = __commonJS({
  "node_modules/.pnpm/merge2@1.4.1/node_modules/merge2/index.js"(exports, module2) {
    "use strict";
    var Stream = require("stream");
    var PassThrough = Stream.PassThrough;
    var slice = Array.prototype.slice;
    module2.exports = merge2;
    function merge2() {
      const streamsQueue = [];
      const args = slice.call(arguments);
      let merging = false;
      let options = args[args.length - 1];
      if (options && !Array.isArray(options) && options.pipe == null) {
        args.pop();
      } else {
        options = {};
      }
      const doEnd = options.end !== false;
      const doPipeError = options.pipeError === true;
      if (options.objectMode == null) {
        options.objectMode = true;
      }
      if (options.highWaterMark == null) {
        options.highWaterMark = 64 * 1024;
      }
      const mergedStream = PassThrough(options);
      function addStream() {
        for (let i = 0, len = arguments.length; i < len; i++) {
          streamsQueue.push(pauseStreams(arguments[i], options));
        }
        mergeStream();
        return this;
      }
      function mergeStream() {
        if (merging) {
          return;
        }
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        if (!Array.isArray(streams)) {
          streams = [streams];
        }
        let pipesCount = streams.length + 1;
        function next() {
          if (--pipesCount > 0) {
            return;
          }
          merging = false;
          mergeStream();
        }
        function pipe5(stream) {
          function onend() {
            stream.removeListener("merge2UnpipeEnd", onend);
            stream.removeListener("end", onend);
            if (doPipeError) {
              stream.removeListener("error", onerror);
            }
            next();
          }
          function onerror(err) {
            mergedStream.emit("error", err);
          }
          if (stream._readableState.endEmitted) {
            return next();
          }
          stream.on("merge2UnpipeEnd", onend);
          stream.on("end", onend);
          if (doPipeError) {
            stream.on("error", onerror);
          }
          stream.pipe(mergedStream, { end: false });
          stream.resume();
        }
        for (let i = 0; i < streams.length; i++) {
          pipe5(streams[i]);
        }
        next();
      }
      function endStream() {
        merging = false;
        mergedStream.emit("queueDrain");
        if (doEnd) {
          mergedStream.end();
        }
      }
      mergedStream.setMaxListeners(0);
      mergedStream.add = addStream;
      mergedStream.on("unpipe", function(stream) {
        stream.emit("merge2UnpipeEnd");
      });
      if (args.length) {
        addStream.apply(null, args);
      }
      return mergedStream;
    }
    function pauseStreams(streams, options) {
      if (!Array.isArray(streams)) {
        if (!streams._readableState && streams.pipe) {
          streams = streams.pipe(PassThrough(options));
        }
        if (!streams._readableState || !streams.pause || !streams.pipe) {
          throw new Error("Only readable stream can be merged.");
        }
        streams.pause();
      } else {
        for (let i = 0, len = streams.length; i < len; i++) {
          streams[i] = pauseStreams(streams[i], options);
        }
      }
      return streams;
    }
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/array.js
var require_array = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.splitWhen = exports.flatten = void 0;
    function flatten(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    exports.flatten = flatten;
    function splitWhen(items, predicate) {
      const result = [[]];
      let groupIndex = 0;
      for (const item of items) {
        if (predicate(item)) {
          groupIndex++;
          result[groupIndex] = [];
        } else {
          result[groupIndex].push(item);
        }
      }
      return result;
    }
    exports.splitWhen = splitWhen;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/errno.js
var require_errno = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/errno.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEnoentCodeError = void 0;
    function isEnoentCodeError(error) {
      return error.code === "ENOENT";
    }
    exports.isEnoentCodeError = isEnoentCodeError;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/fs.js
var require_fs = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports.createDirentFromStats = createDirentFromStats;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/path.js
var require_path = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeLeadingDotSegment = exports.escape = exports.makeAbsolute = exports.unixify = void 0;
    var path6 = require("path");
    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    var UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports.unixify = unixify;
    function makeAbsolute(cwd, filepath) {
      return path6.resolve(cwd, filepath);
    }
    exports.makeAbsolute = makeAbsolute;
    function escape2(pattern) {
      return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports.escape = escape2;
    function removeLeadingDotSegment(entry) {
      if (entry.charAt(0) === ".") {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\") {
          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
      }
      return entry;
    }
    exports.removeLeadingDotSegment = removeLeadingDotSegment;
  }
});

// node_modules/.pnpm/is-extglob@2.1.1/node_modules/is-extglob/index.js
var require_is_extglob = __commonJS({
  "node_modules/.pnpm/is-extglob@2.1.1/node_modules/is-extglob/index.js"(exports, module2) {
    module2.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match3;
      while (match3 = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match3[2])
          return true;
        str = str.slice(match3.index + match3[0].length);
      }
      return false;
    };
  }
});

// node_modules/.pnpm/is-glob@4.0.3/node_modules/is-glob/index.js
var require_is_glob = __commonJS({
  "node_modules/.pnpm/is-glob@4.0.3/node_modules/is-glob/index.js"(exports, module2) {
    var isExtglob = require_is_extglob();
    var chars = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index < str.length) {
        if (str[index] === "*") {
          return true;
        }
        if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
          if (closeSquareIndex < index) {
            closeSquareIndex = str.indexOf("]", index);
          }
          if (closeSquareIndex > index) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index);
          if (closeCurlyIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index);
          if (closeParenIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
          if (pipeIndex < index) {
            pipeIndex = str.indexOf("|", index);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      while (index < str.length) {
        if (/[*?{}()[\]]/.test(str[index])) {
          return true;
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    module2.exports = function isGlob2(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check = strictCheck;
      if (options && options.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
  }
});

// node_modules/.pnpm/glob-parent@5.1.2/node_modules/glob-parent/index.js
var require_glob_parent = __commonJS({
  "node_modules/.pnpm/glob-parent@5.1.2/node_modules/glob-parent/index.js"(exports, module2) {
    "use strict";
    var isGlob2 = require_is_glob();
    var pathPosixDirname = require("path").posix.dirname;
    var isWin32 = require("os").platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function globParent(str, opts) {
      var options = Object.assign({ flipBackslashes: true }, opts);
      if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        str = str.replace(backslash, slash);
      }
      if (enclosure.test(str)) {
        str += slash;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob2(str) || globby.test(str));
      return str.replace(escaped, "$1");
    };
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/utils.js"(exports) {
    "use strict";
    exports.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports.isInteger(min) || !exports.isInteger(max))
        return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports.escapeNode = (block, n = 0, type) => {
      let node = block.nodes[n];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          let ele = arr[i];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/stringify.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = (ast, options = {}) => {
      let stringify = (node, parent = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});

// node_modules/.pnpm/is-number@7.0.0/node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/.pnpm/is-number@7.0.0/node_modules/is-number/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js"(exports, module2) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min, max);
      let b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = { min, max, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = /* @__PURE__ */ new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start = min;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max2 = ranges[i];
        let obj = rangeToPattern(String(start), String(max2), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  }
});

// node_modules/.pnpm/fill-range@7.0.1/node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/.pnpm/fill-range@7.0.1/node_modules/fill-range/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index] === "0")
        ;
      return index > 0;
    };
    var stringify = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad2 = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify(start, end, options) === false;
      let format = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad2(format(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options) : toRegex(range, null, { wrap: false, ...options });
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min = Math.min(a, b);
      let max = Math.max(a, b);
      if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, { transform: step });
      }
      if (isObject(step)) {
        return fill(start, end, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step))
          return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill;
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/compile.js"(exports, module2) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils();
    var compile = (ast, options = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          let range = fill(...args, { ...options, wrap: false, toRegex: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/expand.js"(exports, module2) {
    "use strict";
    var fill = require_fill_range();
    var stringify = require_stringify();
    var utils = require_utils();
    var append = (queue = "", stash = "", enclose = false) => {
      let result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      let walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify(node, options);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module2.exports = expand;
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/parse.js"(exports, module2) {
    "use strict";
    var stringify = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants2();
    var parse2 = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      let memo = {};
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let closed = true;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module2.exports = parse2;
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/index.js"(exports, module2) {
    "use strict";
    var stringify = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse2 = require_parse2();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse2(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options), options);
      }
      return stringify(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js
var require_constants3 = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js"(exports, module2) {
    "use strict";
    var path6 = require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path6.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    var path6 = require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants3();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match3) => {
        return match3 === "\\" ? "" : match3;
      });
    };
    exports.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path6.sep === "\\";
    };
    exports.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js"(exports, module2) {
    "use strict";
    var utils = require_utils2();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants3();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob2 = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob2 = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob2 = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob2 = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob2 = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob2 = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob2 = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob2 = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob2 = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob2 === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob2 = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob2 === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob2 === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob: isGlob2,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js
var require_parse3 = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js"(exports, module2) {
    "use strict";
    var constants = require_constants3();
    var utils = require_utils2();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse2 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse2(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match3 = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match3 && match3[0].length > 2) {
            slashes = match3[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match3 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match3) {
            value += match3[0];
            state.index += match3[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse2.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match3 = /^(.*?)\.(\w+)$/.exec(str);
            if (!match3)
              return;
            const source2 = create(match3[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match3[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse2;
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js"(exports, module2) {
    "use strict";
    var path6 = require("path");
    var scan = require_scan();
    var parse2 = require_parse3();
    var utils = require_utils2();
    var constants = require_constants3();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match: match3, output } = picomatch.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match: match3, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match3 = input === glob;
      let output = match3 && format ? format(input) : input;
      if (match3 === false) {
        output = format ? format(input) : input;
        match3 = output === glob;
      }
      if (match3 === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match3 = picomatch.matchBase(input, regex, options, posix);
        } else {
          match3 = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match3), match: match3, output };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path6.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse2(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse2.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse2(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// node_modules/.pnpm/micromatch@4.0.5/node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "node_modules/.pnpm/micromatch@4.0.5/node_modules/micromatch/index.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils2();
    var isEmptyString = (val) => val === "" || val === "./";
    var micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match3 = negated ? !matched.isMatch : matched.isMatch;
          if (!match3)
            continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult)
          options.onResult(state);
        items.push(state.output);
      };
      let matches = new Set(micromatch(list, patterns, { ...options, onResult }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch.contains(str, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str, pattern, { ...options, contains: true });
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys)
        res[key] = obj[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options)(str));
    };
    micromatch.capture = (glob, input, options) => {
      let posix = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
      let match3 = regex.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match3) {
        return match3.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      return micromatch.braces(pattern, { ...options, expand: true });
    };
    module2.exports = micromatch;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/pattern.js
var require_pattern = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;
    var path6 = require("path");
    var globParent = require_glob_parent();
    var micromatch = require_micromatch();
    var GLOBSTAR = "**";
    var ESCAPE_SYMBOL = "\\";
    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
    var BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
    function isStaticPattern(pattern, options = {}) {
      return !isDynamicPattern(pattern, options);
    }
    exports.isStaticPattern = isStaticPattern;
    function isDynamicPattern(pattern, options = {}) {
      if (pattern === "") {
        return false;
      }
      if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
      }
      if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
        return true;
      }
      return false;
    }
    exports.isDynamicPattern = isDynamicPattern;
    function hasBraceExpansion(pattern) {
      const openingBraceIndex = pattern.indexOf("{");
      if (openingBraceIndex === -1) {
        return false;
      }
      const closingBraceIndex = pattern.indexOf("}", openingBraceIndex + 1);
      if (closingBraceIndex === -1) {
        return false;
      }
      const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
      return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
    }
    function convertToPositivePattern(pattern) {
      return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
    }
    exports.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
      return "!" + pattern;
    }
    exports.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern(pattern) {
      return pattern.startsWith("!") && pattern[1] !== "(";
    }
    exports.isNegativePattern = isNegativePattern;
    function isPositivePattern(pattern) {
      return !isNegativePattern(pattern);
    }
    exports.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern);
    }
    exports.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
    }
    exports.getPositivePatterns = getPositivePatterns;
    function getPatternsInsideCurrentDirectory(patterns) {
      return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
    }
    exports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    function getPatternsOutsideCurrentDirectory(patterns) {
      return patterns.filter(isPatternRelatedToParentDirectory);
    }
    exports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    function isPatternRelatedToParentDirectory(pattern) {
      return pattern.startsWith("..") || pattern.startsWith("./..");
    }
    exports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    function getBaseDirectory(pattern) {
      return globParent(pattern, { flipBackslashes: false });
    }
    exports.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
      return pattern.includes(GLOBSTAR);
    }
    exports.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith("/" + GLOBSTAR);
    }
    exports.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
      const basename = path6.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
    }
    exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
      }, []);
    }
    exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
      return micromatch.braces(pattern, {
        expand: true,
        nodupes: true
      });
    }
    exports.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options) {
      let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
      if (parts.length === 0) {
        parts = [pattern];
      }
      if (parts[0].startsWith("/")) {
        parts[0] = parts[0].slice(1);
        parts.unshift("");
      }
      return parts;
    }
    exports.getPatternParts = getPatternParts;
    function makeRe(pattern, options) {
      return micromatch.makeRe(pattern, options);
    }
    exports.makeRe = makeRe;
    function convertPatternsToRe(patterns, options) {
      return patterns.map((pattern) => makeRe(pattern, options));
    }
    exports.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry));
    }
    exports.matchAny = matchAny;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/stream.js
var require_stream = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var merge2 = require_merge2();
    function merge(streams) {
      const mergedStream = merge2(streams);
      streams.forEach((stream) => {
        stream.once("error", (error) => mergedStream.emit("error", error));
      });
      mergedStream.once("close", () => propagateCloseEventToSources(streams));
      mergedStream.once("end", () => propagateCloseEventToSources(streams));
      return mergedStream;
    }
    exports.merge = merge;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream) => stream.emit("close"));
    }
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/string.js
var require_string = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmpty = exports.isString = void 0;
    function isString(input) {
      return typeof input === "string";
    }
    exports.isString = isString;
    function isEmpty(input) {
      return input === "";
    }
    exports.isEmpty = isEmpty;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/index.js
var require_utils3 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;
    var array = require_array();
    exports.array = array;
    var errno = require_errno();
    exports.errno = errno;
    var fs5 = require_fs();
    exports.fs = fs5;
    var path6 = require_path();
    exports.path = path6;
    var pattern = require_pattern();
    exports.pattern = pattern;
    var stream = require_stream();
    exports.stream = stream;
    var string = require_string();
    exports.string = string;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/managers/tasks.js
var require_tasks = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/managers/tasks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;
    var utils = require_utils3();
    function generate(patterns, settings) {
      const positivePatterns = getPositivePatterns(patterns);
      const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
      const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
      const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
      const staticTasks = convertPatternsToTasks(
        staticPatterns,
        negativePatterns,
        /* dynamic */
        false
      );
      const dynamicTasks = convertPatternsToTasks(
        dynamicPatterns,
        negativePatterns,
        /* dynamic */
        true
      );
      return staticTasks.concat(dynamicTasks);
    }
    exports.generate = generate;
    function convertPatternsToTasks(positive, negative, dynamic) {
      const tasks = [];
      const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
      const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
      const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
      const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
      tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
      if ("." in insideCurrentDirectoryGroup) {
        tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
      } else {
        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
      }
      return tasks;
    }
    exports.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils.pattern.getPositivePatterns(patterns);
    }
    exports.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore) {
      const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
      const positive = negative.map(utils.pattern.convertToPositivePattern);
      return positive;
    }
    exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      const group = {};
      return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
          collection[base].push(pattern);
        } else {
          collection[base] = [pattern];
        }
        return collection;
      }, group);
    }
    exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
      });
    }
    exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
      };
    }
    exports.convertPatternGroupToTask = convertPatternGroupToTask;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/managers/patterns.js
var require_patterns = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/managers/patterns.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeDuplicateSlashes = exports.transform = void 0;
    var DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
    function transform(patterns) {
      return patterns.map((pattern) => removeDuplicateSlashes(pattern));
    }
    exports.transform = transform;
    function removeDuplicateSlashes(pattern) {
      return pattern.replace(DOUBLE_SLASH_RE, "/");
    }
    exports.removeDuplicateSlashes = removeDuplicateSlashes;
  }
});

// node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/providers/async.js
var require_async = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.read = void 0;
    function read(path6, settings, callback) {
      settings.fs.lstat(path6, (lstatError, lstat) => {
        if (lstatError !== null) {
          callFailureCallback(callback, lstatError);
          return;
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
          callSuccessCallback(callback, lstat);
          return;
        }
        settings.fs.stat(path6, (statError, stat) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback(callback, statError);
              return;
            }
            callSuccessCallback(callback, lstat);
            return;
          }
          if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
          }
          callSuccessCallback(callback, stat);
        });
      });
    }
    exports.read = read;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/providers/sync.js
var require_sync = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.read = void 0;
    function read(path6, settings) {
      const lstat = settings.fs.lstatSync(path6);
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
      }
      try {
        const stat = settings.fs.statSync(path6);
        if (settings.markSymbolicLink) {
          stat.isSymbolicLink = () => true;
        }
        return stat;
      } catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
          return lstat;
        }
        throw error;
      }
    }
    exports.read = read;
  }
});

// node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/adapters/fs.js
var require_fs2 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
    var fs5 = require("fs");
    exports.FILE_SYSTEM_ADAPTER = {
      lstat: fs5.lstat,
      stat: fs5.stat,
      lstatSync: fs5.lstatSync,
      statSync: fs5.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/settings.js
var require_settings = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs5 = require_fs2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs5.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports.default = Settings;
  }
});

// node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/index.js
var require_out = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.statSync = exports.stat = exports.Settings = void 0;
    var async = require_async();
    var sync = require_sync();
    var settings_1 = require_settings();
    exports.Settings = settings_1.default;
    function stat(path6, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path6, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path6, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports.stat = stat;
    function statSync(path6, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path6, settings);
    }
    exports.statSync = statSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/.pnpm/queue-microtask@1.2.3/node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "node_modules/.pnpm/queue-microtask@1.2.3/node_modules/queue-microtask/index.js"(exports, module2) {
    var promise;
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});

// node_modules/.pnpm/run-parallel@1.2.0/node_modules/run-parallel/index.js
var require_run_parallel = __commonJS({
  "node_modules/.pnpm/run-parallel@1.2.0/node_modules/run-parallel/index.js"(exports, module2) {
    module2.exports = runParallel;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel(tasks, cb) {
      let results, pending, keys;
      let isSync = true;
      if (Array.isArray(tasks)) {
        results = [];
        pending = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = keys.length;
      }
      function done(err) {
        function end() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each(i, err, result) {
        results[i] = result;
        if (--pending === 0 || err) {
          done(err);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.forEach(function(key) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
        });
      } else {
        tasks.forEach(function(task, i) {
          task(function(err, result) {
            each(i, err, result);
          });
        });
      }
      isSync = false;
    }
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/constants.js
var require_constants4 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    var SUPPORTED_MAJOR_VERSION = 10;
    var SUPPORTED_MINOR_VERSION = 10;
    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/utils/fs.js
var require_fs3 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports.createDirentFromStats = createDirentFromStats;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/utils/index.js
var require_utils4 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fs = void 0;
    var fs5 = require_fs3();
    exports.fs = fs5;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/common.js
var require_common2 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinPathSegments = void 0;
    function joinPathSegments(a, b, separator) {
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports.joinPathSegments = joinPathSegments;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/async.js
var require_async2 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
    var fsStat = require_out();
    var rpl = require_run_parallel();
    var constants_1 = require_constants4();
    var utils = require_utils4();
    var common = require_common2();
    function read(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
      }
      readdir(directory, settings, callback);
    }
    exports.read = read;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
          callSuccessCallback(callback, entries);
          return;
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
          done(null, entry);
          return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry);
            return;
          }
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          done(null, entry);
        });
      };
    }
    function readdir(directory, settings, callback) {
      settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const tasks = names.map((name) => {
          const path6 = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
          return (done) => {
            fsStat.stat(path6, settings.fsStatSettings, (error, stats) => {
              if (error !== null) {
                done(error);
                return;
              }
              const entry = {
                name,
                path: path6,
                dirent: utils.fs.createDirentFromStats(name, stats)
              };
              if (settings.stats) {
                entry.stats = stats;
              }
              done(null, entry);
            });
          };
        });
        rpl(tasks, (rplError, entries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, entries);
        });
      });
    }
    exports.readdir = readdir;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/sync.js
var require_sync2 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
    var fsStat = require_out();
    var constants_1 = require_constants4();
    var utils = require_utils4();
    var common = require_common2();
    function read(directory, settings) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
      }
      return readdir(directory, settings);
    }
    exports.read = read;
    function readdirWithFileTypes(directory, settings) {
      const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
      return dirents.map((dirent) => {
        const entry = {
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
          try {
            const stats = settings.fs.statSync(entry.path);
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          } catch (error) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              throw error;
            }
          }
        }
        return entry;
      });
    }
    exports.readdirWithFileTypes = readdirWithFileTypes;
    function readdir(directory, settings) {
      const names = settings.fs.readdirSync(directory);
      return names.map((name) => {
        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
          name,
          path: entryPath,
          dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
          entry.stats = stats;
        }
        return entry;
      });
    }
    exports.readdir = readdir;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var require_fs4 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
    var fs5 = require("fs");
    exports.FILE_SYSTEM_ADAPTER = {
      lstat: fs5.lstat,
      stat: fs5.stat,
      lstatSync: fs5.lstatSync,
      statSync: fs5.statSync,
      readdir: fs5.readdir,
      readdirSync: fs5.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/settings.js
var require_settings2 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path6 = require("path");
    var fsStat = require_out();
    var fs5 = require_fs4();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs5.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path6.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports.default = Settings;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/index.js
var require_out2 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Settings = exports.scandirSync = exports.scandir = void 0;
    var async = require_async2();
    var sync = require_sync2();
    var settings_1 = require_settings2();
    exports.Settings = settings_1.default;
    function scandir(path6, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path6, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path6, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports.scandir = scandir;
    function scandirSync(path6, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path6, settings);
    }
    exports.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/.pnpm/reusify@1.0.4/node_modules/reusify/reusify.js
var require_reusify = __commonJS({
  "node_modules/.pnpm/reusify@1.0.4/node_modules/reusify/reusify.js"(exports, module2) {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current = head;
        if (current.next) {
          head = current.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get,
        release
      };
    }
    module2.exports = reusify;
  }
});

// node_modules/.pnpm/fastq@1.15.0/node_modules/fastq/queue.js
var require_queue = __commonJS({
  "node_modules/.pnpm/fastq@1.15.0/node_modules/fastq/queue.js"(exports, module2) {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      if (concurrency < 1) {
        throw new Error("fastqueue concurrency must be greater than 1");
      }
      var cache2 = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self2 = {
        push,
        drain: noop,
        saturated: noop,
        pause,
        paused: false,
        concurrency,
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop,
        kill,
        killAndDrain,
        error
      };
      return self2;
      function running() {
        return _running;
      }
      function pause() {
        self2.paused = true;
      }
      function length() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current = queueHead;
        var tasks = [];
        while (current) {
          tasks.push(current.value);
          current = current.next;
        }
        return tasks;
      }
      function resume() {
        if (!self2.paused)
          return;
        self2.paused = false;
        for (var i = 0; i < self2.concurrency; i++) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self2.length() === 0;
      }
      function push(value, done) {
        var current = cache2.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running === self2.concurrency || self2.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function unshift(value, done) {
        var current = cache2.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        if (_running === self2.concurrency || self2.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache2.release(holder);
        }
        var next = queueHead;
        if (next) {
          if (!self2.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context, next.value, next.worked);
            if (queueTail === null) {
              self2.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self2.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self2.drain = noop;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self2.drain();
        self2.drain = noop;
      }
      function error(handler) {
        errorHandler = handler;
      }
    }
    function noop() {
    }
    function Task() {
      this.value = null;
      this.callback = noop;
      this.next = null;
      this.release = noop;
      this.context = null;
      this.errorHandler = null;
      var self2 = this;
      this.worked = function worked(err, result) {
        var callback = self2.callback;
        var errorHandler = self2.errorHandler;
        var val = self2.value;
        self2.value = null;
        self2.callback = noop;
        if (self2.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self2.context, err, result);
        self2.release(self2);
      };
    }
    function queueAsPromised(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context, asyncWrapper, concurrency);
      var pushCb = queue.push;
      var unshiftCb = queue.unshift;
      queue.push = push;
      queue.unshift = unshift;
      queue.drained = drained;
      return queue;
      function push(value) {
        var p = new Promise(function(resolve, reject) {
          pushCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function unshift(value) {
        var p = new Promise(function(resolve, reject) {
          unshiftCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function drained() {
        if (queue.idle()) {
          return new Promise(function(resolve) {
            resolve();
          });
        }
        var previousDrain = queue.drain;
        var p = new Promise(function(resolve) {
          queue.drain = function() {
            previousDrain();
            resolve();
          };
        });
        return p;
      }
    }
    module2.exports = fastqueue;
    module2.exports.promise = queueAsPromised;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/common.js
var require_common3 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = void 0;
    function isFatalError(settings, error) {
      if (settings.errorFilter === null) {
        return true;
      }
      return !settings.errorFilter(error);
    }
    exports.isFatalError = isFatalError;
    function isAppliedFilter(filter, value) {
      return filter === null || filter(value);
    }
    exports.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
      if (a === "") {
        return b;
      }
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports.joinPathSegments = joinPathSegments;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/reader.js
var require_reader = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var common = require_common3();
    var Reader = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports.default = Reader;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/async.js
var require_async3 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = require("events");
    var fsScandir = require_out2();
    var fastq = require_queue();
    var common = require_common3();
    var reader_1 = require_reader();
    var AsyncReader = class extends reader_1.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error) => {
          if (error !== null) {
            this._handleError(error);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
          if (error !== null) {
            done(error, void 0);
            return;
          }
          for (const entry of entries) {
            this._handleEntry(entry, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error) {
        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error);
      }
      _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _emitEntry(entry) {
        this._emitter.emit("entry", entry);
      }
    };
    exports.default = AsyncReader;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/async.js
var require_async4 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var async_1 = require_async3();
    var AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error) => {
          callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
          this._storage.push(entry);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
      }
    };
    exports.default = AsyncProvider;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/stream.js
var require_stream2 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = require("stream");
    var async_1 = require_async3();
    var StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error) => {
          this._stream.emit("error", error);
        });
        this._reader.onEntry((entry) => {
          this._stream.push(entry);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    exports.default = StreamProvider;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/sync.js
var require_sync3 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsScandir = require_out2();
    var common = require_common3();
    var reader_1 = require_reader();
    var SyncReader = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = [];
        this._queue = /* @__PURE__ */ new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry of entries) {
            this._handleEntry(entry, base);
          }
        } catch (error) {
          this._handleError(error);
        }
      }
      _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
          return;
        }
        throw error;
      }
      _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _pushToStorage(entry) {
        this._storage.push(entry);
      }
    };
    exports.default = SyncReader;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/sync.js
var require_sync4 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sync_1 = require_sync3();
    var SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports.default = SyncProvider;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/settings.js
var require_settings3 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path6 = require("path");
    var fsScandir = require_out2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path6.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports.default = Settings;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/index.js
var require_out3 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Settings = exports.walkStream = exports.walkSync = exports.walk = void 0;
    var async_1 = require_async4();
    var stream_1 = require_stream2();
    var sync_1 = require_sync4();
    var settings_1 = require_settings3();
    exports.Settings = settings_1.default;
    function walk(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports.walk = walk;
    function walkSync(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new sync_1.default(directory, settings);
      return provider.read();
    }
    exports.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new stream_1.default(directory, settings);
      return provider.read();
    }
    exports.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/reader.js
var require_reader2 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path6 = require("path");
    var fsStat = require_out();
    var utils = require_utils3();
    var Reader = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path6.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern) {
        const entry = {
          name: pattern,
          path: pattern,
          dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
          entry.stats = stats;
        }
        return entry;
      }
      _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
      }
    };
    exports.default = Reader;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/stream.js
var require_stream3 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = require("stream");
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderStream = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
      }
      dynamic(root, options) {
        return this._walkStream(root, options);
      }
      static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({ objectMode: true });
        stream._write = (index, _enc, done) => {
          return this._getEntry(filepaths[index], patterns[index], options).then((entry) => {
            if (entry !== null && options.entryFilter(entry)) {
              stream.push(entry);
            }
            if (index === filepaths.length - 1) {
              stream.end();
            }
            done();
          }).catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
          stream.write(i);
        }
        return stream;
      }
      _getEntry(filepath, pattern, options) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve, reject) => {
          this._stat(filepath, this._fsStatSettings, (error, stats) => {
            return error === null ? resolve(stats) : reject(error);
          });
        });
      }
    };
    exports.default = ReaderStream;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/async.js
var require_async5 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var stream_1 = require_stream3();
    var ReaderAsync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkAsync = fsWalk.walk;
        this._readerStream = new stream_1.default(this._settings);
      }
      dynamic(root, options) {
        return new Promise((resolve, reject) => {
          this._walkAsync(root, options, (error, entries) => {
            if (error === null) {
              resolve(entries);
            } else {
              reject(error);
            }
          });
        });
      }
      async static(patterns, options) {
        const entries = [];
        const stream = this._readerStream.static(patterns, options);
        return new Promise((resolve, reject) => {
          stream.once("error", reject);
          stream.on("data", (entry) => entries.push(entry));
          stream.once("end", () => resolve(entries));
        });
      }
    };
    exports.default = ReaderAsync;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/matchers/matcher.js
var require_matcher = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/matchers/matcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils3();
    var Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern of patterns) {
          const segments = this._getPatternSegments(pattern);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
      }
    };
    exports.default = Matcher;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/matchers/partial.js
var require_partial = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/matchers/partial.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var matcher_1 = require_matcher();
    var PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
          const section = pattern.sections[0];
          if (!pattern.complete && levels > section.length) {
            return true;
          }
          const match3 = parts.every((part, index) => {
            const segment = pattern.segments[index];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match3) {
            return true;
          }
        }
        return false;
      }
    };
    exports.default = PartialMatcher;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/filters/deep.js
var require_deep = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/filters/deep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils3();
    var partial_1 = require_partial();
    var DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
          return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
      }
    };
    exports.default = DeepFilter;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/filters/entry.js
var require_entry = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/filters/entry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils3();
    var EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = /* @__PURE__ */ new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry) => this._filter(entry, positiveRe, negativeRe);
      }
      _filter(entry, positiveRe, negativeRe) {
        if (this._settings.unique && this._isDuplicateEntry(entry)) {
          return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
          return false;
        }
        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
        const isDirectory = entry.dirent.isDirectory();
        const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(entry.path, negativeRe, isDirectory);
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(entry);
        }
        return isMatched;
      }
      _isDuplicateEntry(entry) {
        return this.index.has(entry.path);
      }
      _createIndexRecord(entry) {
        this.index.set(entry.path, void 0);
      }
      _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
      }
      _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(entryPath, patternsRe, isDirectory) {
        const filepath = utils.path.removeLeadingDotSegment(entryPath);
        const isMatched = utils.pattern.matchAny(filepath, patternsRe);
        if (!isMatched && isDirectory) {
          return utils.pattern.matchAny(filepath + "/", patternsRe);
        }
        return isMatched;
      }
    };
    exports.default = EntryFilter;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/filters/error.js
var require_error = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/filters/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils3();
    var ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error) => this._isNonFatalError(error);
      }
      _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
      }
    };
    exports.default = ErrorFilter;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/transformers/entry.js
var require_entry2 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/transformers/entry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils3();
    var EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry) => this._transform(entry);
      }
      _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
          filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
      }
    };
    exports.default = EntryTransformer;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/provider.js
var require_provider = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path6 = require("path");
    var deep_1 = require_deep();
    var entry_1 = require_entry();
    var error_1 = require_error();
    var entry_2 = require_entry2();
    var Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path6.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    exports.default = Provider;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/async.js
var require_async6 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var async_1 = require_async5();
    var provider_1 = require_provider();
    var ProviderAsync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new async_1.default(this._settings);
      }
      async read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = await this.api(root, task, options);
        return entries.map((entry) => options.transform(entry));
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports.default = ProviderAsync;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/stream.js
var require_stream4 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = require("stream");
    var stream_2 = require_stream3();
    var provider_1 = require_provider();
    var ProviderStream = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({ objectMode: true, read: () => {
        } });
        source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
        destination.once("close", () => source.destroy());
        return destination;
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports.default = ProviderStream;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/sync.js
var require_sync5 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root, options) {
        return this._walkSync(root, options);
      }
      static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
          const filepath = this._getFullEntryPath(pattern);
          const entry = this._getEntry(filepath, pattern, options);
          if (entry === null || !options.entryFilter(entry)) {
            continue;
          }
          entries.push(entry);
        }
        return entries;
      }
      _getEntry(filepath, pattern, options) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern);
        } catch (error) {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    exports.default = ReaderSync;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/sync.js
var require_sync6 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sync_1 = require_sync5();
    var provider_1 = require_provider();
    var ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports.default = ProviderSync;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/settings.js
var require_settings4 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    var fs5 = require("fs");
    var os = require("os");
    var CPU_COUNT = Math.max(os.cpus().length, 1);
    exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs5.lstat,
      lstatSync: fs5.lstatSync,
      stat: fs5.stat,
      statSync: fs5.statSync,
      readdir: fs5.readdir,
      readdirSync: fs5.readdirSync
    };
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
          this.onlyFiles = false;
        }
        if (this.stats) {
          this.objectMode = true;
        }
      }
      _getValue(option, value) {
        return option === void 0 ? value : option;
      }
      _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
      }
    };
    exports.default = Settings;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/index.js
var require_out4 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/index.js"(exports, module2) {
    "use strict";
    var taskManager = require_tasks();
    var patternManager = require_patterns();
    var async_1 = require_async6();
    var stream_1 = require_stream4();
    var sync_1 = require_sync6();
    var settings_1 = require_settings4();
    var utils = require_utils3();
    async function FastGlob(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, async_1.default, options);
      const result = await Promise.all(works);
      return utils.array.flatten(result);
    }
    (function(FastGlob2) {
      function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync;
      function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream;
      function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = patternManager.transform([].concat(source));
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern;
      function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
    })(FastGlob || (FastGlob = {}));
    function getWorks(source, _Provider, options) {
      const patterns = patternManager.transform([].concat(source));
      const settings = new settings_1.default(options);
      const tasks = taskManager.generate(patterns, settings);
      const provider = new _Provider(settings);
      return tasks.map(provider.read, provider);
    }
    function assertPatternsInput(input) {
      const source = [].concat(input);
      const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
      if (!isValidSource) {
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
      }
    }
    module2.exports = FastGlob;
  }
});

// node_modules/.pnpm/path-type@4.0.0/node_modules/path-type/index.js
var require_path_type = __commonJS({
  "node_modules/.pnpm/path-type@4.0.0/node_modules/path-type/index.js"(exports) {
    "use strict";
    var { promisify } = require("util");
    var fs5 = require("fs");
    async function isType(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        const stats = await promisify(fs5[fsStatType])(filePath);
        return stats[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        }
        throw error;
      }
    }
    function isTypeSync(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        return fs5[fsStatType](filePath)[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        }
        throw error;
      }
    }
    exports.isFile = isType.bind(null, "stat", "isFile");
    exports.isDirectory = isType.bind(null, "stat", "isDirectory");
    exports.isSymlink = isType.bind(null, "lstat", "isSymbolicLink");
    exports.isFileSync = isTypeSync.bind(null, "statSync", "isFile");
    exports.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory");
    exports.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink");
  }
});

// node_modules/.pnpm/dir-glob@3.0.1/node_modules/dir-glob/index.js
var require_dir_glob = __commonJS({
  "node_modules/.pnpm/dir-glob@3.0.1/node_modules/dir-glob/index.js"(exports, module2) {
    "use strict";
    var path6 = require("path");
    var pathType = require_path_type();
    var getExtensions = (extensions) => extensions.length > 1 ? `{${extensions.join(",")}}` : extensions[0];
    var getPath = (filepath, cwd) => {
      const pth = filepath[0] === "!" ? filepath.slice(1) : filepath;
      return path6.isAbsolute(pth) ? pth : path6.join(cwd, pth);
    };
    var addExtensions = (file, extensions) => {
      if (path6.extname(file)) {
        return `**/${file}`;
      }
      return `**/${file}.${getExtensions(extensions)}`;
    };
    var getGlob = (directory, options) => {
      if (options.files && !Array.isArray(options.files)) {
        throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options.files}\``);
      }
      if (options.extensions && !Array.isArray(options.extensions)) {
        throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options.extensions}\``);
      }
      if (options.files && options.extensions) {
        return options.files.map((x) => path6.posix.join(directory, addExtensions(x, options.extensions)));
      }
      if (options.files) {
        return options.files.map((x) => path6.posix.join(directory, `**/${x}`));
      }
      if (options.extensions) {
        return [path6.posix.join(directory, `**/*.${getExtensions(options.extensions)}`)];
      }
      return [path6.posix.join(directory, "**")];
    };
    module2.exports = async (input, options) => {
      options = {
        cwd: process.cwd(),
        ...options
      };
      if (typeof options.cwd !== "string") {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
      }
      const globs = await Promise.all([].concat(input).map(async (x) => {
        const isDirectory = await pathType.isDirectory(getPath(x, options.cwd));
        return isDirectory ? getGlob(x, options) : x;
      }));
      return [].concat.apply([], globs);
    };
    module2.exports.sync = (input, options) => {
      options = {
        cwd: process.cwd(),
        ...options
      };
      if (typeof options.cwd !== "string") {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
      }
      const globs = [].concat(input).map((x) => pathType.isDirectorySync(getPath(x, options.cwd)) ? getGlob(x, options) : x);
      return [].concat.apply([], globs);
    };
  }
});

// node_modules/.pnpm/ignore@5.2.4/node_modules/ignore/index.js
var require_ignore = __commonJS({
  "node_modules/.pnpm/ignore@5.2.4/node_modules/ignore/index.js"(exports, module2) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH = "/";
    var TMP_KEY_IGNORE = "node-ignore";
    if (typeof Symbol !== "undefined") {
      TMP_KEY_IGNORE = Symbol.for("node-ignore");
    }
    var KEY_IGNORE = TMP_KEY_IGNORE;
    var define = (object, key, value) => Object.defineProperty(object, key, { value });
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = () => false;
    var sanitizeRange = (range) => range.replace(
      REGEX_REGEXP_RANGE,
      (match3, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match3 : EMPTY
    );
    var cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a \ ) -> (a  )
        /\\?\s+$/,
        (match3) => match3.indexOf("\\") === 0 ? SPACE : EMPTY
      ],
      // replace (\ ) with ' '
      [
        /\\\s/g,
        () => SPACE
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|*+(){^]/g,
        (match3) => `\\${match3}`
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^"
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        () => "\\/"
      ],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        () => "^(?:.*\\/)?"
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_, p1, p2) => {
          const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        }
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match3, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match3) => /\/$/.test(match3) ? `${match3}$` : `${match3}(?=$|\\/$)`
      ],
      // trailing wildcard
      [
        /(\^|\\\/)?\\\*$/,
        (_, p1) => {
          const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
          return `${prefix}(?=$|\\/$)`;
        }
      ]
    ];
    var regexCache = /* @__PURE__ */ Object.create(null);
    var makeRegex = (pattern, ignoreCase) => {
      let source = regexCache[pattern];
      if (!source) {
        source = REPLACERS.reduce(
          (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
          pattern
        );
        regexCache[pattern] = source;
      }
      return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
    };
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0;
    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
    var IgnoreRule = class {
      constructor(origin, pattern, negative, regex) {
        this.origin = origin;
        this.pattern = pattern;
        this.negative = negative;
        this.regex = regex;
      }
    };
    var createRule2 = (pattern, ignoreCase) => {
      const origin = pattern;
      let negative = false;
      if (pattern.indexOf("!") === 0) {
        negative = true;
        pattern = pattern.substr(1);
      }
      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern, ignoreCase);
      return new IgnoreRule(
        origin,
        pattern,
        negative,
        regex
      );
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path6, originalPath, doThrow) => {
      if (!isString(path6)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path6) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path6)) {
        const r = "`path.relative()`d";
        return doThrow(
          `path should be a ${r} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    };
    var isNotRelative = (path6) => REGEX_TEST_INVALID_PATH.test(path6);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignoreCase = ignoreCase;
        this._allowRelativePaths = allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern)) {
          const rule = createRule2(pattern, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern) {
        this._added = false;
        makeArray(
          isString(pattern) ? splitPattern(pattern) : pattern
        ).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      // legacy
      addPattern(pattern) {
        return this.add(pattern);
      }
      //          |           ignored : unignored
      // negative |   0:0   |   0:1   |   1:0   |   1:1
      // -------- | ------- | ------- | ------- | --------
      //     0    |  TEST   |  TEST   |  SKIP   |    X
      //     1    |  TESTIF |  SKIP   |  TEST   |    X
      // - SKIP: always skip
      // - TEST: always test
      // - TESTIF: only test if checkUnignored
      // - X: that never happen
      // @param {boolean} whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // @returns {TestResult} true if a file is ignored
      _testOne(path6, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path6);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      // @returns {TestResult}
      _test(originalPath, cache2, checkUnignored, slices) {
        const path6 = originalPath && checkPath.convert(originalPath);
        checkPath(
          path6,
          originalPath,
          this._allowRelativePaths ? RETURN_FALSE : throwError
        );
        return this._t(path6, cache2, checkUnignored, slices);
      }
      _t(path6, cache2, checkUnignored, slices) {
        if (path6 in cache2) {
          return cache2[path6];
        }
        if (!slices) {
          slices = path6.split(SLASH);
        }
        slices.pop();
        if (!slices.length) {
          return cache2[path6] = this._testOne(path6, checkUnignored);
        }
        const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache2,
          checkUnignored,
          slices
        );
        return cache2[path6] = parent.ignored ? parent : this._testOne(path6, checkUnignored);
      }
      ignores(path6) {
        return this._test(path6, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path6) => !this.ignores(path6);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path6) {
        return this._test(path6, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var isPathValid = (path6) => checkPath(path6 && checkPath.convert(path6), path6, RETURN_FALSE);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module2.exports = factory;
    if (
      // Detect `process` so that it can run in browsers.
      typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")
    ) {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path6) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path6) || isNotRelative(path6);
    }
  }
});

// node_modules/.pnpm/slash@3.0.0/node_modules/slash/index.js
var require_slash = __commonJS({
  "node_modules/.pnpm/slash@3.0.0/node_modules/slash/index.js"(exports, module2) {
    "use strict";
    module2.exports = (path6) => {
      const isExtendedLengthPath = /^\\\\\?\\/.test(path6);
      const hasNonAscii = /[^\u0000-\u0080]+/.test(path6);
      if (isExtendedLengthPath || hasNonAscii) {
        return path6;
      }
      return path6.replace(/\\/g, "/");
    };
  }
});

// node_modules/.pnpm/globby@11.1.0/node_modules/globby/gitignore.js
var require_gitignore = __commonJS({
  "node_modules/.pnpm/globby@11.1.0/node_modules/globby/gitignore.js"(exports, module2) {
    "use strict";
    var { promisify } = require("util");
    var fs5 = require("fs");
    var path6 = require("path");
    var fastGlob = require_out4();
    var gitIgnore = require_ignore();
    var slash = require_slash();
    var DEFAULT_IGNORE = [
      "**/node_modules/**",
      "**/flow-typed/**",
      "**/coverage/**",
      "**/.git"
    ];
    var readFileP = promisify(fs5.readFile);
    var mapGitIgnorePatternTo = (base) => (ignore) => {
      if (ignore.startsWith("!")) {
        return "!" + path6.posix.join(base, ignore.slice(1));
      }
      return path6.posix.join(base, ignore);
    };
    var parseGitIgnore = (content, options) => {
      const base = slash(path6.relative(options.cwd, path6.dirname(options.fileName)));
      return content.split(/\r?\n/).filter(Boolean).filter((line) => !line.startsWith("#")).map(mapGitIgnorePatternTo(base));
    };
    var reduceIgnore = (files) => {
      const ignores = gitIgnore();
      for (const file of files) {
        ignores.add(parseGitIgnore(file.content, {
          cwd: file.cwd,
          fileName: file.filePath
        }));
      }
      return ignores;
    };
    var ensureAbsolutePathForCwd = (cwd, p) => {
      cwd = slash(cwd);
      if (path6.isAbsolute(p)) {
        if (slash(p).startsWith(cwd)) {
          return p;
        }
        throw new Error(`Path ${p} is not in cwd ${cwd}`);
      }
      return path6.join(cwd, p);
    };
    var getIsIgnoredPredecate = (ignores, cwd) => {
      return (p) => ignores.ignores(slash(path6.relative(cwd, ensureAbsolutePathForCwd(cwd, p.path || p))));
    };
    var getFile = async (file, cwd) => {
      const filePath = path6.join(cwd, file);
      const content = await readFileP(filePath, "utf8");
      return {
        cwd,
        filePath,
        content
      };
    };
    var getFileSync = (file, cwd) => {
      const filePath = path6.join(cwd, file);
      const content = fs5.readFileSync(filePath, "utf8");
      return {
        cwd,
        filePath,
        content
      };
    };
    var normalizeOptions = ({
      ignore = [],
      cwd = slash(process.cwd())
    } = {}) => {
      return { ignore, cwd };
    };
    module2.exports = async (options) => {
      options = normalizeOptions(options);
      const paths = await fastGlob("**/.gitignore", {
        ignore: DEFAULT_IGNORE.concat(options.ignore),
        cwd: options.cwd
      });
      const files = await Promise.all(paths.map((file) => getFile(file, options.cwd)));
      const ignores = reduceIgnore(files);
      return getIsIgnoredPredecate(ignores, options.cwd);
    };
    module2.exports.sync = (options) => {
      options = normalizeOptions(options);
      const paths = fastGlob.sync("**/.gitignore", {
        ignore: DEFAULT_IGNORE.concat(options.ignore),
        cwd: options.cwd
      });
      const files = paths.map((file) => getFileSync(file, options.cwd));
      const ignores = reduceIgnore(files);
      return getIsIgnoredPredecate(ignores, options.cwd);
    };
  }
});

// node_modules/.pnpm/globby@11.1.0/node_modules/globby/stream-utils.js
var require_stream_utils = __commonJS({
  "node_modules/.pnpm/globby@11.1.0/node_modules/globby/stream-utils.js"(exports, module2) {
    "use strict";
    var { Transform } = require("stream");
    var ObjectTransform = class extends Transform {
      constructor() {
        super({
          objectMode: true
        });
      }
    };
    var FilterStream = class extends ObjectTransform {
      constructor(filter) {
        super();
        this._filter = filter;
      }
      _transform(data, encoding, callback) {
        if (this._filter(data)) {
          this.push(data);
        }
        callback();
      }
    };
    var UniqueStream = class extends ObjectTransform {
      constructor() {
        super();
        this._pushed = /* @__PURE__ */ new Set();
      }
      _transform(data, encoding, callback) {
        if (!this._pushed.has(data)) {
          this.push(data);
          this._pushed.add(data);
        }
        callback();
      }
    };
    module2.exports = {
      FilterStream,
      UniqueStream
    };
  }
});

// node_modules/.pnpm/globby@11.1.0/node_modules/globby/index.js
var require_globby = __commonJS({
  "node_modules/.pnpm/globby@11.1.0/node_modules/globby/index.js"(exports, module2) {
    "use strict";
    var fs5 = require("fs");
    var arrayUnion = require_array_union();
    var merge2 = require_merge2();
    var fastGlob = require_out4();
    var dirGlob = require_dir_glob();
    var gitignore = require_gitignore();
    var { FilterStream, UniqueStream } = require_stream_utils();
    var DEFAULT_FILTER = () => false;
    var isNegative = (pattern) => pattern[0] === "!";
    var assertPatternsInput = (patterns) => {
      if (!patterns.every((pattern) => typeof pattern === "string")) {
        throw new TypeError("Patterns must be a string or an array of strings");
      }
    };
    var checkCwdOption = (options = {}) => {
      if (!options.cwd) {
        return;
      }
      let stat;
      try {
        stat = fs5.statSync(options.cwd);
      } catch {
        return;
      }
      if (!stat.isDirectory()) {
        throw new Error("The `cwd` option must be a path to a directory");
      }
    };
    var getPathString = (p) => p.stats instanceof fs5.Stats ? p.path : p;
    var generateGlobTasks = (patterns, taskOptions) => {
      patterns = arrayUnion([].concat(patterns));
      assertPatternsInput(patterns);
      checkCwdOption(taskOptions);
      const globTasks = [];
      taskOptions = {
        ignore: [],
        expandDirectories: true,
        ...taskOptions
      };
      for (const [index, pattern] of patterns.entries()) {
        if (isNegative(pattern)) {
          continue;
        }
        const ignore = patterns.slice(index).filter((pattern2) => isNegative(pattern2)).map((pattern2) => pattern2.slice(1));
        const options = {
          ...taskOptions,
          ignore: taskOptions.ignore.concat(ignore)
        };
        globTasks.push({ pattern, options });
      }
      return globTasks;
    };
    var globDirs = (task, fn) => {
      let options = {};
      if (task.options.cwd) {
        options.cwd = task.options.cwd;
      }
      if (Array.isArray(task.options.expandDirectories)) {
        options = {
          ...options,
          files: task.options.expandDirectories
        };
      } else if (typeof task.options.expandDirectories === "object") {
        options = {
          ...options,
          ...task.options.expandDirectories
        };
      }
      return fn(task.pattern, options);
    };
    var getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];
    var getFilterSync = (options) => {
      return options && options.gitignore ? gitignore.sync({ cwd: options.cwd, ignore: options.ignore }) : DEFAULT_FILTER;
    };
    var globToTask = (task) => (glob) => {
      const { options } = task;
      if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {
        options.ignore = dirGlob.sync(options.ignore);
      }
      return {
        pattern: glob,
        options
      };
    };
    module2.exports = async (patterns, options) => {
      const globTasks = generateGlobTasks(patterns, options);
      const getFilter = async () => {
        return options && options.gitignore ? gitignore({ cwd: options.cwd, ignore: options.ignore }) : DEFAULT_FILTER;
      };
      const getTasks = async () => {
        const tasks2 = await Promise.all(globTasks.map(async (task) => {
          const globs = await getPattern(task, dirGlob);
          return Promise.all(globs.map(globToTask(task)));
        }));
        return arrayUnion(...tasks2);
      };
      const [filter, tasks] = await Promise.all([getFilter(), getTasks()]);
      const paths = await Promise.all(tasks.map((task) => fastGlob(task.pattern, task.options)));
      return arrayUnion(...paths).filter((path_) => !filter(getPathString(path_)));
    };
    module2.exports.sync = (patterns, options) => {
      const globTasks = generateGlobTasks(patterns, options);
      const tasks = [];
      for (const task of globTasks) {
        const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
        tasks.push(...newTask);
      }
      const filter = getFilterSync(options);
      let matches = [];
      for (const task of tasks) {
        matches = arrayUnion(matches, fastGlob.sync(task.pattern, task.options));
      }
      return matches.filter((path_) => !filter(path_));
    };
    module2.exports.stream = (patterns, options) => {
      const globTasks = generateGlobTasks(patterns, options);
      const tasks = [];
      for (const task of globTasks) {
        const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
        tasks.push(...newTask);
      }
      const filter = getFilterSync(options);
      const filterStream = new FilterStream((p) => !filter(p));
      const uniqueStream = new UniqueStream();
      return merge2(tasks.map((task) => fastGlob.stream(task.pattern, task.options))).pipe(filterStream).pipe(uniqueStream);
    };
    module2.exports.generateGlobTasks = generateGlobTasks;
    module2.exports.hasMagic = (patterns, options) => [].concat(patterns).some((pattern) => fastGlob.isDynamicPattern(pattern, options));
    module2.exports.gitignore = gitignore;
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/resolveProjectList.js
var require_resolveProjectList = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/resolveProjectList.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clearGlobResolutionCache = exports.resolveProjectList = exports.clearGlobCache = void 0;
    var debug_1 = __importDefault2(require_src());
    var globby_1 = require_globby();
    var is_glob_1 = __importDefault2(require_is_glob());
    var shared_1 = require_shared();
    var ExpiringCache_1 = require_ExpiringCache();
    var log = (0, debug_1.default)("typescript-eslint:typescript-estree:parser:parseSettings:resolveProjectList");
    var RESOLUTION_CACHE = null;
    function clearGlobCache() {
      RESOLUTION_CACHE === null || RESOLUTION_CACHE === void 0 ? void 0 : RESOLUTION_CACHE.clear();
    }
    exports.clearGlobCache = clearGlobCache;
    function resolveProjectList(options) {
      var _a2, _b, _c;
      const sanitizedProjects = [];
      if (typeof options.project === "string") {
        sanitizedProjects.push(options.project);
      } else if (Array.isArray(options.project)) {
        for (const project of options.project) {
          if (typeof project === "string") {
            sanitizedProjects.push(project);
          }
        }
      }
      if (sanitizedProjects.length === 0) {
        return [];
      }
      const projectFolderIgnoreList = ((_a2 = options.projectFolderIgnoreList) !== null && _a2 !== void 0 ? _a2 : ["**/node_modules/**"]).reduce((acc, folder) => {
        if (typeof folder === "string") {
          acc.push(folder);
        }
        return acc;
      }, []).map((folder) => folder.startsWith("!") ? folder : `!${folder}`);
      const cacheKey = getHash({
        project: sanitizedProjects,
        projectFolderIgnoreList,
        tsconfigRootDir: options.tsconfigRootDir
      });
      if (RESOLUTION_CACHE == null) {
        RESOLUTION_CACHE = new ExpiringCache_1.ExpiringCache(options.singleRun ? "Infinity" : (_c = (_b = options.cacheLifetime) === null || _b === void 0 ? void 0 : _b.glob) !== null && _c !== void 0 ? _c : ExpiringCache_1.DEFAULT_TSCONFIG_CACHE_DURATION_SECONDS);
      } else {
        const cached = RESOLUTION_CACHE.get(cacheKey);
        if (cached) {
          return cached;
        }
      }
      const nonGlobProjects = sanitizedProjects.filter((project) => !(0, is_glob_1.default)(project));
      const globProjects = sanitizedProjects.filter((project) => (0, is_glob_1.default)(project));
      const uniqueCanonicalProjectPaths = new Set(nonGlobProjects.concat(globProjects.length === 0 ? [] : (0, globby_1.sync)([...globProjects, ...projectFolderIgnoreList], {
        cwd: options.tsconfigRootDir
      })).map((project) => (0, shared_1.getCanonicalFileName)((0, shared_1.ensureAbsolutePath)(project, options.tsconfigRootDir))));
      log("parserOptions.project (excluding ignored) matched projects: %s", uniqueCanonicalProjectPaths);
      const returnValue = Array.from(uniqueCanonicalProjectPaths);
      RESOLUTION_CACHE.set(cacheKey, returnValue);
      return returnValue;
    }
    exports.resolveProjectList = resolveProjectList;
    function getHash({ project, projectFolderIgnoreList, tsconfigRootDir }) {
      const hashObject = {
        tsconfigRootDir,
        // the project order does matter and can impact the resolved globs
        project,
        // the ignore order won't doesn't ever matter
        projectFolderIgnoreList: [...projectFolderIgnoreList].sort()
      };
      return (0, shared_1.createHash)(JSON.stringify(hashObject));
    }
    function clearGlobResolutionCache() {
      RESOLUTION_CACHE === null || RESOLUTION_CACHE === void 0 ? void 0 : RESOLUTION_CACHE.clear();
      RESOLUTION_CACHE = null;
    }
    exports.clearGlobResolutionCache = clearGlobResolutionCache;
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/warnAboutTSVersion.js
var require_warnAboutTSVersion = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/warnAboutTSVersion.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.warnAboutTSVersion = void 0;
    var semver_1 = __importDefault2(require_semver2());
    var ts6 = __importStar2(require("typescript"));
    var SUPPORTED_TYPESCRIPT_VERSIONS = ">=3.3.1 <5.1.0";
    var SUPPORTED_PRERELEASE_RANGES = ["5.0.1-rc"];
    var ACTIVE_TYPESCRIPT_VERSION = ts6.version;
    var isRunningSupportedTypeScriptVersion = semver_1.default.satisfies(ACTIVE_TYPESCRIPT_VERSION, [SUPPORTED_TYPESCRIPT_VERSIONS].concat(SUPPORTED_PRERELEASE_RANGES).join(" || "));
    var warnedAboutTSVersion = false;
    function warnAboutTSVersion(parseSettings) {
      var _a2;
      if (!isRunningSupportedTypeScriptVersion && !warnedAboutTSVersion) {
        const isTTY = typeof process === "undefined" ? false : (_a2 = process.stdout) === null || _a2 === void 0 ? void 0 : _a2.isTTY;
        if (isTTY) {
          const border = "=============";
          const versionWarning = [
            border,
            "WARNING: You are currently running a version of TypeScript which is not officially supported by @typescript-eslint/typescript-estree.",
            "You may find that it works just fine, or you may not.",
            `SUPPORTED TYPESCRIPT VERSIONS: ${SUPPORTED_TYPESCRIPT_VERSIONS}`,
            `YOUR TYPESCRIPT VERSION: ${ACTIVE_TYPESCRIPT_VERSION}`,
            "Please only submit bug reports when using the officially supported version.",
            border
          ];
          parseSettings.log(versionWarning.join("\n\n"));
        }
        warnedAboutTSVersion = true;
      }
    }
    exports.warnAboutTSVersion = warnAboutTSVersion;
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/createParseSettings.js
var require_createParseSettings = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/createParseSettings.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clearTSConfigMatchCache = exports.createParseSettings = void 0;
    var debug_1 = __importDefault2(require_src());
    var shared_1 = require_shared();
    var ExpiringCache_1 = require_ExpiringCache();
    var getProjectConfigFiles_1 = require_getProjectConfigFiles();
    var inferSingleRun_1 = require_inferSingleRun();
    var resolveProjectList_1 = require_resolveProjectList();
    var warnAboutTSVersion_1 = require_warnAboutTSVersion();
    var log = (0, debug_1.default)("typescript-eslint:typescript-estree:parser:parseSettings:createParseSettings");
    var TSCONFIG_MATCH_CACHE;
    function createParseSettings(code, options = {}) {
      var _a2, _b, _c;
      const singleRun = (0, inferSingleRun_1.inferSingleRun)(options);
      const tsconfigRootDir = typeof options.tsconfigRootDir === "string" ? options.tsconfigRootDir : process.cwd();
      const parseSettings = {
        code: enforceString(code),
        comment: options.comment === true,
        comments: [],
        createDefaultProgram: options.createDefaultProgram === true,
        debugLevel: options.debugLevel === true ? /* @__PURE__ */ new Set(["typescript-eslint"]) : Array.isArray(options.debugLevel) ? new Set(options.debugLevel) : /* @__PURE__ */ new Set(),
        errorOnTypeScriptSyntacticAndSemanticIssues: false,
        errorOnUnknownASTType: options.errorOnUnknownASTType === true,
        EXPERIMENTAL_useSourceOfProjectReferenceRedirect: options.EXPERIMENTAL_useSourceOfProjectReferenceRedirect === true,
        extraFileExtensions: Array.isArray(options.extraFileExtensions) && options.extraFileExtensions.every((ext) => typeof ext === "string") ? options.extraFileExtensions : [],
        filePath: (0, shared_1.ensureAbsolutePath)(typeof options.filePath === "string" && options.filePath !== "<input>" ? options.filePath : getFileName(options.jsx), tsconfigRootDir),
        jsx: options.jsx === true,
        loc: options.loc === true,
        log: typeof options.loggerFn === "function" ? options.loggerFn : options.loggerFn === false ? () => {
        } : console.log,
        moduleResolver: (_a2 = options.moduleResolver) !== null && _a2 !== void 0 ? _a2 : "",
        preserveNodeMaps: options.preserveNodeMaps !== false,
        programs: Array.isArray(options.programs) ? options.programs : null,
        projects: [],
        range: options.range === true,
        singleRun,
        tokens: options.tokens === true ? [] : null,
        tsconfigMatchCache: TSCONFIG_MATCH_CACHE !== null && TSCONFIG_MATCH_CACHE !== void 0 ? TSCONFIG_MATCH_CACHE : TSCONFIG_MATCH_CACHE = new ExpiringCache_1.ExpiringCache(singleRun ? "Infinity" : (_c = (_b = options.cacheLifetime) === null || _b === void 0 ? void 0 : _b.glob) !== null && _c !== void 0 ? _c : ExpiringCache_1.DEFAULT_TSCONFIG_CACHE_DURATION_SECONDS),
        tsconfigRootDir
      };
      if (parseSettings.debugLevel.size > 0) {
        const namespaces = [];
        if (parseSettings.debugLevel.has("typescript-eslint")) {
          namespaces.push("typescript-eslint:*");
        }
        if (parseSettings.debugLevel.has("eslint") || // make sure we don't turn off the eslint debug if it was enabled via --debug
        debug_1.default.enabled("eslint:*,-eslint:code-path")) {
          namespaces.push("eslint:*,-eslint:code-path");
        }
        debug_1.default.enable(namespaces.join(","));
      }
      if (Array.isArray(options.programs)) {
        if (!options.programs.length) {
          throw new Error(`You have set parserOptions.programs to an empty array. This will cause all files to not be found in existing programs. Either provide one or more existing TypeScript Program instances in the array, or remove the parserOptions.programs setting.`);
        }
        log("parserOptions.programs was provided, so parserOptions.project will be ignored.");
      }
      if (!parseSettings.programs) {
        parseSettings.projects = (0, resolveProjectList_1.resolveProjectList)({
          cacheLifetime: options.cacheLifetime,
          project: (0, getProjectConfigFiles_1.getProjectConfigFiles)(parseSettings, options.project),
          projectFolderIgnoreList: options.projectFolderIgnoreList,
          singleRun: parseSettings.singleRun,
          tsconfigRootDir
        });
      }
      (0, warnAboutTSVersion_1.warnAboutTSVersion)(parseSettings);
      return parseSettings;
    }
    exports.createParseSettings = createParseSettings;
    function clearTSConfigMatchCache() {
      TSCONFIG_MATCH_CACHE === null || TSCONFIG_MATCH_CACHE === void 0 ? void 0 : TSCONFIG_MATCH_CACHE.clear();
    }
    exports.clearTSConfigMatchCache = clearTSConfigMatchCache;
    function enforceString(code) {
      if (typeof code !== "string") {
        return String(code);
      }
      return code;
    }
    function getFileName(jsx) {
      return jsx ? "estree.tsx" : "estree.ts";
    }
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/semantic-or-syntactic-errors.js
var require_semantic_or_syntactic_errors = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/semantic-or-syntactic-errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFirstSemanticOrSyntacticError = void 0;
    var typescript_1 = require("typescript");
    function getFirstSemanticOrSyntacticError(program, ast) {
      try {
        const supportedSyntacticDiagnostics = whitelistSupportedDiagnostics(program.getSyntacticDiagnostics(ast));
        if (supportedSyntacticDiagnostics.length) {
          return convertDiagnosticToSemanticOrSyntacticError(supportedSyntacticDiagnostics[0]);
        }
        const supportedSemanticDiagnostics = whitelistSupportedDiagnostics(program.getSemanticDiagnostics(ast));
        if (supportedSemanticDiagnostics.length) {
          return convertDiagnosticToSemanticOrSyntacticError(supportedSemanticDiagnostics[0]);
        }
        return void 0;
      } catch (e) {
        console.warn(`Warning From TSC: "${e.message}`);
        return void 0;
      }
    }
    exports.getFirstSemanticOrSyntacticError = getFirstSemanticOrSyntacticError;
    function whitelistSupportedDiagnostics(diagnostics) {
      return diagnostics.filter((diagnostic) => {
        switch (diagnostic.code) {
          case 1013:
          case 1014:
          case 1044:
          case 1045:
          case 1048:
          case 1049:
          case 1070:
          case 1071:
          case 1085:
          case 1090:
          case 1096:
          case 1097:
          case 1098:
          case 1099:
          case 1117:
          case 1121:
          case 1123:
          case 1141:
          case 1162:
          case 1164:
          case 1172:
          case 1173:
          case 1175:
          case 1176:
          case 1190:
          case 1196:
          case 1200:
          case 1206:
          case 1211:
          case 1242:
          case 1246:
          case 1255:
          case 1308:
          case 2364:
          case 2369:
          case 2452:
          case 2462:
          case 8017:
          case 17012:
          case 17013:
            return true;
        }
        return false;
      });
    }
    function convertDiagnosticToSemanticOrSyntacticError(diagnostic) {
      return Object.assign(Object.assign({}, diagnostic), { message: (0, typescript_1.flattenDiagnosticMessageText)(diagnostic.messageText, typescript_1.sys.newLine) });
    }
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/parser.js
var require_parser = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/parser.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clearParseAndGenerateServicesCalls = exports.clearProgramCache = exports.parseWithNodeMaps = exports.parseAndGenerateServices = exports.parse = void 0;
    var debug_1 = __importDefault2(require_src());
    var ast_converter_1 = require_ast_converter();
    var convert_1 = require_convert();
    var createDefaultProgram_1 = require_createDefaultProgram();
    var createIsolatedProgram_1 = require_createIsolatedProgram();
    var createProjectProgram_1 = require_createProjectProgram();
    var createSourceFile_1 = require_createSourceFile();
    var useProvidedPrograms_1 = require_useProvidedPrograms();
    var createParseSettings_1 = require_createParseSettings();
    var semantic_or_syntactic_errors_1 = require_semantic_or_syntactic_errors();
    var log = (0, debug_1.default)("typescript-eslint:typescript-estree:parser");
    var existingPrograms = /* @__PURE__ */ new Map();
    function clearProgramCache() {
      existingPrograms.clear();
    }
    exports.clearProgramCache = clearProgramCache;
    function getProgramAndAST(parseSettings, shouldProvideParserServices) {
      return parseSettings.programs && (0, useProvidedPrograms_1.useProvidedPrograms)(parseSettings.programs, parseSettings) || shouldProvideParserServices && (0, createProjectProgram_1.createProjectProgram)(parseSettings) || shouldProvideParserServices && parseSettings.createDefaultProgram && (0, createDefaultProgram_1.createDefaultProgram)(parseSettings) || (0, createIsolatedProgram_1.createIsolatedProgram)(parseSettings);
    }
    function parse2(code, options) {
      const { ast } = parseWithNodeMapsInternal(code, options, false);
      return ast;
    }
    exports.parse = parse2;
    function parseWithNodeMapsInternal(code, options, shouldPreserveNodeMaps) {
      const parseSettings = (0, createParseSettings_1.createParseSettings)(code, options);
      if (options === null || options === void 0 ? void 0 : options.errorOnTypeScriptSyntacticAndSemanticIssues) {
        throw new Error(`"errorOnTypeScriptSyntacticAndSemanticIssues" is only supported for parseAndGenerateServices()`);
      }
      const ast = (0, createSourceFile_1.createSourceFile)(parseSettings);
      const { estree, astMaps } = (0, ast_converter_1.astConverter)(ast, parseSettings, shouldPreserveNodeMaps);
      return {
        ast: estree,
        esTreeNodeToTSNodeMap: astMaps.esTreeNodeToTSNodeMap,
        tsNodeToESTreeNodeMap: astMaps.tsNodeToESTreeNodeMap
      };
    }
    function parseWithNodeMaps(code, options) {
      return parseWithNodeMapsInternal(code, options, true);
    }
    exports.parseWithNodeMaps = parseWithNodeMaps;
    var parseAndGenerateServicesCalls = {};
    function clearParseAndGenerateServicesCalls() {
      parseAndGenerateServicesCalls = {};
    }
    exports.clearParseAndGenerateServicesCalls = clearParseAndGenerateServicesCalls;
    function parseAndGenerateServices(code, options) {
      var _a2, _b;
      const parseSettings = (0, createParseSettings_1.createParseSettings)(code, options);
      if (options !== void 0) {
        if (typeof options.errorOnTypeScriptSyntacticAndSemanticIssues === "boolean" && options.errorOnTypeScriptSyntacticAndSemanticIssues) {
          parseSettings.errorOnTypeScriptSyntacticAndSemanticIssues = true;
        }
      }
      if (parseSettings.singleRun && !parseSettings.programs && ((_a2 = parseSettings.projects) === null || _a2 === void 0 ? void 0 : _a2.length) > 0) {
        parseSettings.programs = {
          *[Symbol.iterator]() {
            for (const configFile of parseSettings.projects) {
              const existingProgram = existingPrograms.get(configFile);
              if (existingProgram) {
                yield existingProgram;
              } else {
                log("Detected single-run/CLI usage, creating Program once ahead of time for project: %s", configFile);
                const newProgram = (0, useProvidedPrograms_1.createProgramFromConfigFile)(configFile);
                existingPrograms.set(configFile, newProgram);
                yield newProgram;
              }
            }
          }
        };
      }
      const shouldProvideParserServices = parseSettings.programs != null || ((_b = parseSettings.projects) === null || _b === void 0 ? void 0 : _b.length) > 0;
      if (parseSettings.singleRun && options.filePath) {
        parseAndGenerateServicesCalls[options.filePath] = (parseAndGenerateServicesCalls[options.filePath] || 0) + 1;
      }
      const { ast, program } = parseSettings.singleRun && options.filePath && parseAndGenerateServicesCalls[options.filePath] > 1 ? (0, createIsolatedProgram_1.createIsolatedProgram)(parseSettings) : getProgramAndAST(parseSettings, shouldProvideParserServices);
      const shouldPreserveNodeMaps = typeof parseSettings.preserveNodeMaps === "boolean" ? parseSettings.preserveNodeMaps : true;
      const { estree, astMaps } = (0, ast_converter_1.astConverter)(ast, parseSettings, shouldPreserveNodeMaps);
      if (program && parseSettings.errorOnTypeScriptSyntacticAndSemanticIssues) {
        const error = (0, semantic_or_syntactic_errors_1.getFirstSemanticOrSyntacticError)(program, ast);
        if (error) {
          throw (0, convert_1.convertError)(error);
        }
      }
      return {
        ast: estree,
        services: {
          hasFullTypeInformation: shouldProvideParserServices,
          program,
          esTreeNodeToTSNodeMap: astMaps.esTreeNodeToTSNodeMap,
          tsNodeToESTreeNodeMap: astMaps.tsNodeToESTreeNodeMap
        }
      };
    }
    exports.parseAndGenerateServices = parseAndGenerateServices;
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/clear-caches.js
var require_clear_caches = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/clear-caches.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clearProgramCache = exports.clearCaches = void 0;
    var getWatchProgramsForProjects_1 = require_getWatchProgramsForProjects();
    var parser_1 = require_parser();
    var createParseSettings_1 = require_createParseSettings();
    var resolveProjectList_1 = require_resolveProjectList();
    function clearCaches() {
      (0, parser_1.clearProgramCache)();
      (0, getWatchProgramsForProjects_1.clearWatchCaches)();
      (0, createParseSettings_1.clearTSConfigMatchCache)();
      (0, resolveProjectList_1.clearGlobCache)();
    }
    exports.clearCaches = clearCaches;
    exports.clearProgramCache = clearCaches;
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/package.json
var require_package = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/package.json"(exports, module2) {
    module2.exports = {
      name: "@typescript-eslint/typescript-estree",
      version: "5.59.2",
      description: "A parser that converts TypeScript source code into an ESTree compatible form",
      main: "dist/index.js",
      types: "dist/index.d.ts",
      files: [
        "dist",
        "_ts3.4",
        "README.md",
        "LICENSE"
      ],
      engines: {
        node: "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      repository: {
        type: "git",
        url: "https://github.com/typescript-eslint/typescript-eslint.git",
        directory: "packages/typescript-estree"
      },
      bugs: {
        url: "https://github.com/typescript-eslint/typescript-eslint/issues"
      },
      license: "BSD-2-Clause",
      keywords: [
        "ast",
        "estree",
        "ecmascript",
        "javascript",
        "typescript",
        "parser",
        "syntax"
      ],
      scripts: {
        build: "tsc -b tsconfig.build.json",
        postbuild: "downlevel-dts dist _ts3.4/dist",
        clean: "tsc -b tsconfig.build.json --clean",
        postclean: "rimraf dist && rimraf _ts3.4 && rimraf coverage",
        format: 'prettier --write "./**/*.{ts,mts,cts,tsx,js,mjs,cjs,jsx,json,md,css}" --ignore-path ../../.prettierignore',
        lint: "nx lint",
        test: "jest --coverage",
        typecheck: "tsc -p tsconfig.json --noEmit"
      },
      dependencies: {
        "@typescript-eslint/types": "5.59.2",
        "@typescript-eslint/visitor-keys": "5.59.2",
        debug: "^4.3.4",
        globby: "^11.1.0",
        "is-glob": "^4.0.3",
        semver: "^7.3.7",
        tsutils: "^3.21.0"
      },
      devDependencies: {
        "@babel/code-frame": "*",
        "@babel/parser": "*",
        "@types/babel__code-frame": "*",
        "@types/debug": "*",
        "@types/glob": "*",
        "@types/is-glob": "*",
        "@types/semver": "*",
        "@types/tmp": "*",
        glob: "*",
        "jest-specific-snapshot": "*",
        "make-dir": "*",
        tmp: "*",
        typescript: "*"
      },
      peerDependenciesMeta: {
        typescript: {
          optional: true
        }
      },
      funding: {
        type: "opencollective",
        url: "https://opencollective.com/typescript-eslint"
      },
      typesVersions: {
        "<3.8": {
          "*": [
            "_ts3.4/*"
          ]
        }
      },
      gitHead: "ce5f5165c9d4c5843c86d48b6e6e9a488eb06b0a"
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+typescript-estree@5.59.2_typescript@4.9.4/node_modules/@typescript-eslint/typescript-estree/dist/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding2(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = exports.visitorKeys = exports.typescriptVersionIsAtLeast = exports.createProgram = exports.simpleTraverse = exports.parseWithNodeMaps = exports.parseAndGenerateServices = exports.parse = void 0;
    var parser_1 = require_parser();
    Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
      return parser_1.parse;
    } });
    Object.defineProperty(exports, "parseAndGenerateServices", { enumerable: true, get: function() {
      return parser_1.parseAndGenerateServices;
    } });
    Object.defineProperty(exports, "parseWithNodeMaps", { enumerable: true, get: function() {
      return parser_1.parseWithNodeMaps;
    } });
    var simple_traverse_1 = require_simple_traverse();
    Object.defineProperty(exports, "simpleTraverse", { enumerable: true, get: function() {
      return simple_traverse_1.simpleTraverse;
    } });
    __exportStar2(require_ts_estree2(), exports);
    var useProvidedPrograms_1 = require_useProvidedPrograms();
    Object.defineProperty(exports, "createProgram", { enumerable: true, get: function() {
      return useProvidedPrograms_1.createProgramFromConfigFile;
    } });
    __exportStar2(require_getScriptKind(), exports);
    var version_check_1 = require_version_check();
    Object.defineProperty(exports, "typescriptVersionIsAtLeast", { enumerable: true, get: function() {
      return version_check_1.typescriptVersionIsAtLeast;
    } });
    __exportStar2(require_getModifiers(), exports);
    __exportStar2(require_clear_caches(), exports);
    var visitor_keys_1 = require_dist2();
    Object.defineProperty(exports, "visitorKeys", { enumerable: true, get: function() {
      return visitor_keys_1.visitorKeys;
    } });
    exports.version = require_package().version;
  }
});

// node_modules/.pnpm/@eslint-community+eslint-utils@4.4.0_eslint@8.40.0/node_modules/@eslint-community/eslint-utils/index.js
var require_eslint_utils = __commonJS({
  "node_modules/.pnpm/@eslint-community+eslint-utils@4.4.0_eslint@8.40.0/node_modules/@eslint-community/eslint-utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var eslintVisitorKeys = require_eslint_visitor_keys();
    function getInnermostScope(initialScope, node) {
      const location = node.range[0];
      let scope = initialScope;
      let found = false;
      do {
        found = false;
        for (const childScope of scope.childScopes) {
          const range = childScope.block.range;
          if (range[0] <= location && location < range[1]) {
            scope = childScope;
            found = true;
            break;
          }
        }
      } while (found);
      return scope;
    }
    function findVariable(initialScope, nameOrNode) {
      let name = "";
      let scope = initialScope;
      if (typeof nameOrNode === "string") {
        name = nameOrNode;
      } else {
        name = nameOrNode.name;
        scope = getInnermostScope(scope, nameOrNode);
      }
      while (scope != null) {
        const variable = scope.set.get(name);
        if (variable != null) {
          return variable;
        }
        scope = scope.upper;
      }
      return null;
    }
    function negate0(token) {
      return !this(token);
    }
    function negate(f) {
      return negate0.bind(f);
    }
    function isPunctuatorTokenWithValue(token, value) {
      return token.type === "Punctuator" && token.value === value;
    }
    function isArrowToken(token) {
      return isPunctuatorTokenWithValue(token, "=>");
    }
    function isCommaToken(token) {
      return isPunctuatorTokenWithValue(token, ",");
    }
    function isSemicolonToken(token) {
      return isPunctuatorTokenWithValue(token, ";");
    }
    function isColonToken(token) {
      return isPunctuatorTokenWithValue(token, ":");
    }
    function isOpeningParenToken(token) {
      return isPunctuatorTokenWithValue(token, "(");
    }
    function isClosingParenToken(token) {
      return isPunctuatorTokenWithValue(token, ")");
    }
    function isOpeningBracketToken(token) {
      return isPunctuatorTokenWithValue(token, "[");
    }
    function isClosingBracketToken(token) {
      return isPunctuatorTokenWithValue(token, "]");
    }
    function isOpeningBraceToken(token) {
      return isPunctuatorTokenWithValue(token, "{");
    }
    function isClosingBraceToken(token) {
      return isPunctuatorTokenWithValue(token, "}");
    }
    function isCommentToken(token) {
      return ["Block", "Line", "Shebang"].includes(token.type);
    }
    var isNotArrowToken = negate(isArrowToken);
    var isNotCommaToken = negate(isCommaToken);
    var isNotSemicolonToken = negate(isSemicolonToken);
    var isNotColonToken = negate(isColonToken);
    var isNotOpeningParenToken = negate(isOpeningParenToken);
    var isNotClosingParenToken = negate(isClosingParenToken);
    var isNotOpeningBracketToken = negate(isOpeningBracketToken);
    var isNotClosingBracketToken = negate(isClosingBracketToken);
    var isNotOpeningBraceToken = negate(isOpeningBraceToken);
    var isNotClosingBraceToken = negate(isClosingBraceToken);
    var isNotCommentToken = negate(isCommentToken);
    function getOpeningParenOfParams(node, sourceCode) {
      return node.id ? sourceCode.getTokenAfter(node.id, isOpeningParenToken) : sourceCode.getFirstToken(node, isOpeningParenToken);
    }
    function getFunctionHeadLocation(node, sourceCode) {
      const parent = node.parent;
      let start = null;
      let end = null;
      if (node.type === "ArrowFunctionExpression") {
        const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);
        start = arrowToken.loc.start;
        end = arrowToken.loc.end;
      } else if (parent.type === "Property" || parent.type === "MethodDefinition" || parent.type === "PropertyDefinition") {
        start = parent.loc.start;
        end = getOpeningParenOfParams(node, sourceCode).loc.start;
      } else {
        start = node.loc.start;
        end = getOpeningParenOfParams(node, sourceCode).loc.start;
      }
      return {
        start: { ...start },
        end: { ...end }
      };
    }
    var globalObject = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
    var builtinNames = Object.freeze(
      /* @__PURE__ */ new Set([
        "Array",
        "ArrayBuffer",
        "BigInt",
        "BigInt64Array",
        "BigUint64Array",
        "Boolean",
        "DataView",
        "Date",
        "decodeURI",
        "decodeURIComponent",
        "encodeURI",
        "encodeURIComponent",
        "escape",
        "Float32Array",
        "Float64Array",
        "Function",
        "Infinity",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "isFinite",
        "isNaN",
        "isPrototypeOf",
        "JSON",
        "Map",
        "Math",
        "NaN",
        "Number",
        "Object",
        "parseFloat",
        "parseInt",
        "Promise",
        "Proxy",
        "Reflect",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "undefined",
        "unescape",
        "WeakMap",
        "WeakSet"
      ])
    );
    var callAllowed = new Set(
      [
        Array.isArray,
        Array.of,
        Array.prototype.at,
        Array.prototype.concat,
        Array.prototype.entries,
        Array.prototype.every,
        Array.prototype.filter,
        Array.prototype.find,
        Array.prototype.findIndex,
        Array.prototype.flat,
        Array.prototype.includes,
        Array.prototype.indexOf,
        Array.prototype.join,
        Array.prototype.keys,
        Array.prototype.lastIndexOf,
        Array.prototype.slice,
        Array.prototype.some,
        Array.prototype.toString,
        Array.prototype.values,
        typeof BigInt === "function" ? BigInt : void 0,
        Boolean,
        Date,
        Date.parse,
        decodeURI,
        decodeURIComponent,
        encodeURI,
        encodeURIComponent,
        escape,
        isFinite,
        isNaN,
        isPrototypeOf,
        Map,
        Map.prototype.entries,
        Map.prototype.get,
        Map.prototype.has,
        Map.prototype.keys,
        Map.prototype.values,
        ...Object.getOwnPropertyNames(Math).filter((k) => k !== "random").map((k) => Math[k]).filter((f) => typeof f === "function"),
        Number,
        Number.isFinite,
        Number.isNaN,
        Number.parseFloat,
        Number.parseInt,
        Number.prototype.toExponential,
        Number.prototype.toFixed,
        Number.prototype.toPrecision,
        Number.prototype.toString,
        Object,
        Object.entries,
        Object.is,
        Object.isExtensible,
        Object.isFrozen,
        Object.isSealed,
        Object.keys,
        Object.values,
        parseFloat,
        parseInt,
        RegExp,
        Set,
        Set.prototype.entries,
        Set.prototype.has,
        Set.prototype.keys,
        Set.prototype.values,
        String,
        String.fromCharCode,
        String.fromCodePoint,
        String.raw,
        String.prototype.at,
        String.prototype.charAt,
        String.prototype.charCodeAt,
        String.prototype.codePointAt,
        String.prototype.concat,
        String.prototype.endsWith,
        String.prototype.includes,
        String.prototype.indexOf,
        String.prototype.lastIndexOf,
        String.prototype.normalize,
        String.prototype.padEnd,
        String.prototype.padStart,
        String.prototype.slice,
        String.prototype.startsWith,
        String.prototype.substr,
        String.prototype.substring,
        String.prototype.toLowerCase,
        String.prototype.toString,
        String.prototype.toUpperCase,
        String.prototype.trim,
        String.prototype.trimEnd,
        String.prototype.trimLeft,
        String.prototype.trimRight,
        String.prototype.trimStart,
        Symbol.for,
        Symbol.keyFor,
        unescape
      ].filter((f) => typeof f === "function")
    );
    var callPassThrough = /* @__PURE__ */ new Set([
      Object.freeze,
      Object.preventExtensions,
      Object.seal
    ]);
    var getterAllowed = [
      [Map, /* @__PURE__ */ new Set(["size"])],
      [
        RegExp,
        /* @__PURE__ */ new Set([
          "dotAll",
          "flags",
          "global",
          "hasIndices",
          "ignoreCase",
          "multiline",
          "source",
          "sticky",
          "unicode"
        ])
      ],
      [Set, /* @__PURE__ */ new Set(["size"])]
    ];
    function getPropertyDescriptor(object, name) {
      let x = object;
      while ((typeof x === "object" || typeof x === "function") && x !== null) {
        const d = Object.getOwnPropertyDescriptor(x, name);
        if (d) {
          return d;
        }
        x = Object.getPrototypeOf(x);
      }
      return null;
    }
    function isGetter(object, name) {
      const d = getPropertyDescriptor(object, name);
      return d != null && d.get != null;
    }
    function getElementValues(nodeList, initialScope) {
      const valueList = [];
      for (let i = 0; i < nodeList.length; ++i) {
        const elementNode = nodeList[i];
        if (elementNode == null) {
          valueList.length = i + 1;
        } else if (elementNode.type === "SpreadElement") {
          const argument = getStaticValueR(elementNode.argument, initialScope);
          if (argument == null) {
            return null;
          }
          valueList.push(...argument.value);
        } else {
          const element = getStaticValueR(elementNode, initialScope);
          if (element == null) {
            return null;
          }
          valueList.push(element.value);
        }
      }
      return valueList;
    }
    function isEffectivelyConst(variable) {
      const refs = variable.references;
      const inits = refs.filter((r) => r.init).length;
      const reads = refs.filter((r) => r.isReadOnly()).length;
      if (inits === 1 && reads + inits === refs.length) {
        return true;
      }
      return false;
    }
    var operations = Object.freeze({
      ArrayExpression(node, initialScope) {
        const elements = getElementValues(node.elements, initialScope);
        return elements != null ? { value: elements } : null;
      },
      AssignmentExpression(node, initialScope) {
        if (node.operator === "=") {
          return getStaticValueR(node.right, initialScope);
        }
        return null;
      },
      //eslint-disable-next-line complexity
      BinaryExpression(node, initialScope) {
        if (node.operator === "in" || node.operator === "instanceof") {
          return null;
        }
        const left6 = getStaticValueR(node.left, initialScope);
        const right7 = getStaticValueR(node.right, initialScope);
        if (left6 != null && right7 != null) {
          switch (node.operator) {
            case "==":
              return { value: left6.value == right7.value };
            case "!=":
              return { value: left6.value != right7.value };
            case "===":
              return { value: left6.value === right7.value };
            case "!==":
              return { value: left6.value !== right7.value };
            case "<":
              return { value: left6.value < right7.value };
            case "<=":
              return { value: left6.value <= right7.value };
            case ">":
              return { value: left6.value > right7.value };
            case ">=":
              return { value: left6.value >= right7.value };
            case "<<":
              return { value: left6.value << right7.value };
            case ">>":
              return { value: left6.value >> right7.value };
            case ">>>":
              return { value: left6.value >>> right7.value };
            case "+":
              return { value: left6.value + right7.value };
            case "-":
              return { value: left6.value - right7.value };
            case "*":
              return { value: left6.value * right7.value };
            case "/":
              return { value: left6.value / right7.value };
            case "%":
              return { value: left6.value % right7.value };
            case "**":
              return { value: left6.value ** right7.value };
            case "|":
              return { value: left6.value | right7.value };
            case "^":
              return { value: left6.value ^ right7.value };
            case "&":
              return { value: left6.value & right7.value };
          }
        }
        return null;
      },
      CallExpression(node, initialScope) {
        const calleeNode = node.callee;
        const args = getElementValues(node.arguments, initialScope);
        if (args != null) {
          if (calleeNode.type === "MemberExpression") {
            if (calleeNode.property.type === "PrivateIdentifier") {
              return null;
            }
            const object = getStaticValueR(calleeNode.object, initialScope);
            if (object != null) {
              if (object.value == null && (object.optional || node.optional)) {
                return { value: void 0, optional: true };
              }
              const property = getStaticPropertyNameValue(
                calleeNode,
                initialScope
              );
              if (property != null) {
                const receiver = object.value;
                const methodName = property.value;
                if (callAllowed.has(receiver[methodName])) {
                  return { value: receiver[methodName](...args) };
                }
                if (callPassThrough.has(receiver[methodName])) {
                  return { value: args[0] };
                }
              }
            }
          } else {
            const callee = getStaticValueR(calleeNode, initialScope);
            if (callee != null) {
              if (callee.value == null && node.optional) {
                return { value: void 0, optional: true };
              }
              const func = callee.value;
              if (callAllowed.has(func)) {
                return { value: func(...args) };
              }
              if (callPassThrough.has(func)) {
                return { value: args[0] };
              }
            }
          }
        }
        return null;
      },
      ConditionalExpression(node, initialScope) {
        const test = getStaticValueR(node.test, initialScope);
        if (test != null) {
          return test.value ? getStaticValueR(node.consequent, initialScope) : getStaticValueR(node.alternate, initialScope);
        }
        return null;
      },
      ExpressionStatement(node, initialScope) {
        return getStaticValueR(node.expression, initialScope);
      },
      Identifier(node, initialScope) {
        if (initialScope != null) {
          const variable = findVariable(initialScope, node);
          if (variable != null && variable.defs.length === 0 && builtinNames.has(variable.name) && variable.name in globalObject) {
            return { value: globalObject[variable.name] };
          }
          if (variable != null && variable.defs.length === 1) {
            const def = variable.defs[0];
            if (def.parent && def.type === "Variable" && (def.parent.kind === "const" || isEffectivelyConst(variable)) && // TODO(mysticatea): don't support destructuring here.
            def.node.id.type === "Identifier") {
              return getStaticValueR(def.node.init, initialScope);
            }
          }
        }
        return null;
      },
      Literal(node) {
        if ((node.regex != null || node.bigint != null) && node.value == null) {
          return null;
        }
        return { value: node.value };
      },
      LogicalExpression(node, initialScope) {
        const left6 = getStaticValueR(node.left, initialScope);
        if (left6 != null) {
          if (node.operator === "||" && Boolean(left6.value) === true || node.operator === "&&" && Boolean(left6.value) === false || node.operator === "??" && left6.value != null) {
            return left6;
          }
          const right7 = getStaticValueR(node.right, initialScope);
          if (right7 != null) {
            return right7;
          }
        }
        return null;
      },
      MemberExpression(node, initialScope) {
        if (node.property.type === "PrivateIdentifier") {
          return null;
        }
        const object = getStaticValueR(node.object, initialScope);
        if (object != null) {
          if (object.value == null && (object.optional || node.optional)) {
            return { value: void 0, optional: true };
          }
          const property = getStaticPropertyNameValue(node, initialScope);
          if (property != null) {
            if (!isGetter(object.value, property.value)) {
              return { value: object.value[property.value] };
            }
            for (const [classFn, allowed] of getterAllowed) {
              if (object.value instanceof classFn && allowed.has(property.value)) {
                return { value: object.value[property.value] };
              }
            }
          }
        }
        return null;
      },
      ChainExpression(node, initialScope) {
        const expression = getStaticValueR(node.expression, initialScope);
        if (expression != null) {
          return { value: expression.value };
        }
        return null;
      },
      NewExpression(node, initialScope) {
        const callee = getStaticValueR(node.callee, initialScope);
        const args = getElementValues(node.arguments, initialScope);
        if (callee != null && args != null) {
          const Func = callee.value;
          if (callAllowed.has(Func)) {
            return { value: new Func(...args) };
          }
        }
        return null;
      },
      ObjectExpression(node, initialScope) {
        const object = {};
        for (const propertyNode of node.properties) {
          if (propertyNode.type === "Property") {
            if (propertyNode.kind !== "init") {
              return null;
            }
            const key = getStaticPropertyNameValue(
              propertyNode,
              initialScope
            );
            const value = getStaticValueR(propertyNode.value, initialScope);
            if (key == null || value == null) {
              return null;
            }
            object[key.value] = value.value;
          } else if (propertyNode.type === "SpreadElement" || propertyNode.type === "ExperimentalSpreadProperty") {
            const argument = getStaticValueR(
              propertyNode.argument,
              initialScope
            );
            if (argument == null) {
              return null;
            }
            Object.assign(object, argument.value);
          } else {
            return null;
          }
        }
        return { value: object };
      },
      SequenceExpression(node, initialScope) {
        const last = node.expressions[node.expressions.length - 1];
        return getStaticValueR(last, initialScope);
      },
      TaggedTemplateExpression(node, initialScope) {
        const tag = getStaticValueR(node.tag, initialScope);
        const expressions = getElementValues(
          node.quasi.expressions,
          initialScope
        );
        if (tag != null && expressions != null) {
          const func = tag.value;
          const strings = node.quasi.quasis.map((q) => q.value.cooked);
          strings.raw = node.quasi.quasis.map((q) => q.value.raw);
          if (func === String.raw) {
            return { value: func(strings, ...expressions) };
          }
        }
        return null;
      },
      TemplateLiteral(node, initialScope) {
        const expressions = getElementValues(node.expressions, initialScope);
        if (expressions != null) {
          let value = node.quasis[0].value.cooked;
          for (let i = 0; i < expressions.length; ++i) {
            value += expressions[i];
            value += node.quasis[i + 1].value.cooked;
          }
          return { value };
        }
        return null;
      },
      UnaryExpression(node, initialScope) {
        if (node.operator === "delete") {
          return null;
        }
        if (node.operator === "void") {
          return { value: void 0 };
        }
        const arg = getStaticValueR(node.argument, initialScope);
        if (arg != null) {
          switch (node.operator) {
            case "-":
              return { value: -arg.value };
            case "+":
              return { value: +arg.value };
            case "!":
              return { value: !arg.value };
            case "~":
              return { value: ~arg.value };
            case "typeof":
              return { value: typeof arg.value };
          }
        }
        return null;
      }
    });
    function getStaticValueR(node, initialScope) {
      if (node != null && Object.hasOwnProperty.call(operations, node.type)) {
        return operations[node.type](node, initialScope);
      }
      return null;
    }
    function getStaticPropertyNameValue(node, initialScope) {
      const nameNode = node.type === "Property" ? node.key : node.property;
      if (node.computed) {
        return getStaticValueR(nameNode, initialScope);
      }
      if (nameNode.type === "Identifier") {
        return { value: nameNode.name };
      }
      if (nameNode.type === "Literal") {
        if (nameNode.bigint) {
          return { value: nameNode.bigint };
        }
        return { value: String(nameNode.value) };
      }
      return null;
    }
    function getStaticValue(node, initialScope = null) {
      try {
        return getStaticValueR(node, initialScope);
      } catch (_error) {
        return null;
      }
    }
    function getStringIfConstant(node, initialScope = null) {
      if (node && node.type === "Literal" && node.value === null) {
        if (node.regex) {
          return `/${node.regex.pattern}/${node.regex.flags}`;
        }
        if (node.bigint) {
          return node.bigint;
        }
      }
      const evaluated = getStaticValue(node, initialScope);
      return evaluated && String(evaluated.value);
    }
    function getPropertyName(node, initialScope) {
      switch (node.type) {
        case "MemberExpression":
          if (node.computed) {
            return getStringIfConstant(node.property, initialScope);
          }
          if (node.property.type === "PrivateIdentifier") {
            return null;
          }
          return node.property.name;
        case "Property":
        case "MethodDefinition":
        case "PropertyDefinition":
          if (node.computed) {
            return getStringIfConstant(node.key, initialScope);
          }
          if (node.key.type === "Literal") {
            return String(node.key.value);
          }
          if (node.key.type === "PrivateIdentifier") {
            return null;
          }
          return node.key.name;
      }
      return null;
    }
    function getFunctionNameWithKind(node, sourceCode) {
      const parent = node.parent;
      const tokens = [];
      const isObjectMethod = parent.type === "Property" && parent.value === node;
      const isClassMethod = parent.type === "MethodDefinition" && parent.value === node;
      const isClassFieldMethod = parent.type === "PropertyDefinition" && parent.value === node;
      if (isClassMethod || isClassFieldMethod) {
        if (parent.static) {
          tokens.push("static");
        }
        if (parent.key.type === "PrivateIdentifier") {
          tokens.push("private");
        }
      }
      if (node.async) {
        tokens.push("async");
      }
      if (node.generator) {
        tokens.push("generator");
      }
      if (isObjectMethod || isClassMethod) {
        if (parent.kind === "constructor") {
          return "constructor";
        }
        if (parent.kind === "get") {
          tokens.push("getter");
        } else if (parent.kind === "set") {
          tokens.push("setter");
        } else {
          tokens.push("method");
        }
      } else if (isClassFieldMethod) {
        tokens.push("method");
      } else {
        if (node.type === "ArrowFunctionExpression") {
          tokens.push("arrow");
        }
        tokens.push("function");
      }
      if (isObjectMethod || isClassMethod || isClassFieldMethod) {
        if (parent.key.type === "PrivateIdentifier") {
          tokens.push(`#${parent.key.name}`);
        } else {
          const name = getPropertyName(parent);
          if (name) {
            tokens.push(`'${name}'`);
          } else if (sourceCode) {
            const keyText = sourceCode.getText(parent.key);
            if (!keyText.includes("\n")) {
              tokens.push(`[${keyText}]`);
            }
          }
        }
      } else if (node.id) {
        tokens.push(`'${node.id.name}'`);
      } else if (parent.type === "VariableDeclarator" && parent.id && parent.id.type === "Identifier") {
        tokens.push(`'${parent.id.name}'`);
      } else if ((parent.type === "AssignmentExpression" || parent.type === "AssignmentPattern") && parent.left && parent.left.type === "Identifier") {
        tokens.push(`'${parent.left.name}'`);
      } else if (parent.type === "ExportDefaultDeclaration" && parent.declaration === node) {
        tokens.push("'default'");
      }
      return tokens.join(" ");
    }
    var typeConversionBinaryOps = Object.freeze(
      /* @__PURE__ */ new Set([
        "==",
        "!=",
        "<",
        "<=",
        ">",
        ">=",
        "<<",
        ">>",
        ">>>",
        "+",
        "-",
        "*",
        "/",
        "%",
        "|",
        "^",
        "&",
        "in"
      ])
    );
    var typeConversionUnaryOps = Object.freeze(/* @__PURE__ */ new Set(["-", "+", "!", "~"]));
    function isNode(x) {
      return x !== null && typeof x === "object" && typeof x.type === "string";
    }
    var visitor = Object.freeze(
      Object.assign(/* @__PURE__ */ Object.create(null), {
        $visit(node, options, visitorKeys) {
          const { type } = node;
          if (typeof this[type] === "function") {
            return this[type](node, options, visitorKeys);
          }
          return this.$visitChildren(node, options, visitorKeys);
        },
        $visitChildren(node, options, visitorKeys) {
          const { type } = node;
          for (const key of visitorKeys[type] || eslintVisitorKeys.getKeys(node)) {
            const value = node[key];
            if (Array.isArray(value)) {
              for (const element of value) {
                if (isNode(element) && this.$visit(element, options, visitorKeys)) {
                  return true;
                }
              }
            } else if (isNode(value) && this.$visit(value, options, visitorKeys)) {
              return true;
            }
          }
          return false;
        },
        ArrowFunctionExpression() {
          return false;
        },
        AssignmentExpression() {
          return true;
        },
        AwaitExpression() {
          return true;
        },
        BinaryExpression(node, options, visitorKeys) {
          if (options.considerImplicitTypeConversion && typeConversionBinaryOps.has(node.operator) && (node.left.type !== "Literal" || node.right.type !== "Literal")) {
            return true;
          }
          return this.$visitChildren(node, options, visitorKeys);
        },
        CallExpression() {
          return true;
        },
        FunctionExpression() {
          return false;
        },
        ImportExpression() {
          return true;
        },
        MemberExpression(node, options, visitorKeys) {
          if (options.considerGetters) {
            return true;
          }
          if (options.considerImplicitTypeConversion && node.computed && node.property.type !== "Literal") {
            return true;
          }
          return this.$visitChildren(node, options, visitorKeys);
        },
        MethodDefinition(node, options, visitorKeys) {
          if (options.considerImplicitTypeConversion && node.computed && node.key.type !== "Literal") {
            return true;
          }
          return this.$visitChildren(node, options, visitorKeys);
        },
        NewExpression() {
          return true;
        },
        Property(node, options, visitorKeys) {
          if (options.considerImplicitTypeConversion && node.computed && node.key.type !== "Literal") {
            return true;
          }
          return this.$visitChildren(node, options, visitorKeys);
        },
        PropertyDefinition(node, options, visitorKeys) {
          if (options.considerImplicitTypeConversion && node.computed && node.key.type !== "Literal") {
            return true;
          }
          return this.$visitChildren(node, options, visitorKeys);
        },
        UnaryExpression(node, options, visitorKeys) {
          if (node.operator === "delete") {
            return true;
          }
          if (options.considerImplicitTypeConversion && typeConversionUnaryOps.has(node.operator) && node.argument.type !== "Literal") {
            return true;
          }
          return this.$visitChildren(node, options, visitorKeys);
        },
        UpdateExpression() {
          return true;
        },
        YieldExpression() {
          return true;
        }
      })
    );
    function hasSideEffect(node, sourceCode, { considerGetters = false, considerImplicitTypeConversion = false } = {}) {
      return visitor.$visit(
        node,
        { considerGetters, considerImplicitTypeConversion },
        sourceCode.visitorKeys || eslintVisitorKeys.KEYS
      );
    }
    function getParentSyntaxParen(node, sourceCode) {
      const parent = node.parent;
      switch (parent.type) {
        case "CallExpression":
        case "NewExpression":
          if (parent.arguments.length === 1 && parent.arguments[0] === node) {
            return sourceCode.getTokenAfter(
              parent.callee,
              isOpeningParenToken
            );
          }
          return null;
        case "DoWhileStatement":
          if (parent.test === node) {
            return sourceCode.getTokenAfter(
              parent.body,
              isOpeningParenToken
            );
          }
          return null;
        case "IfStatement":
        case "WhileStatement":
          if (parent.test === node) {
            return sourceCode.getFirstToken(parent, 1);
          }
          return null;
        case "ImportExpression":
          if (parent.source === node) {
            return sourceCode.getFirstToken(parent, 1);
          }
          return null;
        case "SwitchStatement":
          if (parent.discriminant === node) {
            return sourceCode.getFirstToken(parent, 1);
          }
          return null;
        case "WithStatement":
          if (parent.object === node) {
            return sourceCode.getFirstToken(parent, 1);
          }
          return null;
        default:
          return null;
      }
    }
    function isParenthesized(timesOrNode, nodeOrSourceCode, optionalSourceCode) {
      let times, node, sourceCode, maybeLeftParen, maybeRightParen;
      if (typeof timesOrNode === "number") {
        times = timesOrNode | 0;
        node = nodeOrSourceCode;
        sourceCode = optionalSourceCode;
        if (!(times >= 1)) {
          throw new TypeError("'times' should be a positive integer.");
        }
      } else {
        times = 1;
        node = timesOrNode;
        sourceCode = nodeOrSourceCode;
      }
      if (node == null || // `Program` can't be parenthesized
      node.parent == null || // `CatchClause.param` can't be parenthesized, example `try {} catch (error) {}`
      node.parent.type === "CatchClause" && node.parent.param === node) {
        return false;
      }
      maybeLeftParen = maybeRightParen = node;
      do {
        maybeLeftParen = sourceCode.getTokenBefore(maybeLeftParen);
        maybeRightParen = sourceCode.getTokenAfter(maybeRightParen);
      } while (maybeLeftParen != null && maybeRightParen != null && isOpeningParenToken(maybeLeftParen) && isClosingParenToken(maybeRightParen) && // Avoid false positive such as `if (a) {}`
      maybeLeftParen !== getParentSyntaxParen(node, sourceCode) && --times > 0);
      return times === 0;
    }
    var placeholder = /\$(?:[$&`']|[1-9][0-9]?)/gu;
    var internal = /* @__PURE__ */ new WeakMap();
    function isEscaped(str, index2) {
      let escaped = false;
      for (let i = index2 - 1; i >= 0 && str.charCodeAt(i) === 92; --i) {
        escaped = !escaped;
      }
      return escaped;
    }
    function replaceS(matcher, str, replacement) {
      const chunks = [];
      let index2 = 0;
      let match3 = null;
      function replacer(key) {
        switch (key) {
          case "$$":
            return "$";
          case "$&":
            return match3[0];
          case "$`":
            return str.slice(0, match3.index);
          case "$'":
            return str.slice(match3.index + match3[0].length);
          default: {
            const i = key.slice(1);
            if (i in match3) {
              return match3[i];
            }
            return key;
          }
        }
      }
      for (match3 of matcher.execAll(str)) {
        chunks.push(str.slice(index2, match3.index));
        chunks.push(replacement.replace(placeholder, replacer));
        index2 = match3.index + match3[0].length;
      }
      chunks.push(str.slice(index2));
      return chunks.join("");
    }
    function replaceF(matcher, str, replace) {
      const chunks = [];
      let index2 = 0;
      for (const match3 of matcher.execAll(str)) {
        chunks.push(str.slice(index2, match3.index));
        chunks.push(String(replace(...match3, match3.index, match3.input)));
        index2 = match3.index + match3[0].length;
      }
      chunks.push(str.slice(index2));
      return chunks.join("");
    }
    var PatternMatcher = class {
      /**
       * Initialize this matcher.
       * @param {RegExp} pattern The pattern to match.
       * @param {{escaped:boolean}} options The options.
       */
      constructor(pattern, { escaped = false } = {}) {
        if (!(pattern instanceof RegExp)) {
          throw new TypeError("'pattern' should be a RegExp instance.");
        }
        if (!pattern.flags.includes("g")) {
          throw new Error("'pattern' should contains 'g' flag.");
        }
        internal.set(this, {
          pattern: new RegExp(pattern.source, pattern.flags),
          escaped: Boolean(escaped)
        });
      }
      /**
       * Find the pattern in a given string.
       * @param {string} str The string to find.
       * @returns {IterableIterator<RegExpExecArray>} The iterator which iterate the matched information.
       */
      *execAll(str) {
        const { pattern, escaped } = internal.get(this);
        let match3 = null;
        let lastIndex = 0;
        pattern.lastIndex = 0;
        while ((match3 = pattern.exec(str)) != null) {
          if (escaped || !isEscaped(str, match3.index)) {
            lastIndex = pattern.lastIndex;
            yield match3;
            pattern.lastIndex = lastIndex;
          }
        }
      }
      /**
       * Check whether the pattern is found in a given string.
       * @param {string} str The string to check.
       * @returns {boolean} `true` if the pattern was found in the string.
       */
      test(str) {
        const it = this.execAll(str);
        const ret = it.next();
        return !ret.done;
      }
      /**
       * Replace a given string.
       * @param {string} str The string to be replaced.
       * @param {(string|((...strs:string[])=>string))} replacer The string or function to replace. This is the same as the 2nd argument of `String.prototype.replace`.
       * @returns {string} The replaced string.
       */
      [Symbol.replace](str, replacer) {
        return typeof replacer === "function" ? replaceF(this, String(str), replacer) : replaceS(this, String(str), String(replacer));
      }
    };
    var IMPORT_TYPE = /^(?:Import|Export(?:All|Default|Named))Declaration$/u;
    var has = Function.call.bind(Object.hasOwnProperty);
    var READ = Symbol("read");
    var CALL = Symbol("call");
    var CONSTRUCT = Symbol("construct");
    var ESM = Symbol("esm");
    var requireCall = { require: { [CALL]: true } };
    function isModifiedGlobal(variable) {
      return variable == null || variable.defs.length !== 0 || variable.references.some((r) => r.isWrite());
    }
    function isPassThrough(node) {
      const parent = node.parent;
      switch (parent && parent.type) {
        case "ConditionalExpression":
          return parent.consequent === node || parent.alternate === node;
        case "LogicalExpression":
          return true;
        case "SequenceExpression":
          return parent.expressions[parent.expressions.length - 1] === node;
        case "ChainExpression":
          return true;
        default:
          return false;
      }
    }
    var ReferenceTracker = class {
      /**
       * Initialize this tracker.
       * @param {Scope} globalScope The global scope.
       * @param {object} [options] The options.
       * @param {"legacy"|"strict"} [options.mode="strict"] The mode to determine the ImportDeclaration's behavior for CJS modules.
       * @param {string[]} [options.globalObjectNames=["global","globalThis","self","window"]] The variable names for Global Object.
       */
      constructor(globalScope, {
        mode = "strict",
        globalObjectNames = ["global", "globalThis", "self", "window"]
      } = {}) {
        this.variableStack = [];
        this.globalScope = globalScope;
        this.mode = mode;
        this.globalObjectNames = globalObjectNames.slice(0);
      }
      /**
       * Iterate the references of global variables.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *iterateGlobalReferences(traceMap) {
        for (const key of Object.keys(traceMap)) {
          const nextTraceMap = traceMap[key];
          const path6 = [key];
          const variable = this.globalScope.set.get(key);
          if (isModifiedGlobal(variable)) {
            continue;
          }
          yield* this._iterateVariableReferences(
            variable,
            path6,
            nextTraceMap,
            true
          );
        }
        for (const key of this.globalObjectNames) {
          const path6 = [];
          const variable = this.globalScope.set.get(key);
          if (isModifiedGlobal(variable)) {
            continue;
          }
          yield* this._iterateVariableReferences(
            variable,
            path6,
            traceMap,
            false
          );
        }
      }
      /**
       * Iterate the references of CommonJS modules.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *iterateCjsReferences(traceMap) {
        for (const { node } of this.iterateGlobalReferences(requireCall)) {
          const key = getStringIfConstant(node.arguments[0]);
          if (key == null || !has(traceMap, key)) {
            continue;
          }
          const nextTraceMap = traceMap[key];
          const path6 = [key];
          if (nextTraceMap[READ]) {
            yield {
              node,
              path: path6,
              type: READ,
              info: nextTraceMap[READ]
            };
          }
          yield* this._iteratePropertyReferences(node, path6, nextTraceMap);
        }
      }
      /**
       * Iterate the references of ES modules.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *iterateEsmReferences(traceMap) {
        const programNode = this.globalScope.block;
        for (const node of programNode.body) {
          if (!IMPORT_TYPE.test(node.type) || node.source == null) {
            continue;
          }
          const moduleId = node.source.value;
          if (!has(traceMap, moduleId)) {
            continue;
          }
          const nextTraceMap = traceMap[moduleId];
          const path6 = [moduleId];
          if (nextTraceMap[READ]) {
            yield { node, path: path6, type: READ, info: nextTraceMap[READ] };
          }
          if (node.type === "ExportAllDeclaration") {
            for (const key of Object.keys(nextTraceMap)) {
              const exportTraceMap = nextTraceMap[key];
              if (exportTraceMap[READ]) {
                yield {
                  node,
                  path: path6.concat(key),
                  type: READ,
                  info: exportTraceMap[READ]
                };
              }
            }
          } else {
            for (const specifier of node.specifiers) {
              const esm = has(nextTraceMap, ESM);
              const it = this._iterateImportReferences(
                specifier,
                path6,
                esm ? nextTraceMap : this.mode === "legacy" ? { default: nextTraceMap, ...nextTraceMap } : { default: nextTraceMap }
              );
              if (esm) {
                yield* it;
              } else {
                for (const report of it) {
                  report.path = report.path.filter(exceptDefault);
                  if (report.path.length >= 2 || report.type !== READ) {
                    yield report;
                  }
                }
              }
            }
          }
        }
      }
      /**
       * Iterate the references for a given variable.
       * @param {Variable} variable The variable to iterate that references.
       * @param {string[]} path The current path.
       * @param {object} traceMap The trace map.
       * @param {boolean} shouldReport = The flag to report those references.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *_iterateVariableReferences(variable, path6, traceMap, shouldReport) {
        if (this.variableStack.includes(variable)) {
          return;
        }
        this.variableStack.push(variable);
        try {
          for (const reference of variable.references) {
            if (!reference.isRead()) {
              continue;
            }
            const node = reference.identifier;
            if (shouldReport && traceMap[READ]) {
              yield { node, path: path6, type: READ, info: traceMap[READ] };
            }
            yield* this._iteratePropertyReferences(node, path6, traceMap);
          }
        } finally {
          this.variableStack.pop();
        }
      }
      /**
       * Iterate the references for a given AST node.
       * @param rootNode The AST node to iterate references.
       * @param {string[]} path The current path.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      //eslint-disable-next-line complexity
      *_iteratePropertyReferences(rootNode, path6, traceMap) {
        let node = rootNode;
        while (isPassThrough(node)) {
          node = node.parent;
        }
        const parent = node.parent;
        if (parent.type === "MemberExpression") {
          if (parent.object === node) {
            const key = getPropertyName(parent);
            if (key == null || !has(traceMap, key)) {
              return;
            }
            path6 = path6.concat(key);
            const nextTraceMap = traceMap[key];
            if (nextTraceMap[READ]) {
              yield {
                node: parent,
                path: path6,
                type: READ,
                info: nextTraceMap[READ]
              };
            }
            yield* this._iteratePropertyReferences(
              parent,
              path6,
              nextTraceMap
            );
          }
          return;
        }
        if (parent.type === "CallExpression") {
          if (parent.callee === node && traceMap[CALL]) {
            yield { node: parent, path: path6, type: CALL, info: traceMap[CALL] };
          }
          return;
        }
        if (parent.type === "NewExpression") {
          if (parent.callee === node && traceMap[CONSTRUCT]) {
            yield {
              node: parent,
              path: path6,
              type: CONSTRUCT,
              info: traceMap[CONSTRUCT]
            };
          }
          return;
        }
        if (parent.type === "AssignmentExpression") {
          if (parent.right === node) {
            yield* this._iterateLhsReferences(parent.left, path6, traceMap);
            yield* this._iteratePropertyReferences(parent, path6, traceMap);
          }
          return;
        }
        if (parent.type === "AssignmentPattern") {
          if (parent.right === node) {
            yield* this._iterateLhsReferences(parent.left, path6, traceMap);
          }
          return;
        }
        if (parent.type === "VariableDeclarator") {
          if (parent.init === node) {
            yield* this._iterateLhsReferences(parent.id, path6, traceMap);
          }
        }
      }
      /**
       * Iterate the references for a given Pattern node.
       * @param {Node} patternNode The Pattern node to iterate references.
       * @param {string[]} path The current path.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *_iterateLhsReferences(patternNode, path6, traceMap) {
        if (patternNode.type === "Identifier") {
          const variable = findVariable(this.globalScope, patternNode);
          if (variable != null) {
            yield* this._iterateVariableReferences(
              variable,
              path6,
              traceMap,
              false
            );
          }
          return;
        }
        if (patternNode.type === "ObjectPattern") {
          for (const property of patternNode.properties) {
            const key = getPropertyName(property);
            if (key == null || !has(traceMap, key)) {
              continue;
            }
            const nextPath = path6.concat(key);
            const nextTraceMap = traceMap[key];
            if (nextTraceMap[READ]) {
              yield {
                node: property,
                path: nextPath,
                type: READ,
                info: nextTraceMap[READ]
              };
            }
            yield* this._iterateLhsReferences(
              property.value,
              nextPath,
              nextTraceMap
            );
          }
          return;
        }
        if (patternNode.type === "AssignmentPattern") {
          yield* this._iterateLhsReferences(patternNode.left, path6, traceMap);
        }
      }
      /**
       * Iterate the references for a given ModuleSpecifier node.
       * @param {Node} specifierNode The ModuleSpecifier node to iterate references.
       * @param {string[]} path The current path.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *_iterateImportReferences(specifierNode, path6, traceMap) {
        const type = specifierNode.type;
        if (type === "ImportSpecifier" || type === "ImportDefaultSpecifier") {
          const key = type === "ImportDefaultSpecifier" ? "default" : specifierNode.imported.name;
          if (!has(traceMap, key)) {
            return;
          }
          path6 = path6.concat(key);
          const nextTraceMap = traceMap[key];
          if (nextTraceMap[READ]) {
            yield {
              node: specifierNode,
              path: path6,
              type: READ,
              info: nextTraceMap[READ]
            };
          }
          yield* this._iterateVariableReferences(
            findVariable(this.globalScope, specifierNode.local),
            path6,
            nextTraceMap,
            false
          );
          return;
        }
        if (type === "ImportNamespaceSpecifier") {
          yield* this._iterateVariableReferences(
            findVariable(this.globalScope, specifierNode.local),
            path6,
            traceMap,
            false
          );
          return;
        }
        if (type === "ExportSpecifier") {
          const key = specifierNode.local.name;
          if (!has(traceMap, key)) {
            return;
          }
          path6 = path6.concat(key);
          const nextTraceMap = traceMap[key];
          if (nextTraceMap[READ]) {
            yield {
              node: specifierNode,
              path: path6,
              type: READ,
              info: nextTraceMap[READ]
            };
          }
        }
      }
    };
    ReferenceTracker.READ = READ;
    ReferenceTracker.CALL = CALL;
    ReferenceTracker.CONSTRUCT = CONSTRUCT;
    ReferenceTracker.ESM = ESM;
    function exceptDefault(name, index2) {
      return !(index2 === 1 && name === "default");
    }
    var index = {
      CALL,
      CONSTRUCT,
      ESM,
      findVariable,
      getFunctionHeadLocation,
      getFunctionNameWithKind,
      getInnermostScope,
      getPropertyName,
      getStaticValue,
      getStringIfConstant,
      hasSideEffect,
      isArrowToken,
      isClosingBraceToken,
      isClosingBracketToken,
      isClosingParenToken,
      isColonToken,
      isCommaToken,
      isCommentToken,
      isNotArrowToken,
      isNotClosingBraceToken,
      isNotClosingBracketToken,
      isNotClosingParenToken,
      isNotColonToken,
      isNotCommaToken,
      isNotCommentToken,
      isNotOpeningBraceToken,
      isNotOpeningBracketToken,
      isNotOpeningParenToken,
      isNotSemicolonToken,
      isOpeningBraceToken,
      isOpeningBracketToken,
      isOpeningParenToken,
      isParenthesized,
      isSemicolonToken,
      PatternMatcher,
      READ,
      ReferenceTracker
    };
    exports.CALL = CALL;
    exports.CONSTRUCT = CONSTRUCT;
    exports.ESM = ESM;
    exports.PatternMatcher = PatternMatcher;
    exports.READ = READ;
    exports.ReferenceTracker = ReferenceTracker;
    exports["default"] = index;
    exports.findVariable = findVariable;
    exports.getFunctionHeadLocation = getFunctionHeadLocation;
    exports.getFunctionNameWithKind = getFunctionNameWithKind;
    exports.getInnermostScope = getInnermostScope;
    exports.getPropertyName = getPropertyName;
    exports.getStaticValue = getStaticValue;
    exports.getStringIfConstant = getStringIfConstant;
    exports.hasSideEffect = hasSideEffect;
    exports.isArrowToken = isArrowToken;
    exports.isClosingBraceToken = isClosingBraceToken;
    exports.isClosingBracketToken = isClosingBracketToken;
    exports.isClosingParenToken = isClosingParenToken;
    exports.isColonToken = isColonToken;
    exports.isCommaToken = isCommaToken;
    exports.isCommentToken = isCommentToken;
    exports.isNotArrowToken = isNotArrowToken;
    exports.isNotClosingBraceToken = isNotClosingBraceToken;
    exports.isNotClosingBracketToken = isNotClosingBracketToken;
    exports.isNotClosingParenToken = isNotClosingParenToken;
    exports.isNotColonToken = isNotColonToken;
    exports.isNotCommaToken = isNotCommaToken;
    exports.isNotCommentToken = isNotCommentToken;
    exports.isNotOpeningBraceToken = isNotOpeningBraceToken;
    exports.isNotOpeningBracketToken = isNotOpeningBracketToken;
    exports.isNotOpeningParenToken = isNotOpeningParenToken;
    exports.isNotSemicolonToken = isNotSemicolonToken;
    exports.isOpeningBraceToken = isOpeningBraceToken;
    exports.isOpeningBracketToken = isOpeningBracketToken;
    exports.isOpeningParenToken = isOpeningParenToken;
    exports.isParenthesized = isParenthesized;
    exports.isSemicolonToken = isSemicolonToken;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ast-utils/eslint-utils/astUtilities.js
var require_astUtilities = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ast-utils/eslint-utils/astUtilities.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isParenthesized = exports.hasSideEffect = exports.getStringIfConstant = exports.getStaticValue = exports.getPropertyName = exports.getFunctionNameWithKind = exports.getFunctionHeadLocation = void 0;
    var eslintUtils = __importStar2(require_eslint_utils());
    var getFunctionHeadLocation = eslintUtils.getFunctionHeadLocation;
    exports.getFunctionHeadLocation = getFunctionHeadLocation;
    var getFunctionNameWithKind = eslintUtils.getFunctionNameWithKind;
    exports.getFunctionNameWithKind = getFunctionNameWithKind;
    var getPropertyName = eslintUtils.getPropertyName;
    exports.getPropertyName = getPropertyName;
    var getStaticValue = eslintUtils.getStaticValue;
    exports.getStaticValue = getStaticValue;
    var getStringIfConstant = eslintUtils.getStringIfConstant;
    exports.getStringIfConstant = getStringIfConstant;
    var hasSideEffect = eslintUtils.hasSideEffect;
    exports.hasSideEffect = hasSideEffect;
    var isParenthesized = eslintUtils.isParenthesized;
    exports.isParenthesized = isParenthesized;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ast-utils/eslint-utils/PatternMatcher.js
var require_PatternMatcher = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ast-utils/eslint-utils/PatternMatcher.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PatternMatcher = void 0;
    var eslintUtils = __importStar2(require_eslint_utils());
    var PatternMatcher = eslintUtils.PatternMatcher;
    exports.PatternMatcher = PatternMatcher;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ast-utils/eslint-utils/predicates.js
var require_predicates = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ast-utils/eslint-utils/predicates.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSemicolonToken = exports.isOpeningParenToken = exports.isOpeningBracketToken = exports.isOpeningBraceToken = exports.isNotSemicolonToken = exports.isNotOpeningParenToken = exports.isNotOpeningBracketToken = exports.isNotOpeningBraceToken = exports.isNotCommentToken = exports.isNotCommaToken = exports.isNotColonToken = exports.isNotClosingParenToken = exports.isNotClosingBracketToken = exports.isNotClosingBraceToken = exports.isNotArrowToken = exports.isCommentToken = exports.isCommaToken = exports.isColonToken = exports.isClosingParenToken = exports.isClosingBracketToken = exports.isClosingBraceToken = exports.isArrowToken = void 0;
    var eslintUtils = __importStar2(require_eslint_utils());
    var isArrowToken = eslintUtils.isArrowToken;
    exports.isArrowToken = isArrowToken;
    var isNotArrowToken = eslintUtils.isNotArrowToken;
    exports.isNotArrowToken = isNotArrowToken;
    var isClosingBraceToken = eslintUtils.isClosingBraceToken;
    exports.isClosingBraceToken = isClosingBraceToken;
    var isNotClosingBraceToken = eslintUtils.isNotClosingBraceToken;
    exports.isNotClosingBraceToken = isNotClosingBraceToken;
    var isClosingBracketToken = eslintUtils.isClosingBracketToken;
    exports.isClosingBracketToken = isClosingBracketToken;
    var isNotClosingBracketToken = eslintUtils.isNotClosingBracketToken;
    exports.isNotClosingBracketToken = isNotClosingBracketToken;
    var isClosingParenToken = eslintUtils.isClosingParenToken;
    exports.isClosingParenToken = isClosingParenToken;
    var isNotClosingParenToken = eslintUtils.isNotClosingParenToken;
    exports.isNotClosingParenToken = isNotClosingParenToken;
    var isColonToken = eslintUtils.isColonToken;
    exports.isColonToken = isColonToken;
    var isNotColonToken = eslintUtils.isNotColonToken;
    exports.isNotColonToken = isNotColonToken;
    var isCommaToken = eslintUtils.isCommaToken;
    exports.isCommaToken = isCommaToken;
    var isNotCommaToken = eslintUtils.isNotCommaToken;
    exports.isNotCommaToken = isNotCommaToken;
    var isCommentToken = eslintUtils.isCommentToken;
    exports.isCommentToken = isCommentToken;
    var isNotCommentToken = eslintUtils.isNotCommentToken;
    exports.isNotCommentToken = isNotCommentToken;
    var isOpeningBraceToken = eslintUtils.isOpeningBraceToken;
    exports.isOpeningBraceToken = isOpeningBraceToken;
    var isNotOpeningBraceToken = eslintUtils.isNotOpeningBraceToken;
    exports.isNotOpeningBraceToken = isNotOpeningBraceToken;
    var isOpeningBracketToken = eslintUtils.isOpeningBracketToken;
    exports.isOpeningBracketToken = isOpeningBracketToken;
    var isNotOpeningBracketToken = eslintUtils.isNotOpeningBracketToken;
    exports.isNotOpeningBracketToken = isNotOpeningBracketToken;
    var isOpeningParenToken = eslintUtils.isOpeningParenToken;
    exports.isOpeningParenToken = isOpeningParenToken;
    var isNotOpeningParenToken = eslintUtils.isNotOpeningParenToken;
    exports.isNotOpeningParenToken = isNotOpeningParenToken;
    var isSemicolonToken = eslintUtils.isSemicolonToken;
    exports.isSemicolonToken = isSemicolonToken;
    var isNotSemicolonToken = eslintUtils.isNotSemicolonToken;
    exports.isNotSemicolonToken = isNotSemicolonToken;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ast-utils/eslint-utils/ReferenceTracker.js
var require_ReferenceTracker = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ast-utils/eslint-utils/ReferenceTracker.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReferenceTracker = void 0;
    var eslintUtils = __importStar2(require_eslint_utils());
    var ReferenceTrackerREAD = eslintUtils.ReferenceTracker.READ;
    var ReferenceTrackerCALL = eslintUtils.ReferenceTracker.CALL;
    var ReferenceTrackerCONSTRUCT = eslintUtils.ReferenceTracker.CONSTRUCT;
    var ReferenceTrackerESM = eslintUtils.ReferenceTracker.ESM;
    var ReferenceTracker = eslintUtils.ReferenceTracker;
    exports.ReferenceTracker = ReferenceTracker;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ast-utils/eslint-utils/scopeAnalysis.js
var require_scopeAnalysis = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ast-utils/eslint-utils/scopeAnalysis.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getInnermostScope = exports.findVariable = void 0;
    var eslintUtils = __importStar2(require_eslint_utils());
    var findVariable = eslintUtils.findVariable;
    exports.findVariable = findVariable;
    var getInnermostScope = eslintUtils.getInnermostScope;
    exports.getInnermostScope = getInnermostScope;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ast-utils/eslint-utils/index.js
var require_eslint_utils2 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ast-utils/eslint-utils/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding2(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar2(require_astUtilities(), exports);
    __exportStar2(require_PatternMatcher(), exports);
    __exportStar2(require_predicates(), exports);
    __exportStar2(require_ReferenceTracker(), exports);
    __exportStar2(require_scopeAnalysis(), exports);
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ast-utils/helpers.js
var require_helpers = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ast-utils/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNotTokenOfTypeWithConditions = exports.isTokenOfTypeWithConditions = exports.isNodeOfTypeWithConditions = exports.isNodeOfTypes = exports.isNodeOfType = void 0;
    var isNodeOfType = (nodeType) => (node) => (node === null || node === void 0 ? void 0 : node.type) === nodeType;
    exports.isNodeOfType = isNodeOfType;
    var isNodeOfTypes = (nodeTypes) => (node) => !!node && nodeTypes.includes(node.type);
    exports.isNodeOfTypes = isNodeOfTypes;
    var isNodeOfTypeWithConditions = (nodeType, conditions) => {
      const entries = Object.entries(conditions);
      return (node) => (node === null || node === void 0 ? void 0 : node.type) === nodeType && entries.every(([key, value]) => node[key] === value);
    };
    exports.isNodeOfTypeWithConditions = isNodeOfTypeWithConditions;
    var isTokenOfTypeWithConditions = (tokenType, conditions) => {
      const entries = Object.entries(conditions);
      return (token) => (token === null || token === void 0 ? void 0 : token.type) === tokenType && entries.every(([key, value]) => token[key] === value);
    };
    exports.isTokenOfTypeWithConditions = isTokenOfTypeWithConditions;
    var isNotTokenOfTypeWithConditions = (tokenType, conditions) => (token) => !(0, exports.isTokenOfTypeWithConditions)(tokenType, conditions)(token);
    exports.isNotTokenOfTypeWithConditions = isNotTokenOfTypeWithConditions;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ast-utils/misc.js
var require_misc = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ast-utils/misc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LINEBREAK_MATCHER = exports.isTokenOnSameLine = void 0;
    var LINEBREAK_MATCHER = /\r\n|[\r\n\u2028\u2029]/;
    exports.LINEBREAK_MATCHER = LINEBREAK_MATCHER;
    function isTokenOnSameLine(left6, right7) {
      return left6.loc.end.line === right7.loc.start.line;
    }
    exports.isTokenOnSameLine = isTokenOnSameLine;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-estree.js
var require_ts_estree3 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-estree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TSESTree = exports.AST_TOKEN_TYPES = exports.AST_NODE_TYPES = void 0;
    var types_1 = require_dist();
    Object.defineProperty(exports, "AST_NODE_TYPES", { enumerable: true, get: function() {
      return types_1.AST_NODE_TYPES;
    } });
    Object.defineProperty(exports, "AST_TOKEN_TYPES", { enumerable: true, get: function() {
      return types_1.AST_TOKEN_TYPES;
    } });
    Object.defineProperty(exports, "TSESTree", { enumerable: true, get: function() {
      return types_1.TSESTree;
    } });
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ast-utils/predicates.js
var require_predicates2 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ast-utils/predicates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isVariableDeclarator = exports.isTypeKeyword = exports.isTypeAssertion = exports.isTSFunctionType = exports.isTSConstructorType = exports.isSetter = exports.isOptionalCallExpression = exports.isOptionalChainPunctuator = exports.isNotOptionalChainPunctuator = exports.isNotNonNullAssertionPunctuator = exports.isNonNullAssertionPunctuator = exports.isLogicalOrOperator = exports.isLoop = exports.isImportKeyword = exports.isIdentifier = exports.isFunctionType = exports.isFunctionOrFunctionType = exports.isFunction = exports.isClassOrTypeElement = exports.isConstructor = exports.isAwaitKeyword = exports.isAwaitExpression = void 0;
    var ts_estree_1 = require_ts_estree3();
    var helpers_1 = require_helpers();
    var isOptionalChainPunctuator = (0, helpers_1.isTokenOfTypeWithConditions)(ts_estree_1.AST_TOKEN_TYPES.Punctuator, { value: "?." });
    exports.isOptionalChainPunctuator = isOptionalChainPunctuator;
    var isNotOptionalChainPunctuator = (0, helpers_1.isNotTokenOfTypeWithConditions)(ts_estree_1.AST_TOKEN_TYPES.Punctuator, { value: "?." });
    exports.isNotOptionalChainPunctuator = isNotOptionalChainPunctuator;
    var isNonNullAssertionPunctuator = (0, helpers_1.isTokenOfTypeWithConditions)(ts_estree_1.AST_TOKEN_TYPES.Punctuator, { value: "!" });
    exports.isNonNullAssertionPunctuator = isNonNullAssertionPunctuator;
    var isNotNonNullAssertionPunctuator = (0, helpers_1.isNotTokenOfTypeWithConditions)(ts_estree_1.AST_TOKEN_TYPES.Punctuator, { value: "!" });
    exports.isNotNonNullAssertionPunctuator = isNotNonNullAssertionPunctuator;
    var isOptionalCallExpression = (0, helpers_1.isNodeOfTypeWithConditions)(
      ts_estree_1.AST_NODE_TYPES.CallExpression,
      // this flag means the call expression itself is option
      // i.e. it is foo.bar?.() and not foo?.bar()
      { optional: true }
    );
    exports.isOptionalCallExpression = isOptionalCallExpression;
    var isLogicalOrOperator = (0, helpers_1.isNodeOfTypeWithConditions)(ts_estree_1.AST_NODE_TYPES.LogicalExpression, { operator: "||" });
    exports.isLogicalOrOperator = isLogicalOrOperator;
    var isTypeAssertion = (0, helpers_1.isNodeOfTypes)([
      ts_estree_1.AST_NODE_TYPES.TSAsExpression,
      ts_estree_1.AST_NODE_TYPES.TSTypeAssertion
    ]);
    exports.isTypeAssertion = isTypeAssertion;
    var isVariableDeclarator = (0, helpers_1.isNodeOfType)(ts_estree_1.AST_NODE_TYPES.VariableDeclarator);
    exports.isVariableDeclarator = isVariableDeclarator;
    var functionTypes = [
      ts_estree_1.AST_NODE_TYPES.ArrowFunctionExpression,
      ts_estree_1.AST_NODE_TYPES.FunctionDeclaration,
      ts_estree_1.AST_NODE_TYPES.FunctionExpression
    ];
    var isFunction = (0, helpers_1.isNodeOfTypes)(functionTypes);
    exports.isFunction = isFunction;
    var functionTypeTypes = [
      ts_estree_1.AST_NODE_TYPES.TSCallSignatureDeclaration,
      ts_estree_1.AST_NODE_TYPES.TSConstructorType,
      ts_estree_1.AST_NODE_TYPES.TSConstructSignatureDeclaration,
      ts_estree_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression,
      ts_estree_1.AST_NODE_TYPES.TSFunctionType,
      ts_estree_1.AST_NODE_TYPES.TSMethodSignature
    ];
    var isFunctionType = (0, helpers_1.isNodeOfTypes)(functionTypeTypes);
    exports.isFunctionType = isFunctionType;
    var isFunctionOrFunctionType = (0, helpers_1.isNodeOfTypes)([
      ...functionTypes,
      ...functionTypeTypes
    ]);
    exports.isFunctionOrFunctionType = isFunctionOrFunctionType;
    var isTSFunctionType = (0, helpers_1.isNodeOfType)(ts_estree_1.AST_NODE_TYPES.TSFunctionType);
    exports.isTSFunctionType = isTSFunctionType;
    var isTSConstructorType = (0, helpers_1.isNodeOfType)(ts_estree_1.AST_NODE_TYPES.TSConstructorType);
    exports.isTSConstructorType = isTSConstructorType;
    var isClassOrTypeElement = (0, helpers_1.isNodeOfTypes)([
      // ClassElement
      ts_estree_1.AST_NODE_TYPES.PropertyDefinition,
      ts_estree_1.AST_NODE_TYPES.FunctionExpression,
      ts_estree_1.AST_NODE_TYPES.MethodDefinition,
      ts_estree_1.AST_NODE_TYPES.TSAbstractPropertyDefinition,
      ts_estree_1.AST_NODE_TYPES.TSAbstractMethodDefinition,
      ts_estree_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression,
      ts_estree_1.AST_NODE_TYPES.TSIndexSignature,
      // TypeElement
      ts_estree_1.AST_NODE_TYPES.TSCallSignatureDeclaration,
      ts_estree_1.AST_NODE_TYPES.TSConstructSignatureDeclaration,
      // AST_NODE_TYPES.TSIndexSignature,
      ts_estree_1.AST_NODE_TYPES.TSMethodSignature,
      ts_estree_1.AST_NODE_TYPES.TSPropertySignature
    ]);
    exports.isClassOrTypeElement = isClassOrTypeElement;
    var isConstructor = (0, helpers_1.isNodeOfTypeWithConditions)(ts_estree_1.AST_NODE_TYPES.MethodDefinition, { kind: "constructor" });
    exports.isConstructor = isConstructor;
    function isSetter(node) {
      return !!node && (node.type === ts_estree_1.AST_NODE_TYPES.MethodDefinition || node.type === ts_estree_1.AST_NODE_TYPES.Property) && node.kind === "set";
    }
    exports.isSetter = isSetter;
    var isIdentifier3 = (0, helpers_1.isNodeOfType)(ts_estree_1.AST_NODE_TYPES.Identifier);
    exports.isIdentifier = isIdentifier3;
    var isAwaitExpression = (0, helpers_1.isNodeOfType)(ts_estree_1.AST_NODE_TYPES.AwaitExpression);
    exports.isAwaitExpression = isAwaitExpression;
    var isAwaitKeyword = (0, helpers_1.isTokenOfTypeWithConditions)(ts_estree_1.AST_TOKEN_TYPES.Identifier, {
      value: "await"
    });
    exports.isAwaitKeyword = isAwaitKeyword;
    var isTypeKeyword = (0, helpers_1.isTokenOfTypeWithConditions)(ts_estree_1.AST_TOKEN_TYPES.Identifier, {
      value: "type"
    });
    exports.isTypeKeyword = isTypeKeyword;
    var isImportKeyword = (0, helpers_1.isTokenOfTypeWithConditions)(ts_estree_1.AST_TOKEN_TYPES.Keyword, {
      value: "import"
    });
    exports.isImportKeyword = isImportKeyword;
    var isLoop = (0, helpers_1.isNodeOfTypes)([
      ts_estree_1.AST_NODE_TYPES.DoWhileStatement,
      ts_estree_1.AST_NODE_TYPES.ForStatement,
      ts_estree_1.AST_NODE_TYPES.ForInStatement,
      ts_estree_1.AST_NODE_TYPES.ForOfStatement,
      ts_estree_1.AST_NODE_TYPES.WhileStatement
    ]);
    exports.isLoop = isLoop;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ast-utils/index.js
var require_ast_utils = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ast-utils/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding2(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar2(require_eslint_utils2(), exports);
    __exportStar2(require_helpers(), exports);
    __exportStar2(require_misc(), exports);
    __exportStar2(require_predicates2(), exports);
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/eslint-utils/deepMerge.js
var require_deepMerge = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/eslint-utils/deepMerge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isObjectNotArray = exports.deepMerge = void 0;
    function isObjectNotArray(obj) {
      return typeof obj === "object" && !Array.isArray(obj);
    }
    exports.isObjectNotArray = isObjectNotArray;
    function deepMerge(first = {}, second = {}) {
      const keys = new Set(Object.keys(first).concat(Object.keys(second)));
      return Array.from(keys).reduce((acc, key) => {
        const firstHasKey = key in first;
        const secondHasKey = key in second;
        const firstValue = first[key];
        const secondValue = second[key];
        if (firstHasKey && secondHasKey) {
          if (isObjectNotArray(firstValue) && isObjectNotArray(secondValue)) {
            acc[key] = deepMerge(firstValue, secondValue);
          } else {
            acc[key] = secondValue;
          }
        } else if (firstHasKey) {
          acc[key] = firstValue;
        } else {
          acc[key] = secondValue;
        }
        return acc;
      }, {});
    }
    exports.deepMerge = deepMerge;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/eslint-utils/applyDefault.js
var require_applyDefault = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/eslint-utils/applyDefault.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.applyDefault = void 0;
    var deepMerge_1 = require_deepMerge();
    function applyDefault(defaultOptions, userOptions) {
      const options = JSON.parse(JSON.stringify(defaultOptions));
      if (userOptions == null) {
        return options;
      }
      options.forEach((opt, i) => {
        if (userOptions[i] !== void 0) {
          const userOpt = userOptions[i];
          if ((0, deepMerge_1.isObjectNotArray)(userOpt) && (0, deepMerge_1.isObjectNotArray)(opt)) {
            options[i] = (0, deepMerge_1.deepMerge)(opt, userOpt);
          } else {
            options[i] = userOpt;
          }
        }
      });
      return options;
    }
    exports.applyDefault = applyDefault;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/eslint-utils/batchedSingleLineTests.js
var require_batchedSingleLineTests = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/eslint-utils/batchedSingleLineTests.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.batchedSingleLineTests = void 0;
    function batchedSingleLineTests(options) {
      const lineOffset = options.code.startsWith("\n") ? 2 : 1;
      const output = "output" in options && options.output ? options.output.trim().split("\n") : null;
      return options.code.trim().split("\n").map((code, i) => {
        const lineNum = i + lineOffset;
        const errors = "errors" in options ? options.errors.filter((e) => e.line === lineNum) : [];
        const returnVal = Object.assign(Object.assign({}, options), { code, errors: errors.map((e) => Object.assign(Object.assign({}, e), { line: 1 })) });
        if (output === null || output === void 0 ? void 0 : output[i]) {
          return Object.assign(Object.assign({}, returnVal), { output: output[i] });
        }
        return returnVal;
      });
    }
    exports.batchedSingleLineTests = batchedSingleLineTests;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/eslint-utils/getParserServices.js
var require_getParserServices = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/eslint-utils/getParserServices.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getParserServices = void 0;
    var ERROR_MESSAGE = 'You have used a rule which requires parserServices to be generated. You must therefore provide a value for the "parserOptions.project" property for @typescript-eslint/parser.';
    function getParserServices(context, allowWithoutFullTypeInformation = false) {
      var _a2, _b;
      if (!((_a2 = context.parserServices) === null || _a2 === void 0 ? void 0 : _a2.program) || !context.parserServices.esTreeNodeToTSNodeMap || !context.parserServices.tsNodeToESTreeNodeMap) {
        throw new Error(ERROR_MESSAGE);
      }
      const hasFullTypeInformation = (_b = context.parserServices.hasFullTypeInformation) !== null && _b !== void 0 ? _b : (
        /* backwards compatible */
        true
      );
      if (!hasFullTypeInformation && !allowWithoutFullTypeInformation) {
        throw new Error(ERROR_MESSAGE);
      }
      return context.parserServices;
    }
    exports.getParserServices = getParserServices;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/eslint-utils/InferTypesFromRule.js
var require_InferTypesFromRule = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/eslint-utils/InferTypesFromRule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/eslint-utils/RuleCreator.js
var require_RuleCreator = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/eslint-utils/RuleCreator.js"(exports) {
    "use strict";
    var __rest2 = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleCreator = void 0;
    var applyDefault_1 = require_applyDefault();
    function RuleCreator(urlCreator) {
      return function createNamedRule(_a2) {
        var { name, meta } = _a2, rule = __rest2(_a2, ["name", "meta"]);
        return createRule2(Object.assign({ meta: Object.assign(Object.assign({}, meta), { docs: Object.assign(Object.assign({}, meta.docs), { url: urlCreator(name) }) }) }, rule));
      };
    }
    exports.RuleCreator = RuleCreator;
    function createRule2({ create, defaultOptions, meta }) {
      return {
        create(context) {
          const optionsWithDefault = (0, applyDefault_1.applyDefault)(defaultOptions, context.options);
          return create(context, optionsWithDefault);
        },
        defaultOptions,
        meta
      };
    }
    RuleCreator.withoutDocs = createRule2;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint/RuleTester.js
var require_RuleTester = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint/RuleTester.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleTester = void 0;
    var eslint_1 = require("eslint");
    var RuleTester = class extends eslint_1.RuleTester {
    };
    exports.RuleTester = RuleTester;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/eslint-utils/rule-tester/dependencyConstraints.js
var require_dependencyConstraints = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/eslint-utils/rule-tester/dependencyConstraints.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.satisfiesAllDependencyConstraints = void 0;
    var semver = __importStar2(require_semver2());
    var BASE_SATISFIES_OPTIONS = {
      includePrerelease: true
    };
    function satisfiesDependencyConstraint(packageName, constraintIn) {
      const constraint = typeof constraintIn === "string" ? {
        range: `>=${constraintIn}`
      } : constraintIn;
      return semver.satisfies(require(`${packageName}/package.json`).version, constraint.range, typeof constraint.options === "object" ? Object.assign(Object.assign({}, BASE_SATISFIES_OPTIONS), constraint.options) : constraint.options);
    }
    function satisfiesAllDependencyConstraints(dependencyConstraints) {
      if (dependencyConstraints == null) {
        return true;
      }
      for (const [packageName, constraint] of Object.entries(dependencyConstraints)) {
        if (!satisfiesDependencyConstraint(packageName, constraint)) {
          return false;
        }
      }
      return true;
    }
    exports.satisfiesAllDependencyConstraints = satisfiesAllDependencyConstraints;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/eslint-utils/rule-tester/RuleTester.js
var require_RuleTester2 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/eslint-utils/rule-tester/RuleTester.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __rest2 = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a2;
    var _RuleTester_baseOptions;
    var _RuleTester_afterAll;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RuleTester = exports.noFormat = void 0;
    var assert_1 = __importDefault2(require("assert"));
    var package_json_1 = require("eslint/package.json");
    var path6 = __importStar2(require("path"));
    var semver = __importStar2(require_semver2());
    var BaseRuleTester = __importStar2(require_RuleTester());
    var deepMerge_1 = require_deepMerge();
    var dependencyConstraints_1 = require_dependencyConstraints();
    var TS_ESLINT_PARSER = "@typescript-eslint/parser";
    var ERROR_MESSAGE = `Do not set the parser at the test level unless you want to use a parser other than ${TS_ESLINT_PARSER}`;
    function isDescribeWithSkip(value) {
      return typeof value === "object" && value != null && "skip" in value && typeof value.skip === "function";
    }
    var RuleTester = class extends BaseRuleTester.RuleTester {
      /**
       * If you supply a value to this property, the rule tester will call this instead of using the version defined on
       * the global namespace.
       */
      static get afterAll() {
        var _b;
        return (_b = __classPrivateFieldGet2(this, _a2, "f", _RuleTester_afterAll)) !== null && _b !== void 0 ? _b : typeof afterAll === "function" ? afterAll : () => {
        };
      }
      static set afterAll(value) {
        __classPrivateFieldSet2(this, _a2, value, "f", _RuleTester_afterAll);
      }
      get staticThis() {
        return this.constructor;
      }
      constructor(baseOptions) {
        var _b, _c;
        const { dependencyConstraints: _ } = baseOptions, baseOptionsSafeForESLint = __rest2(baseOptions, ["dependencyConstraints"]);
        super(Object.assign(Object.assign({}, baseOptionsSafeForESLint), {
          parserOptions: Object.assign(Object.assign({}, baseOptions.parserOptions), { warnOnUnsupportedTypeScriptVersion: (_c = (_b = baseOptions.parserOptions) === null || _b === void 0 ? void 0 : _b.warnOnUnsupportedTypeScriptVersion) !== null && _c !== void 0 ? _c : false }),
          // as of eslint 6 you have to provide an absolute path to the parser
          // but that's not as clean to type, this saves us trying to manually enforce
          // that contributors require.resolve everything
          parser: require.resolve(baseOptions.parser)
        }));
        _RuleTester_baseOptions.set(this, void 0);
        __classPrivateFieldSet2(this, _RuleTester_baseOptions, baseOptions, "f");
        this.staticThis.afterAll(() => {
          try {
            const parser = require(TS_ESLINT_PARSER);
            parser.clearCaches();
          } catch (_b2) {
          }
        });
      }
      getFilename(testOptions) {
        var _b;
        const resolvedOptions = (0, deepMerge_1.deepMerge)(__classPrivateFieldGet2(this, _RuleTester_baseOptions, "f").parserOptions, testOptions);
        const filename = `file.ts${((_b = resolvedOptions.ecmaFeatures) === null || _b === void 0 ? void 0 : _b.jsx) ? "x" : ""}`;
        if (resolvedOptions.project) {
          return path6.join(resolvedOptions.tsconfigRootDir != null ? resolvedOptions.tsconfigRootDir : process.cwd(), filename);
        }
        return filename;
      }
      // as of eslint 6 you have to provide an absolute path to the parser
      // If you don't do that at the test level, the test will fail somewhat cryptically...
      // This is a lot more explicit
      run(name, rule, testsReadonly) {
        if (__classPrivateFieldGet2(this, _RuleTester_baseOptions, "f").dependencyConstraints && !(0, dependencyConstraints_1.satisfiesAllDependencyConstraints)(__classPrivateFieldGet2(this, _RuleTester_baseOptions, "f").dependencyConstraints)) {
          if (isDescribeWithSkip(this.staticThis.describe)) {
            this.staticThis.describe.skip(name, () => {
              this.staticThis.it("All tests skipped due to unsatisfied constructor dependency constraints", () => {
              });
            });
          } else {
            this.staticThis.describe(name, () => {
              this.staticThis.it("All tests skipped due to unsatisfied constructor dependency constraints", () => {
                assert_1.default.equal(true, true);
              });
            });
          }
          return;
        }
        const tests = {
          // standardize the valid tests as objects
          valid: testsReadonly.valid.map((test) => {
            if (typeof test === "string") {
              return {
                code: test
              };
            }
            return test;
          }),
          invalid: testsReadonly.invalid
        };
        const allTestsIterator = {
          *[Symbol.iterator]() {
            for (const test of tests.valid) {
              yield test;
            }
            for (const test of tests.invalid) {
              yield test;
            }
          }
        };
        const normalizeTest = (_b) => {
          var { dependencyConstraints: _ } = _b, test = __rest2(_b, ["dependencyConstraints"]);
          if (test.parser === TS_ESLINT_PARSER) {
            throw new Error(ERROR_MESSAGE);
          }
          if (!test.filename) {
            return Object.assign(Object.assign({}, test), { filename: this.getFilename(test.parserOptions) });
          }
          return test;
        };
        tests.valid = tests.valid.map(normalizeTest);
        tests.invalid = tests.invalid.map(normalizeTest);
        const hasOnly = (() => {
          for (const test of allTestsIterator) {
            if (test.only) {
              return true;
            }
          }
          return false;
        })();
        if (!hasOnly) {
          const hasConstraints = (() => {
            for (const test of allTestsIterator) {
              if (test.dependencyConstraints && Object.keys(test.dependencyConstraints).length > 0) {
                return true;
              }
            }
            return false;
          })();
          if (hasConstraints) {
            if (semver.satisfies(package_json_1.version, ">=7.29.0")) {
              const maybeMarkAsOnly = (test) => {
                return Object.assign(Object.assign({}, test), { only: (0, dependencyConstraints_1.satisfiesAllDependencyConstraints)(test.dependencyConstraints) });
              };
              tests.valid = tests.valid.map(maybeMarkAsOnly);
              tests.invalid = tests.invalid.map(maybeMarkAsOnly);
            } else {
              tests.valid = tests.valid.filter((test) => (0, dependencyConstraints_1.satisfiesAllDependencyConstraints)(test.dependencyConstraints));
              tests.invalid = tests.invalid.filter((test) => (0, dependencyConstraints_1.satisfiesAllDependencyConstraints)(test.dependencyConstraints));
            }
          }
        }
        super.run(name, rule, tests);
      }
    };
    exports.RuleTester = RuleTester;
    _a2 = RuleTester, _RuleTester_baseOptions = /* @__PURE__ */ new WeakMap();
    _RuleTester_afterAll = { value: void 0 };
    function noFormat(raw, ...keys) {
      return String.raw({ raw }, ...keys);
    }
    exports.noFormat = noFormat;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/eslint-utils/nullThrows.js
var require_nullThrows = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/eslint-utils/nullThrows.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NullThrowsReasons = exports.nullThrows = void 0;
    var NullThrowsReasons = {
      MissingParent: "Expected node to have a parent.",
      MissingToken: (token, thing) => `Expected to find a ${token} for the ${thing}.`
    };
    exports.NullThrowsReasons = NullThrowsReasons;
    function nullThrows(value, message) {
      if (value == null) {
        throw new Error(`Non-null Assertion Failed: ${message}`);
      }
      return value;
    }
    exports.nullThrows = nullThrows;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/eslint-utils/index.js
var require_eslint_utils3 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/eslint-utils/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding2(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar2(require_applyDefault(), exports);
    __exportStar2(require_batchedSingleLineTests(), exports);
    __exportStar2(require_getParserServices(), exports);
    __exportStar2(require_InferTypesFromRule(), exports);
    __exportStar2(require_RuleCreator(), exports);
    __exportStar2(require_RuleTester2(), exports);
    __exportStar2(require_deepMerge(), exports);
    __exportStar2(require_nullThrows(), exports);
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/json-schema.js
var require_json_schema = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/json-schema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint/AST.js
var require_AST = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint/AST.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint/CLIEngine.js
var require_CLIEngine = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint/CLIEngine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CLIEngine = void 0;
    var eslint_1 = require("eslint");
    var CLIEngine = eslint_1.CLIEngine ? class CLIEngine extends eslint_1.CLIEngine {
    } : void 0;
    exports.CLIEngine = CLIEngine;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint/ESLint.js
var require_ESLint = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint/ESLint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ESLint = void 0;
    var eslint_1 = require("eslint");
    var _ESLint = eslint_1.ESLint !== null && eslint_1.ESLint !== void 0 ? eslint_1.ESLint : function() {
      throw new Error("Attempted to construct an ESLint instance on less than ESLint v7.0.0");
    };
    var ESLint = class extends _ESLint {
    };
    exports.ESLint = ESLint;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint/Linter.js
var require_Linter = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint/Linter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Linter = void 0;
    var eslint_1 = require("eslint");
    var Linter = class extends eslint_1.Linter {
    };
    exports.Linter = Linter;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint/ParserOptions.js
var require_ParserOptions = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint/ParserOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint/Rule.js
var require_Rule = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint/Rule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/base-config.js
var require_base_config = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/base-config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TYPE_VALUE = exports.VALUE = exports.TYPE = void 0;
    exports.TYPE = Object.freeze({
      eslintImplicitGlobalSetting: "readonly",
      isTypeVariable: true,
      isValueVariable: false
    });
    exports.VALUE = Object.freeze({
      eslintImplicitGlobalSetting: "readonly",
      isTypeVariable: false,
      isValueVariable: true
    });
    exports.TYPE_VALUE = Object.freeze({
      eslintImplicitGlobalSetting: "readonly",
      isTypeVariable: true,
      isValueVariable: true
    });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/decorators.js
var require_decorators = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/decorators.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decorators = void 0;
    var base_config_1 = require_base_config();
    exports.decorators = {
      ClassMemberDecoratorContext: base_config_1.TYPE,
      DecoratorContext: base_config_1.TYPE,
      ClassDecoratorContext: base_config_1.TYPE,
      ClassMethodDecoratorContext: base_config_1.TYPE,
      ClassGetterDecoratorContext: base_config_1.TYPE,
      ClassSetterDecoratorContext: base_config_1.TYPE,
      ClassAccessorDecoratorContext: base_config_1.TYPE,
      ClassAccessorDecoratorTarget: base_config_1.TYPE,
      ClassAccessorDecoratorResult: base_config_1.TYPE,
      ClassFieldDecoratorContext: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/decorators.legacy.js
var require_decorators_legacy = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/decorators.legacy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decorators_legacy = void 0;
    var base_config_1 = require_base_config();
    exports.decorators_legacy = {
      ClassDecorator: base_config_1.TYPE,
      PropertyDecorator: base_config_1.TYPE,
      MethodDecorator: base_config_1.TYPE,
      ParameterDecorator: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/dom.js
var require_dom = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/dom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dom = void 0;
    var base_config_1 = require_base_config();
    exports.dom = {
      AddEventListenerOptions: base_config_1.TYPE,
      AesCbcParams: base_config_1.TYPE,
      AesCtrParams: base_config_1.TYPE,
      AesDerivedKeyParams: base_config_1.TYPE,
      AesGcmParams: base_config_1.TYPE,
      AesKeyAlgorithm: base_config_1.TYPE,
      AesKeyGenParams: base_config_1.TYPE,
      Algorithm: base_config_1.TYPE,
      AnalyserOptions: base_config_1.TYPE,
      AnimationEventInit: base_config_1.TYPE,
      AnimationPlaybackEventInit: base_config_1.TYPE,
      AssignedNodesOptions: base_config_1.TYPE,
      AudioBufferOptions: base_config_1.TYPE,
      AudioBufferSourceOptions: base_config_1.TYPE,
      AudioConfiguration: base_config_1.TYPE,
      AudioContextOptions: base_config_1.TYPE,
      AudioNodeOptions: base_config_1.TYPE,
      AudioProcessingEventInit: base_config_1.TYPE,
      AudioTimestamp: base_config_1.TYPE,
      AudioWorkletNodeOptions: base_config_1.TYPE,
      AuthenticationExtensionsClientInputs: base_config_1.TYPE,
      AuthenticationExtensionsClientOutputs: base_config_1.TYPE,
      AuthenticatorSelectionCriteria: base_config_1.TYPE,
      BiquadFilterOptions: base_config_1.TYPE,
      BlobEventInit: base_config_1.TYPE,
      BlobPropertyBag: base_config_1.TYPE,
      CSSStyleSheetInit: base_config_1.TYPE,
      CacheQueryOptions: base_config_1.TYPE,
      CanvasRenderingContext2DSettings: base_config_1.TYPE,
      ChannelMergerOptions: base_config_1.TYPE,
      ChannelSplitterOptions: base_config_1.TYPE,
      CheckVisibilityOptions: base_config_1.TYPE,
      ClientQueryOptions: base_config_1.TYPE,
      ClipboardEventInit: base_config_1.TYPE,
      ClipboardItemOptions: base_config_1.TYPE,
      CloseEventInit: base_config_1.TYPE,
      CompositionEventInit: base_config_1.TYPE,
      ComputedEffectTiming: base_config_1.TYPE,
      ComputedKeyframe: base_config_1.TYPE,
      ConstantSourceOptions: base_config_1.TYPE,
      ConstrainBooleanParameters: base_config_1.TYPE,
      ConstrainDOMStringParameters: base_config_1.TYPE,
      ConstrainDoubleRange: base_config_1.TYPE,
      ConstrainULongRange: base_config_1.TYPE,
      ConvolverOptions: base_config_1.TYPE,
      CredentialCreationOptions: base_config_1.TYPE,
      CredentialPropertiesOutput: base_config_1.TYPE,
      CredentialRequestOptions: base_config_1.TYPE,
      CryptoKeyPair: base_config_1.TYPE,
      CustomEventInit: base_config_1.TYPE,
      DOMMatrix2DInit: base_config_1.TYPE,
      DOMMatrixInit: base_config_1.TYPE,
      DOMPointInit: base_config_1.TYPE,
      DOMQuadInit: base_config_1.TYPE,
      DOMRectInit: base_config_1.TYPE,
      DelayOptions: base_config_1.TYPE,
      DeviceMotionEventAccelerationInit: base_config_1.TYPE,
      DeviceMotionEventInit: base_config_1.TYPE,
      DeviceMotionEventRotationRateInit: base_config_1.TYPE,
      DeviceOrientationEventInit: base_config_1.TYPE,
      DisplayMediaStreamOptions: base_config_1.TYPE,
      DocumentTimelineOptions: base_config_1.TYPE,
      DoubleRange: base_config_1.TYPE,
      DragEventInit: base_config_1.TYPE,
      DynamicsCompressorOptions: base_config_1.TYPE,
      EcKeyAlgorithm: base_config_1.TYPE,
      EcKeyGenParams: base_config_1.TYPE,
      EcKeyImportParams: base_config_1.TYPE,
      EcdhKeyDeriveParams: base_config_1.TYPE,
      EcdsaParams: base_config_1.TYPE,
      EffectTiming: base_config_1.TYPE,
      ElementCreationOptions: base_config_1.TYPE,
      ElementDefinitionOptions: base_config_1.TYPE,
      ErrorEventInit: base_config_1.TYPE,
      EventInit: base_config_1.TYPE,
      EventListenerOptions: base_config_1.TYPE,
      EventModifierInit: base_config_1.TYPE,
      EventSourceInit: base_config_1.TYPE,
      FilePropertyBag: base_config_1.TYPE,
      FileSystemFlags: base_config_1.TYPE,
      FileSystemGetDirectoryOptions: base_config_1.TYPE,
      FileSystemGetFileOptions: base_config_1.TYPE,
      FileSystemRemoveOptions: base_config_1.TYPE,
      FocusEventInit: base_config_1.TYPE,
      FocusOptions: base_config_1.TYPE,
      FontFaceDescriptors: base_config_1.TYPE,
      FontFaceSetLoadEventInit: base_config_1.TYPE,
      FormDataEventInit: base_config_1.TYPE,
      FullscreenOptions: base_config_1.TYPE,
      GainOptions: base_config_1.TYPE,
      GamepadEventInit: base_config_1.TYPE,
      GetAnimationsOptions: base_config_1.TYPE,
      GetNotificationOptions: base_config_1.TYPE,
      GetRootNodeOptions: base_config_1.TYPE,
      HashChangeEventInit: base_config_1.TYPE,
      HkdfParams: base_config_1.TYPE,
      HmacImportParams: base_config_1.TYPE,
      HmacKeyAlgorithm: base_config_1.TYPE,
      HmacKeyGenParams: base_config_1.TYPE,
      IDBDatabaseInfo: base_config_1.TYPE,
      IDBIndexParameters: base_config_1.TYPE,
      IDBObjectStoreParameters: base_config_1.TYPE,
      IDBTransactionOptions: base_config_1.TYPE,
      IDBVersionChangeEventInit: base_config_1.TYPE,
      IIRFilterOptions: base_config_1.TYPE,
      IdleRequestOptions: base_config_1.TYPE,
      ImageBitmapOptions: base_config_1.TYPE,
      ImageBitmapRenderingContextSettings: base_config_1.TYPE,
      ImageDataSettings: base_config_1.TYPE,
      ImageEncodeOptions: base_config_1.TYPE,
      ImportMeta: base_config_1.TYPE,
      InputEventInit: base_config_1.TYPE,
      IntersectionObserverEntryInit: base_config_1.TYPE,
      IntersectionObserverInit: base_config_1.TYPE,
      JsonWebKey: base_config_1.TYPE,
      KeyAlgorithm: base_config_1.TYPE,
      KeyboardEventInit: base_config_1.TYPE,
      Keyframe: base_config_1.TYPE,
      KeyframeAnimationOptions: base_config_1.TYPE,
      KeyframeEffectOptions: base_config_1.TYPE,
      LockInfo: base_config_1.TYPE,
      LockManagerSnapshot: base_config_1.TYPE,
      LockOptions: base_config_1.TYPE,
      MIDIConnectionEventInit: base_config_1.TYPE,
      MIDIMessageEventInit: base_config_1.TYPE,
      MIDIOptions: base_config_1.TYPE,
      MediaCapabilitiesDecodingInfo: base_config_1.TYPE,
      MediaCapabilitiesEncodingInfo: base_config_1.TYPE,
      MediaCapabilitiesInfo: base_config_1.TYPE,
      MediaConfiguration: base_config_1.TYPE,
      MediaDecodingConfiguration: base_config_1.TYPE,
      MediaElementAudioSourceOptions: base_config_1.TYPE,
      MediaEncodingConfiguration: base_config_1.TYPE,
      MediaEncryptedEventInit: base_config_1.TYPE,
      MediaImage: base_config_1.TYPE,
      MediaKeyMessageEventInit: base_config_1.TYPE,
      MediaKeySystemConfiguration: base_config_1.TYPE,
      MediaKeySystemMediaCapability: base_config_1.TYPE,
      MediaMetadataInit: base_config_1.TYPE,
      MediaPositionState: base_config_1.TYPE,
      MediaQueryListEventInit: base_config_1.TYPE,
      MediaRecorderOptions: base_config_1.TYPE,
      MediaSessionActionDetails: base_config_1.TYPE,
      MediaStreamAudioSourceOptions: base_config_1.TYPE,
      MediaStreamConstraints: base_config_1.TYPE,
      MediaStreamTrackEventInit: base_config_1.TYPE,
      MediaTrackCapabilities: base_config_1.TYPE,
      MediaTrackConstraintSet: base_config_1.TYPE,
      MediaTrackConstraints: base_config_1.TYPE,
      MediaTrackSettings: base_config_1.TYPE,
      MediaTrackSupportedConstraints: base_config_1.TYPE,
      MessageEventInit: base_config_1.TYPE,
      MouseEventInit: base_config_1.TYPE,
      MultiCacheQueryOptions: base_config_1.TYPE,
      MutationObserverInit: base_config_1.TYPE,
      NavigationPreloadState: base_config_1.TYPE,
      NotificationAction: base_config_1.TYPE,
      NotificationOptions: base_config_1.TYPE,
      OfflineAudioCompletionEventInit: base_config_1.TYPE,
      OfflineAudioContextOptions: base_config_1.TYPE,
      OptionalEffectTiming: base_config_1.TYPE,
      OscillatorOptions: base_config_1.TYPE,
      PageTransitionEventInit: base_config_1.TYPE,
      PannerOptions: base_config_1.TYPE,
      PaymentCurrencyAmount: base_config_1.TYPE,
      PaymentDetailsBase: base_config_1.TYPE,
      PaymentDetailsInit: base_config_1.TYPE,
      PaymentDetailsModifier: base_config_1.TYPE,
      PaymentDetailsUpdate: base_config_1.TYPE,
      PaymentItem: base_config_1.TYPE,
      PaymentMethodChangeEventInit: base_config_1.TYPE,
      PaymentMethodData: base_config_1.TYPE,
      PaymentRequestUpdateEventInit: base_config_1.TYPE,
      PaymentValidationErrors: base_config_1.TYPE,
      Pbkdf2Params: base_config_1.TYPE,
      PerformanceMarkOptions: base_config_1.TYPE,
      PerformanceMeasureOptions: base_config_1.TYPE,
      PerformanceObserverInit: base_config_1.TYPE,
      PeriodicWaveConstraints: base_config_1.TYPE,
      PeriodicWaveOptions: base_config_1.TYPE,
      PermissionDescriptor: base_config_1.TYPE,
      PictureInPictureEventInit: base_config_1.TYPE,
      PointerEventInit: base_config_1.TYPE,
      PopStateEventInit: base_config_1.TYPE,
      PositionOptions: base_config_1.TYPE,
      ProgressEventInit: base_config_1.TYPE,
      PromiseRejectionEventInit: base_config_1.TYPE,
      PropertyIndexedKeyframes: base_config_1.TYPE,
      PublicKeyCredentialCreationOptions: base_config_1.TYPE,
      PublicKeyCredentialDescriptor: base_config_1.TYPE,
      PublicKeyCredentialEntity: base_config_1.TYPE,
      PublicKeyCredentialParameters: base_config_1.TYPE,
      PublicKeyCredentialRequestOptions: base_config_1.TYPE,
      PublicKeyCredentialRpEntity: base_config_1.TYPE,
      PublicKeyCredentialUserEntity: base_config_1.TYPE,
      PushSubscriptionJSON: base_config_1.TYPE,
      PushSubscriptionOptionsInit: base_config_1.TYPE,
      QueuingStrategy: base_config_1.TYPE,
      QueuingStrategyInit: base_config_1.TYPE,
      RTCAnswerOptions: base_config_1.TYPE,
      RTCCertificateExpiration: base_config_1.TYPE,
      RTCConfiguration: base_config_1.TYPE,
      RTCDTMFToneChangeEventInit: base_config_1.TYPE,
      RTCDataChannelEventInit: base_config_1.TYPE,
      RTCDataChannelInit: base_config_1.TYPE,
      RTCDtlsFingerprint: base_config_1.TYPE,
      RTCEncodedAudioFrameMetadata: base_config_1.TYPE,
      RTCEncodedVideoFrameMetadata: base_config_1.TYPE,
      RTCErrorEventInit: base_config_1.TYPE,
      RTCErrorInit: base_config_1.TYPE,
      RTCIceCandidateInit: base_config_1.TYPE,
      RTCIceCandidatePairStats: base_config_1.TYPE,
      RTCIceServer: base_config_1.TYPE,
      RTCInboundRtpStreamStats: base_config_1.TYPE,
      RTCLocalSessionDescriptionInit: base_config_1.TYPE,
      RTCOfferAnswerOptions: base_config_1.TYPE,
      RTCOfferOptions: base_config_1.TYPE,
      RTCOutboundRtpStreamStats: base_config_1.TYPE,
      RTCPeerConnectionIceErrorEventInit: base_config_1.TYPE,
      RTCPeerConnectionIceEventInit: base_config_1.TYPE,
      RTCReceivedRtpStreamStats: base_config_1.TYPE,
      RTCRtcpParameters: base_config_1.TYPE,
      RTCRtpCapabilities: base_config_1.TYPE,
      RTCRtpCodecCapability: base_config_1.TYPE,
      RTCRtpCodecParameters: base_config_1.TYPE,
      RTCRtpCodingParameters: base_config_1.TYPE,
      RTCRtpContributingSource: base_config_1.TYPE,
      RTCRtpEncodingParameters: base_config_1.TYPE,
      RTCRtpHeaderExtensionCapability: base_config_1.TYPE,
      RTCRtpHeaderExtensionParameters: base_config_1.TYPE,
      RTCRtpParameters: base_config_1.TYPE,
      RTCRtpReceiveParameters: base_config_1.TYPE,
      RTCRtpSendParameters: base_config_1.TYPE,
      RTCRtpStreamStats: base_config_1.TYPE,
      RTCRtpSynchronizationSource: base_config_1.TYPE,
      RTCRtpTransceiverInit: base_config_1.TYPE,
      RTCSentRtpStreamStats: base_config_1.TYPE,
      RTCSessionDescriptionInit: base_config_1.TYPE,
      RTCStats: base_config_1.TYPE,
      RTCTrackEventInit: base_config_1.TYPE,
      RTCTransportStats: base_config_1.TYPE,
      ReadableStreamGetReaderOptions: base_config_1.TYPE,
      ReadableStreamReadDoneResult: base_config_1.TYPE,
      ReadableStreamReadValueResult: base_config_1.TYPE,
      ReadableWritablePair: base_config_1.TYPE,
      RegistrationOptions: base_config_1.TYPE,
      RequestInit: base_config_1.TYPE,
      ResizeObserverOptions: base_config_1.TYPE,
      ResponseInit: base_config_1.TYPE,
      RsaHashedImportParams: base_config_1.TYPE,
      RsaHashedKeyAlgorithm: base_config_1.TYPE,
      RsaHashedKeyGenParams: base_config_1.TYPE,
      RsaKeyAlgorithm: base_config_1.TYPE,
      RsaKeyGenParams: base_config_1.TYPE,
      RsaOaepParams: base_config_1.TYPE,
      RsaOtherPrimesInfo: base_config_1.TYPE,
      RsaPssParams: base_config_1.TYPE,
      SVGBoundingBoxOptions: base_config_1.TYPE,
      ScrollIntoViewOptions: base_config_1.TYPE,
      ScrollOptions: base_config_1.TYPE,
      ScrollToOptions: base_config_1.TYPE,
      SecurityPolicyViolationEventInit: base_config_1.TYPE,
      ShadowRootInit: base_config_1.TYPE,
      ShareData: base_config_1.TYPE,
      SpeechSynthesisErrorEventInit: base_config_1.TYPE,
      SpeechSynthesisEventInit: base_config_1.TYPE,
      StaticRangeInit: base_config_1.TYPE,
      StereoPannerOptions: base_config_1.TYPE,
      StorageEstimate: base_config_1.TYPE,
      StorageEventInit: base_config_1.TYPE,
      StreamPipeOptions: base_config_1.TYPE,
      StructuredSerializeOptions: base_config_1.TYPE,
      SubmitEventInit: base_config_1.TYPE,
      TextDecodeOptions: base_config_1.TYPE,
      TextDecoderOptions: base_config_1.TYPE,
      TextEncoderEncodeIntoResult: base_config_1.TYPE,
      TouchEventInit: base_config_1.TYPE,
      TouchInit: base_config_1.TYPE,
      TrackEventInit: base_config_1.TYPE,
      Transformer: base_config_1.TYPE,
      TransitionEventInit: base_config_1.TYPE,
      UIEventInit: base_config_1.TYPE,
      ULongRange: base_config_1.TYPE,
      UnderlyingByteSource: base_config_1.TYPE,
      UnderlyingDefaultSource: base_config_1.TYPE,
      UnderlyingSink: base_config_1.TYPE,
      UnderlyingSource: base_config_1.TYPE,
      ValidityStateFlags: base_config_1.TYPE,
      VideoColorSpaceInit: base_config_1.TYPE,
      VideoConfiguration: base_config_1.TYPE,
      VideoFrameCallbackMetadata: base_config_1.TYPE,
      WaveShaperOptions: base_config_1.TYPE,
      WebGLContextAttributes: base_config_1.TYPE,
      WebGLContextEventInit: base_config_1.TYPE,
      WheelEventInit: base_config_1.TYPE,
      WindowPostMessageOptions: base_config_1.TYPE,
      WorkerOptions: base_config_1.TYPE,
      WorkletOptions: base_config_1.TYPE,
      NodeFilter: base_config_1.TYPE_VALUE,
      XPathNSResolver: base_config_1.TYPE,
      ANGLE_instanced_arrays: base_config_1.TYPE,
      ARIAMixin: base_config_1.TYPE,
      AbortController: base_config_1.TYPE_VALUE,
      AbortSignalEventMap: base_config_1.TYPE,
      AbortSignal: base_config_1.TYPE_VALUE,
      AbstractRange: base_config_1.TYPE_VALUE,
      AbstractWorkerEventMap: base_config_1.TYPE,
      AbstractWorker: base_config_1.TYPE,
      AnalyserNode: base_config_1.TYPE_VALUE,
      Animatable: base_config_1.TYPE,
      AnimationEventMap: base_config_1.TYPE,
      Animation: base_config_1.TYPE_VALUE,
      AnimationEffect: base_config_1.TYPE_VALUE,
      AnimationEvent: base_config_1.TYPE_VALUE,
      AnimationFrameProvider: base_config_1.TYPE,
      AnimationPlaybackEvent: base_config_1.TYPE_VALUE,
      AnimationTimeline: base_config_1.TYPE_VALUE,
      Attr: base_config_1.TYPE_VALUE,
      AudioBuffer: base_config_1.TYPE_VALUE,
      AudioBufferSourceNode: base_config_1.TYPE_VALUE,
      AudioContext: base_config_1.TYPE_VALUE,
      AudioDestinationNode: base_config_1.TYPE_VALUE,
      AudioListener: base_config_1.TYPE_VALUE,
      AudioNode: base_config_1.TYPE_VALUE,
      AudioParam: base_config_1.TYPE_VALUE,
      AudioParamMap: base_config_1.TYPE_VALUE,
      AudioProcessingEvent: base_config_1.TYPE_VALUE,
      AudioScheduledSourceNodeEventMap: base_config_1.TYPE,
      AudioScheduledSourceNode: base_config_1.TYPE_VALUE,
      AudioWorklet: base_config_1.TYPE_VALUE,
      AudioWorkletNodeEventMap: base_config_1.TYPE,
      AudioWorkletNode: base_config_1.TYPE_VALUE,
      AuthenticatorAssertionResponse: base_config_1.TYPE_VALUE,
      AuthenticatorAttestationResponse: base_config_1.TYPE_VALUE,
      AuthenticatorResponse: base_config_1.TYPE_VALUE,
      BarProp: base_config_1.TYPE_VALUE,
      BaseAudioContextEventMap: base_config_1.TYPE,
      BaseAudioContext: base_config_1.TYPE_VALUE,
      BeforeUnloadEvent: base_config_1.TYPE_VALUE,
      BiquadFilterNode: base_config_1.TYPE_VALUE,
      Blob: base_config_1.TYPE_VALUE,
      BlobEvent: base_config_1.TYPE_VALUE,
      Body: base_config_1.TYPE,
      BroadcastChannelEventMap: base_config_1.TYPE,
      BroadcastChannel: base_config_1.TYPE_VALUE,
      ByteLengthQueuingStrategy: base_config_1.TYPE_VALUE,
      CDATASection: base_config_1.TYPE_VALUE,
      CSSAnimation: base_config_1.TYPE_VALUE,
      CSSConditionRule: base_config_1.TYPE_VALUE,
      CSSContainerRule: base_config_1.TYPE_VALUE,
      CSSCounterStyleRule: base_config_1.TYPE_VALUE,
      CSSFontFaceRule: base_config_1.TYPE_VALUE,
      CSSFontFeatureValuesRule: base_config_1.TYPE_VALUE,
      CSSFontPaletteValuesRule: base_config_1.TYPE_VALUE,
      CSSGroupingRule: base_config_1.TYPE_VALUE,
      CSSImportRule: base_config_1.TYPE_VALUE,
      CSSKeyframeRule: base_config_1.TYPE_VALUE,
      CSSKeyframesRule: base_config_1.TYPE_VALUE,
      CSSLayerBlockRule: base_config_1.TYPE_VALUE,
      CSSLayerStatementRule: base_config_1.TYPE_VALUE,
      CSSMediaRule: base_config_1.TYPE_VALUE,
      CSSNamespaceRule: base_config_1.TYPE_VALUE,
      CSSPageRule: base_config_1.TYPE_VALUE,
      CSSRule: base_config_1.TYPE_VALUE,
      CSSRuleList: base_config_1.TYPE_VALUE,
      CSSStyleDeclaration: base_config_1.TYPE_VALUE,
      CSSStyleRule: base_config_1.TYPE_VALUE,
      CSSStyleSheet: base_config_1.TYPE_VALUE,
      CSSSupportsRule: base_config_1.TYPE_VALUE,
      CSSTransition: base_config_1.TYPE_VALUE,
      Cache: base_config_1.TYPE_VALUE,
      CacheStorage: base_config_1.TYPE_VALUE,
      CanvasCaptureMediaStreamTrack: base_config_1.TYPE_VALUE,
      CanvasCompositing: base_config_1.TYPE,
      CanvasDrawImage: base_config_1.TYPE,
      CanvasDrawPath: base_config_1.TYPE,
      CanvasFillStrokeStyles: base_config_1.TYPE,
      CanvasFilters: base_config_1.TYPE,
      CanvasGradient: base_config_1.TYPE_VALUE,
      CanvasImageData: base_config_1.TYPE,
      CanvasImageSmoothing: base_config_1.TYPE,
      CanvasPath: base_config_1.TYPE,
      CanvasPathDrawingStyles: base_config_1.TYPE,
      CanvasPattern: base_config_1.TYPE_VALUE,
      CanvasRect: base_config_1.TYPE,
      CanvasRenderingContext2D: base_config_1.TYPE_VALUE,
      CanvasShadowStyles: base_config_1.TYPE,
      CanvasState: base_config_1.TYPE,
      CanvasText: base_config_1.TYPE,
      CanvasTextDrawingStyles: base_config_1.TYPE,
      CanvasTransform: base_config_1.TYPE,
      CanvasUserInterface: base_config_1.TYPE,
      ChannelMergerNode: base_config_1.TYPE_VALUE,
      ChannelSplitterNode: base_config_1.TYPE_VALUE,
      CharacterData: base_config_1.TYPE_VALUE,
      ChildNode: base_config_1.TYPE,
      ClientRect: base_config_1.TYPE,
      Clipboard: base_config_1.TYPE_VALUE,
      ClipboardEvent: base_config_1.TYPE_VALUE,
      ClipboardItem: base_config_1.TYPE_VALUE,
      CloseEvent: base_config_1.TYPE_VALUE,
      Comment: base_config_1.TYPE_VALUE,
      CompositionEvent: base_config_1.TYPE_VALUE,
      ConstantSourceNode: base_config_1.TYPE_VALUE,
      ConvolverNode: base_config_1.TYPE_VALUE,
      CountQueuingStrategy: base_config_1.TYPE_VALUE,
      Credential: base_config_1.TYPE_VALUE,
      CredentialsContainer: base_config_1.TYPE_VALUE,
      Crypto: base_config_1.TYPE_VALUE,
      CryptoKey: base_config_1.TYPE_VALUE,
      CustomElementRegistry: base_config_1.TYPE_VALUE,
      CustomEvent: base_config_1.TYPE_VALUE,
      DOMException: base_config_1.TYPE_VALUE,
      DOMImplementation: base_config_1.TYPE_VALUE,
      DOMMatrix: base_config_1.TYPE_VALUE,
      SVGMatrix: base_config_1.TYPE_VALUE,
      WebKitCSSMatrix: base_config_1.TYPE_VALUE,
      DOMMatrixReadOnly: base_config_1.TYPE_VALUE,
      DOMParser: base_config_1.TYPE_VALUE,
      DOMPoint: base_config_1.TYPE_VALUE,
      SVGPoint: base_config_1.TYPE_VALUE,
      DOMPointReadOnly: base_config_1.TYPE_VALUE,
      DOMQuad: base_config_1.TYPE_VALUE,
      DOMRect: base_config_1.TYPE_VALUE,
      SVGRect: base_config_1.TYPE_VALUE,
      DOMRectList: base_config_1.TYPE_VALUE,
      DOMRectReadOnly: base_config_1.TYPE_VALUE,
      DOMStringList: base_config_1.TYPE_VALUE,
      DOMStringMap: base_config_1.TYPE_VALUE,
      DOMTokenList: base_config_1.TYPE_VALUE,
      DataTransfer: base_config_1.TYPE_VALUE,
      DataTransferItem: base_config_1.TYPE_VALUE,
      DataTransferItemList: base_config_1.TYPE_VALUE,
      DelayNode: base_config_1.TYPE_VALUE,
      DeviceMotionEvent: base_config_1.TYPE_VALUE,
      DeviceMotionEventAcceleration: base_config_1.TYPE,
      DeviceMotionEventRotationRate: base_config_1.TYPE,
      DeviceOrientationEvent: base_config_1.TYPE_VALUE,
      DocumentEventMap: base_config_1.TYPE,
      Document: base_config_1.TYPE_VALUE,
      DocumentFragment: base_config_1.TYPE_VALUE,
      DocumentOrShadowRoot: base_config_1.TYPE,
      DocumentTimeline: base_config_1.TYPE_VALUE,
      DocumentType: base_config_1.TYPE_VALUE,
      DragEvent: base_config_1.TYPE_VALUE,
      DynamicsCompressorNode: base_config_1.TYPE_VALUE,
      EXT_blend_minmax: base_config_1.TYPE,
      EXT_color_buffer_float: base_config_1.TYPE,
      EXT_color_buffer_half_float: base_config_1.TYPE,
      EXT_float_blend: base_config_1.TYPE,
      EXT_frag_depth: base_config_1.TYPE,
      EXT_sRGB: base_config_1.TYPE,
      EXT_shader_texture_lod: base_config_1.TYPE,
      EXT_texture_compression_bptc: base_config_1.TYPE,
      EXT_texture_compression_rgtc: base_config_1.TYPE,
      EXT_texture_filter_anisotropic: base_config_1.TYPE,
      EXT_texture_norm16: base_config_1.TYPE,
      ElementEventMap: base_config_1.TYPE,
      Element: base_config_1.TYPE_VALUE,
      ElementCSSInlineStyle: base_config_1.TYPE,
      ElementContentEditable: base_config_1.TYPE,
      ElementInternals: base_config_1.TYPE_VALUE,
      ErrorEvent: base_config_1.TYPE_VALUE,
      Event: base_config_1.TYPE_VALUE,
      EventCounts: base_config_1.TYPE_VALUE,
      EventListener: base_config_1.TYPE,
      EventListenerObject: base_config_1.TYPE,
      EventSourceEventMap: base_config_1.TYPE,
      EventSource: base_config_1.TYPE_VALUE,
      EventTarget: base_config_1.TYPE_VALUE,
      External: base_config_1.TYPE_VALUE,
      File: base_config_1.TYPE_VALUE,
      FileList: base_config_1.TYPE_VALUE,
      FileReaderEventMap: base_config_1.TYPE,
      FileReader: base_config_1.TYPE_VALUE,
      FileSystem: base_config_1.TYPE_VALUE,
      FileSystemDirectoryEntry: base_config_1.TYPE_VALUE,
      FileSystemDirectoryHandle: base_config_1.TYPE_VALUE,
      FileSystemDirectoryReader: base_config_1.TYPE_VALUE,
      FileSystemEntry: base_config_1.TYPE_VALUE,
      FileSystemFileEntry: base_config_1.TYPE_VALUE,
      FileSystemFileHandle: base_config_1.TYPE_VALUE,
      FileSystemHandle: base_config_1.TYPE_VALUE,
      FocusEvent: base_config_1.TYPE_VALUE,
      FontFace: base_config_1.TYPE_VALUE,
      FontFaceSetEventMap: base_config_1.TYPE,
      FontFaceSet: base_config_1.TYPE_VALUE,
      FontFaceSetLoadEvent: base_config_1.TYPE_VALUE,
      FontFaceSource: base_config_1.TYPE,
      FormData: base_config_1.TYPE_VALUE,
      FormDataEvent: base_config_1.TYPE_VALUE,
      GainNode: base_config_1.TYPE_VALUE,
      Gamepad: base_config_1.TYPE_VALUE,
      GamepadButton: base_config_1.TYPE_VALUE,
      GamepadEvent: base_config_1.TYPE_VALUE,
      GamepadHapticActuator: base_config_1.TYPE_VALUE,
      GenericTransformStream: base_config_1.TYPE,
      Geolocation: base_config_1.TYPE_VALUE,
      GeolocationCoordinates: base_config_1.TYPE_VALUE,
      GeolocationPosition: base_config_1.TYPE_VALUE,
      GeolocationPositionError: base_config_1.TYPE_VALUE,
      GlobalEventHandlersEventMap: base_config_1.TYPE,
      GlobalEventHandlers: base_config_1.TYPE,
      HTMLAllCollection: base_config_1.TYPE_VALUE,
      HTMLAnchorElement: base_config_1.TYPE_VALUE,
      HTMLAreaElement: base_config_1.TYPE_VALUE,
      HTMLAudioElement: base_config_1.TYPE_VALUE,
      HTMLBRElement: base_config_1.TYPE_VALUE,
      HTMLBaseElement: base_config_1.TYPE_VALUE,
      HTMLBodyElementEventMap: base_config_1.TYPE,
      HTMLBodyElement: base_config_1.TYPE_VALUE,
      HTMLButtonElement: base_config_1.TYPE_VALUE,
      HTMLCanvasElement: base_config_1.TYPE_VALUE,
      HTMLCollectionBase: base_config_1.TYPE,
      HTMLCollection: base_config_1.TYPE_VALUE,
      HTMLCollectionOf: base_config_1.TYPE,
      HTMLDListElement: base_config_1.TYPE_VALUE,
      HTMLDataElement: base_config_1.TYPE_VALUE,
      HTMLDataListElement: base_config_1.TYPE_VALUE,
      HTMLDetailsElement: base_config_1.TYPE_VALUE,
      HTMLDialogElement: base_config_1.TYPE_VALUE,
      HTMLDirectoryElement: base_config_1.TYPE_VALUE,
      HTMLDivElement: base_config_1.TYPE_VALUE,
      HTMLDocument: base_config_1.TYPE_VALUE,
      HTMLElementEventMap: base_config_1.TYPE,
      HTMLElement: base_config_1.TYPE_VALUE,
      HTMLEmbedElement: base_config_1.TYPE_VALUE,
      HTMLFieldSetElement: base_config_1.TYPE_VALUE,
      HTMLFontElement: base_config_1.TYPE_VALUE,
      HTMLFormControlsCollection: base_config_1.TYPE_VALUE,
      HTMLFormElement: base_config_1.TYPE_VALUE,
      HTMLFrameElement: base_config_1.TYPE_VALUE,
      HTMLFrameSetElementEventMap: base_config_1.TYPE,
      HTMLFrameSetElement: base_config_1.TYPE_VALUE,
      HTMLHRElement: base_config_1.TYPE_VALUE,
      HTMLHeadElement: base_config_1.TYPE_VALUE,
      HTMLHeadingElement: base_config_1.TYPE_VALUE,
      HTMLHtmlElement: base_config_1.TYPE_VALUE,
      HTMLHyperlinkElementUtils: base_config_1.TYPE,
      HTMLIFrameElement: base_config_1.TYPE_VALUE,
      HTMLImageElement: base_config_1.TYPE_VALUE,
      HTMLInputElement: base_config_1.TYPE_VALUE,
      HTMLLIElement: base_config_1.TYPE_VALUE,
      HTMLLabelElement: base_config_1.TYPE_VALUE,
      HTMLLegendElement: base_config_1.TYPE_VALUE,
      HTMLLinkElement: base_config_1.TYPE_VALUE,
      HTMLMapElement: base_config_1.TYPE_VALUE,
      HTMLMarqueeElement: base_config_1.TYPE_VALUE,
      HTMLMediaElementEventMap: base_config_1.TYPE,
      HTMLMediaElement: base_config_1.TYPE_VALUE,
      HTMLMenuElement: base_config_1.TYPE_VALUE,
      HTMLMetaElement: base_config_1.TYPE_VALUE,
      HTMLMeterElement: base_config_1.TYPE_VALUE,
      HTMLModElement: base_config_1.TYPE_VALUE,
      HTMLOListElement: base_config_1.TYPE_VALUE,
      HTMLObjectElement: base_config_1.TYPE_VALUE,
      HTMLOptGroupElement: base_config_1.TYPE_VALUE,
      HTMLOptionElement: base_config_1.TYPE_VALUE,
      HTMLOptionsCollection: base_config_1.TYPE_VALUE,
      HTMLOrSVGElement: base_config_1.TYPE,
      HTMLOutputElement: base_config_1.TYPE_VALUE,
      HTMLParagraphElement: base_config_1.TYPE_VALUE,
      HTMLParamElement: base_config_1.TYPE_VALUE,
      HTMLPictureElement: base_config_1.TYPE_VALUE,
      HTMLPreElement: base_config_1.TYPE_VALUE,
      HTMLProgressElement: base_config_1.TYPE_VALUE,
      HTMLQuoteElement: base_config_1.TYPE_VALUE,
      HTMLScriptElement: base_config_1.TYPE_VALUE,
      HTMLSelectElement: base_config_1.TYPE_VALUE,
      HTMLSlotElement: base_config_1.TYPE_VALUE,
      HTMLSourceElement: base_config_1.TYPE_VALUE,
      HTMLSpanElement: base_config_1.TYPE_VALUE,
      HTMLStyleElement: base_config_1.TYPE_VALUE,
      HTMLTableCaptionElement: base_config_1.TYPE_VALUE,
      HTMLTableCellElement: base_config_1.TYPE_VALUE,
      HTMLTableColElement: base_config_1.TYPE_VALUE,
      HTMLTableDataCellElement: base_config_1.TYPE,
      HTMLTableElement: base_config_1.TYPE_VALUE,
      HTMLTableHeaderCellElement: base_config_1.TYPE,
      HTMLTableRowElement: base_config_1.TYPE_VALUE,
      HTMLTableSectionElement: base_config_1.TYPE_VALUE,
      HTMLTemplateElement: base_config_1.TYPE_VALUE,
      HTMLTextAreaElement: base_config_1.TYPE_VALUE,
      HTMLTimeElement: base_config_1.TYPE_VALUE,
      HTMLTitleElement: base_config_1.TYPE_VALUE,
      HTMLTrackElement: base_config_1.TYPE_VALUE,
      HTMLUListElement: base_config_1.TYPE_VALUE,
      HTMLUnknownElement: base_config_1.TYPE_VALUE,
      HTMLVideoElementEventMap: base_config_1.TYPE,
      HTMLVideoElement: base_config_1.TYPE_VALUE,
      HashChangeEvent: base_config_1.TYPE_VALUE,
      Headers: base_config_1.TYPE_VALUE,
      History: base_config_1.TYPE_VALUE,
      IDBCursor: base_config_1.TYPE_VALUE,
      IDBCursorWithValue: base_config_1.TYPE_VALUE,
      IDBDatabaseEventMap: base_config_1.TYPE,
      IDBDatabase: base_config_1.TYPE_VALUE,
      IDBFactory: base_config_1.TYPE_VALUE,
      IDBIndex: base_config_1.TYPE_VALUE,
      IDBKeyRange: base_config_1.TYPE_VALUE,
      IDBObjectStore: base_config_1.TYPE_VALUE,
      IDBOpenDBRequestEventMap: base_config_1.TYPE,
      IDBOpenDBRequest: base_config_1.TYPE_VALUE,
      IDBRequestEventMap: base_config_1.TYPE,
      IDBRequest: base_config_1.TYPE_VALUE,
      IDBTransactionEventMap: base_config_1.TYPE,
      IDBTransaction: base_config_1.TYPE_VALUE,
      IDBVersionChangeEvent: base_config_1.TYPE_VALUE,
      IIRFilterNode: base_config_1.TYPE_VALUE,
      IdleDeadline: base_config_1.TYPE_VALUE,
      ImageBitmap: base_config_1.TYPE_VALUE,
      ImageBitmapRenderingContext: base_config_1.TYPE_VALUE,
      ImageData: base_config_1.TYPE_VALUE,
      InnerHTML: base_config_1.TYPE,
      InputDeviceInfo: base_config_1.TYPE_VALUE,
      InputEvent: base_config_1.TYPE_VALUE,
      IntersectionObserver: base_config_1.TYPE_VALUE,
      IntersectionObserverEntry: base_config_1.TYPE_VALUE,
      KHR_parallel_shader_compile: base_config_1.TYPE,
      KeyboardEvent: base_config_1.TYPE_VALUE,
      KeyframeEffect: base_config_1.TYPE_VALUE,
      LinkStyle: base_config_1.TYPE,
      Location: base_config_1.TYPE_VALUE,
      Lock: base_config_1.TYPE_VALUE,
      LockManager: base_config_1.TYPE_VALUE,
      MIDIAccessEventMap: base_config_1.TYPE,
      MIDIAccess: base_config_1.TYPE_VALUE,
      MIDIConnectionEvent: base_config_1.TYPE_VALUE,
      MIDIInputEventMap: base_config_1.TYPE,
      MIDIInput: base_config_1.TYPE_VALUE,
      MIDIInputMap: base_config_1.TYPE_VALUE,
      MIDIMessageEvent: base_config_1.TYPE_VALUE,
      MIDIOutput: base_config_1.TYPE_VALUE,
      MIDIOutputMap: base_config_1.TYPE_VALUE,
      MIDIPortEventMap: base_config_1.TYPE,
      MIDIPort: base_config_1.TYPE_VALUE,
      MathMLElementEventMap: base_config_1.TYPE,
      MathMLElement: base_config_1.TYPE_VALUE,
      MediaCapabilities: base_config_1.TYPE_VALUE,
      MediaDeviceInfo: base_config_1.TYPE_VALUE,
      MediaDevicesEventMap: base_config_1.TYPE,
      MediaDevices: base_config_1.TYPE_VALUE,
      MediaElementAudioSourceNode: base_config_1.TYPE_VALUE,
      MediaEncryptedEvent: base_config_1.TYPE_VALUE,
      MediaError: base_config_1.TYPE_VALUE,
      MediaKeyMessageEvent: base_config_1.TYPE_VALUE,
      MediaKeySessionEventMap: base_config_1.TYPE,
      MediaKeySession: base_config_1.TYPE_VALUE,
      MediaKeyStatusMap: base_config_1.TYPE_VALUE,
      MediaKeySystemAccess: base_config_1.TYPE_VALUE,
      MediaKeys: base_config_1.TYPE_VALUE,
      MediaList: base_config_1.TYPE_VALUE,
      MediaMetadata: base_config_1.TYPE_VALUE,
      MediaQueryListEventMap: base_config_1.TYPE,
      MediaQueryList: base_config_1.TYPE_VALUE,
      MediaQueryListEvent: base_config_1.TYPE_VALUE,
      MediaRecorderEventMap: base_config_1.TYPE,
      MediaRecorder: base_config_1.TYPE_VALUE,
      MediaSession: base_config_1.TYPE_VALUE,
      MediaSourceEventMap: base_config_1.TYPE,
      MediaSource: base_config_1.TYPE_VALUE,
      MediaStreamEventMap: base_config_1.TYPE,
      MediaStream: base_config_1.TYPE_VALUE,
      MediaStreamAudioDestinationNode: base_config_1.TYPE_VALUE,
      MediaStreamAudioSourceNode: base_config_1.TYPE_VALUE,
      MediaStreamTrackEventMap: base_config_1.TYPE,
      MediaStreamTrack: base_config_1.TYPE_VALUE,
      MediaStreamTrackEvent: base_config_1.TYPE_VALUE,
      MessageChannel: base_config_1.TYPE_VALUE,
      MessageEvent: base_config_1.TYPE_VALUE,
      MessagePortEventMap: base_config_1.TYPE,
      MessagePort: base_config_1.TYPE_VALUE,
      MimeType: base_config_1.TYPE_VALUE,
      MimeTypeArray: base_config_1.TYPE_VALUE,
      MouseEvent: base_config_1.TYPE_VALUE,
      MutationEvent: base_config_1.TYPE_VALUE,
      MutationObserver: base_config_1.TYPE_VALUE,
      MutationRecord: base_config_1.TYPE_VALUE,
      NamedNodeMap: base_config_1.TYPE_VALUE,
      NavigationPreloadManager: base_config_1.TYPE_VALUE,
      Navigator: base_config_1.TYPE_VALUE,
      NavigatorAutomationInformation: base_config_1.TYPE,
      NavigatorConcurrentHardware: base_config_1.TYPE,
      NavigatorContentUtils: base_config_1.TYPE,
      NavigatorCookies: base_config_1.TYPE,
      NavigatorID: base_config_1.TYPE,
      NavigatorLanguage: base_config_1.TYPE,
      NavigatorLocks: base_config_1.TYPE,
      NavigatorOnLine: base_config_1.TYPE,
      NavigatorPlugins: base_config_1.TYPE,
      NavigatorStorage: base_config_1.TYPE,
      Node: base_config_1.TYPE_VALUE,
      NodeIterator: base_config_1.TYPE_VALUE,
      NodeList: base_config_1.TYPE_VALUE,
      NodeListOf: base_config_1.TYPE,
      NonDocumentTypeChildNode: base_config_1.TYPE,
      NonElementParentNode: base_config_1.TYPE,
      NotificationEventMap: base_config_1.TYPE,
      Notification: base_config_1.TYPE_VALUE,
      OES_draw_buffers_indexed: base_config_1.TYPE,
      OES_element_index_uint: base_config_1.TYPE,
      OES_fbo_render_mipmap: base_config_1.TYPE,
      OES_standard_derivatives: base_config_1.TYPE,
      OES_texture_float: base_config_1.TYPE,
      OES_texture_float_linear: base_config_1.TYPE,
      OES_texture_half_float: base_config_1.TYPE,
      OES_texture_half_float_linear: base_config_1.TYPE,
      OES_vertex_array_object: base_config_1.TYPE,
      OVR_multiview2: base_config_1.TYPE,
      OfflineAudioCompletionEvent: base_config_1.TYPE_VALUE,
      OfflineAudioContextEventMap: base_config_1.TYPE,
      OfflineAudioContext: base_config_1.TYPE_VALUE,
      OffscreenCanvasEventMap: base_config_1.TYPE,
      OffscreenCanvas: base_config_1.TYPE_VALUE,
      OffscreenCanvasRenderingContext2D: base_config_1.TYPE_VALUE,
      OscillatorNode: base_config_1.TYPE_VALUE,
      OverconstrainedError: base_config_1.TYPE_VALUE,
      PageTransitionEvent: base_config_1.TYPE_VALUE,
      PannerNode: base_config_1.TYPE_VALUE,
      ParentNode: base_config_1.TYPE,
      Path2D: base_config_1.TYPE_VALUE,
      PaymentMethodChangeEvent: base_config_1.TYPE_VALUE,
      PaymentRequestEventMap: base_config_1.TYPE,
      PaymentRequest: base_config_1.TYPE_VALUE,
      PaymentRequestUpdateEvent: base_config_1.TYPE_VALUE,
      PaymentResponse: base_config_1.TYPE_VALUE,
      PerformanceEventMap: base_config_1.TYPE,
      Performance: base_config_1.TYPE_VALUE,
      PerformanceEntry: base_config_1.TYPE_VALUE,
      PerformanceEventTiming: base_config_1.TYPE_VALUE,
      PerformanceMark: base_config_1.TYPE_VALUE,
      PerformanceMeasure: base_config_1.TYPE_VALUE,
      PerformanceNavigation: base_config_1.TYPE_VALUE,
      PerformanceNavigationTiming: base_config_1.TYPE_VALUE,
      PerformanceObserver: base_config_1.TYPE_VALUE,
      PerformanceObserverEntryList: base_config_1.TYPE_VALUE,
      PerformancePaintTiming: base_config_1.TYPE_VALUE,
      PerformanceResourceTiming: base_config_1.TYPE_VALUE,
      PerformanceServerTiming: base_config_1.TYPE_VALUE,
      PerformanceTiming: base_config_1.TYPE_VALUE,
      PeriodicWave: base_config_1.TYPE_VALUE,
      PermissionStatusEventMap: base_config_1.TYPE,
      PermissionStatus: base_config_1.TYPE_VALUE,
      Permissions: base_config_1.TYPE_VALUE,
      PictureInPictureEvent: base_config_1.TYPE_VALUE,
      PictureInPictureWindowEventMap: base_config_1.TYPE,
      PictureInPictureWindow: base_config_1.TYPE_VALUE,
      Plugin: base_config_1.TYPE_VALUE,
      PluginArray: base_config_1.TYPE_VALUE,
      PointerEvent: base_config_1.TYPE_VALUE,
      PopStateEvent: base_config_1.TYPE_VALUE,
      ProcessingInstruction: base_config_1.TYPE_VALUE,
      ProgressEvent: base_config_1.TYPE_VALUE,
      PromiseRejectionEvent: base_config_1.TYPE_VALUE,
      PublicKeyCredential: base_config_1.TYPE_VALUE,
      PushManager: base_config_1.TYPE_VALUE,
      PushSubscription: base_config_1.TYPE_VALUE,
      PushSubscriptionOptions: base_config_1.TYPE_VALUE,
      RTCCertificate: base_config_1.TYPE_VALUE,
      RTCDTMFSenderEventMap: base_config_1.TYPE,
      RTCDTMFSender: base_config_1.TYPE_VALUE,
      RTCDTMFToneChangeEvent: base_config_1.TYPE_VALUE,
      RTCDataChannelEventMap: base_config_1.TYPE,
      RTCDataChannel: base_config_1.TYPE_VALUE,
      RTCDataChannelEvent: base_config_1.TYPE_VALUE,
      RTCDtlsTransportEventMap: base_config_1.TYPE,
      RTCDtlsTransport: base_config_1.TYPE_VALUE,
      RTCEncodedAudioFrame: base_config_1.TYPE_VALUE,
      RTCEncodedVideoFrame: base_config_1.TYPE_VALUE,
      RTCError: base_config_1.TYPE_VALUE,
      RTCErrorEvent: base_config_1.TYPE_VALUE,
      RTCIceCandidate: base_config_1.TYPE_VALUE,
      RTCIceTransportEventMap: base_config_1.TYPE,
      RTCIceTransport: base_config_1.TYPE_VALUE,
      RTCPeerConnectionEventMap: base_config_1.TYPE,
      RTCPeerConnection: base_config_1.TYPE_VALUE,
      RTCPeerConnectionIceErrorEvent: base_config_1.TYPE_VALUE,
      RTCPeerConnectionIceEvent: base_config_1.TYPE_VALUE,
      RTCRtpReceiver: base_config_1.TYPE_VALUE,
      RTCRtpSender: base_config_1.TYPE_VALUE,
      RTCRtpTransceiver: base_config_1.TYPE_VALUE,
      RTCSctpTransportEventMap: base_config_1.TYPE,
      RTCSctpTransport: base_config_1.TYPE_VALUE,
      RTCSessionDescription: base_config_1.TYPE_VALUE,
      RTCStatsReport: base_config_1.TYPE_VALUE,
      RTCTrackEvent: base_config_1.TYPE_VALUE,
      RadioNodeList: base_config_1.TYPE_VALUE,
      Range: base_config_1.TYPE_VALUE,
      ReadableByteStreamController: base_config_1.TYPE_VALUE,
      ReadableStream: base_config_1.TYPE_VALUE,
      ReadableStreamBYOBReader: base_config_1.TYPE_VALUE,
      ReadableStreamBYOBRequest: base_config_1.TYPE_VALUE,
      ReadableStreamDefaultController: base_config_1.TYPE_VALUE,
      ReadableStreamDefaultReader: base_config_1.TYPE_VALUE,
      ReadableStreamGenericReader: base_config_1.TYPE,
      RemotePlaybackEventMap: base_config_1.TYPE,
      RemotePlayback: base_config_1.TYPE_VALUE,
      Request: base_config_1.TYPE_VALUE,
      ResizeObserver: base_config_1.TYPE_VALUE,
      ResizeObserverEntry: base_config_1.TYPE_VALUE,
      ResizeObserverSize: base_config_1.TYPE_VALUE,
      Response: base_config_1.TYPE_VALUE,
      SVGAElement: base_config_1.TYPE_VALUE,
      SVGAngle: base_config_1.TYPE_VALUE,
      SVGAnimateElement: base_config_1.TYPE_VALUE,
      SVGAnimateMotionElement: base_config_1.TYPE_VALUE,
      SVGAnimateTransformElement: base_config_1.TYPE_VALUE,
      SVGAnimatedAngle: base_config_1.TYPE_VALUE,
      SVGAnimatedBoolean: base_config_1.TYPE_VALUE,
      SVGAnimatedEnumeration: base_config_1.TYPE_VALUE,
      SVGAnimatedInteger: base_config_1.TYPE_VALUE,
      SVGAnimatedLength: base_config_1.TYPE_VALUE,
      SVGAnimatedLengthList: base_config_1.TYPE_VALUE,
      SVGAnimatedNumber: base_config_1.TYPE_VALUE,
      SVGAnimatedNumberList: base_config_1.TYPE_VALUE,
      SVGAnimatedPoints: base_config_1.TYPE,
      SVGAnimatedPreserveAspectRatio: base_config_1.TYPE_VALUE,
      SVGAnimatedRect: base_config_1.TYPE_VALUE,
      SVGAnimatedString: base_config_1.TYPE_VALUE,
      SVGAnimatedTransformList: base_config_1.TYPE_VALUE,
      SVGAnimationElement: base_config_1.TYPE_VALUE,
      SVGCircleElement: base_config_1.TYPE_VALUE,
      SVGClipPathElement: base_config_1.TYPE_VALUE,
      SVGComponentTransferFunctionElement: base_config_1.TYPE_VALUE,
      SVGDefsElement: base_config_1.TYPE_VALUE,
      SVGDescElement: base_config_1.TYPE_VALUE,
      SVGElementEventMap: base_config_1.TYPE,
      SVGElement: base_config_1.TYPE_VALUE,
      SVGEllipseElement: base_config_1.TYPE_VALUE,
      SVGFEBlendElement: base_config_1.TYPE_VALUE,
      SVGFEColorMatrixElement: base_config_1.TYPE_VALUE,
      SVGFEComponentTransferElement: base_config_1.TYPE_VALUE,
      SVGFECompositeElement: base_config_1.TYPE_VALUE,
      SVGFEConvolveMatrixElement: base_config_1.TYPE_VALUE,
      SVGFEDiffuseLightingElement: base_config_1.TYPE_VALUE,
      SVGFEDisplacementMapElement: base_config_1.TYPE_VALUE,
      SVGFEDistantLightElement: base_config_1.TYPE_VALUE,
      SVGFEDropShadowElement: base_config_1.TYPE_VALUE,
      SVGFEFloodElement: base_config_1.TYPE_VALUE,
      SVGFEFuncAElement: base_config_1.TYPE_VALUE,
      SVGFEFuncBElement: base_config_1.TYPE_VALUE,
      SVGFEFuncGElement: base_config_1.TYPE_VALUE,
      SVGFEFuncRElement: base_config_1.TYPE_VALUE,
      SVGFEGaussianBlurElement: base_config_1.TYPE_VALUE,
      SVGFEImageElement: base_config_1.TYPE_VALUE,
      SVGFEMergeElement: base_config_1.TYPE_VALUE,
      SVGFEMergeNodeElement: base_config_1.TYPE_VALUE,
      SVGFEMorphologyElement: base_config_1.TYPE_VALUE,
      SVGFEOffsetElement: base_config_1.TYPE_VALUE,
      SVGFEPointLightElement: base_config_1.TYPE_VALUE,
      SVGFESpecularLightingElement: base_config_1.TYPE_VALUE,
      SVGFESpotLightElement: base_config_1.TYPE_VALUE,
      SVGFETileElement: base_config_1.TYPE_VALUE,
      SVGFETurbulenceElement: base_config_1.TYPE_VALUE,
      SVGFilterElement: base_config_1.TYPE_VALUE,
      SVGFilterPrimitiveStandardAttributes: base_config_1.TYPE,
      SVGFitToViewBox: base_config_1.TYPE,
      SVGForeignObjectElement: base_config_1.TYPE_VALUE,
      SVGGElement: base_config_1.TYPE_VALUE,
      SVGGeometryElement: base_config_1.TYPE_VALUE,
      SVGGradientElement: base_config_1.TYPE_VALUE,
      SVGGraphicsElement: base_config_1.TYPE_VALUE,
      SVGImageElement: base_config_1.TYPE_VALUE,
      SVGLength: base_config_1.TYPE_VALUE,
      SVGLengthList: base_config_1.TYPE_VALUE,
      SVGLineElement: base_config_1.TYPE_VALUE,
      SVGLinearGradientElement: base_config_1.TYPE_VALUE,
      SVGMPathElement: base_config_1.TYPE_VALUE,
      SVGMarkerElement: base_config_1.TYPE_VALUE,
      SVGMaskElement: base_config_1.TYPE_VALUE,
      SVGMetadataElement: base_config_1.TYPE_VALUE,
      SVGNumber: base_config_1.TYPE_VALUE,
      SVGNumberList: base_config_1.TYPE_VALUE,
      SVGPathElement: base_config_1.TYPE_VALUE,
      SVGPatternElement: base_config_1.TYPE_VALUE,
      SVGPointList: base_config_1.TYPE_VALUE,
      SVGPolygonElement: base_config_1.TYPE_VALUE,
      SVGPolylineElement: base_config_1.TYPE_VALUE,
      SVGPreserveAspectRatio: base_config_1.TYPE_VALUE,
      SVGRadialGradientElement: base_config_1.TYPE_VALUE,
      SVGRectElement: base_config_1.TYPE_VALUE,
      SVGSVGElementEventMap: base_config_1.TYPE,
      SVGSVGElement: base_config_1.TYPE_VALUE,
      SVGScriptElement: base_config_1.TYPE_VALUE,
      SVGSetElement: base_config_1.TYPE_VALUE,
      SVGStopElement: base_config_1.TYPE_VALUE,
      SVGStringList: base_config_1.TYPE_VALUE,
      SVGStyleElement: base_config_1.TYPE_VALUE,
      SVGSwitchElement: base_config_1.TYPE_VALUE,
      SVGSymbolElement: base_config_1.TYPE_VALUE,
      SVGTSpanElement: base_config_1.TYPE_VALUE,
      SVGTests: base_config_1.TYPE,
      SVGTextContentElement: base_config_1.TYPE_VALUE,
      SVGTextElement: base_config_1.TYPE_VALUE,
      SVGTextPathElement: base_config_1.TYPE_VALUE,
      SVGTextPositioningElement: base_config_1.TYPE_VALUE,
      SVGTitleElement: base_config_1.TYPE_VALUE,
      SVGTransform: base_config_1.TYPE_VALUE,
      SVGTransformList: base_config_1.TYPE_VALUE,
      SVGURIReference: base_config_1.TYPE,
      SVGUnitTypes: base_config_1.TYPE_VALUE,
      SVGUseElement: base_config_1.TYPE_VALUE,
      SVGViewElement: base_config_1.TYPE_VALUE,
      Screen: base_config_1.TYPE_VALUE,
      ScreenOrientationEventMap: base_config_1.TYPE,
      ScreenOrientation: base_config_1.TYPE_VALUE,
      ScriptProcessorNodeEventMap: base_config_1.TYPE,
      ScriptProcessorNode: base_config_1.TYPE_VALUE,
      SecurityPolicyViolationEvent: base_config_1.TYPE_VALUE,
      Selection: base_config_1.TYPE_VALUE,
      ServiceWorkerEventMap: base_config_1.TYPE,
      ServiceWorker: base_config_1.TYPE_VALUE,
      ServiceWorkerContainerEventMap: base_config_1.TYPE,
      ServiceWorkerContainer: base_config_1.TYPE_VALUE,
      ServiceWorkerRegistrationEventMap: base_config_1.TYPE,
      ServiceWorkerRegistration: base_config_1.TYPE_VALUE,
      ShadowRootEventMap: base_config_1.TYPE,
      ShadowRoot: base_config_1.TYPE_VALUE,
      SharedWorker: base_config_1.TYPE_VALUE,
      Slottable: base_config_1.TYPE,
      SourceBufferEventMap: base_config_1.TYPE,
      SourceBuffer: base_config_1.TYPE_VALUE,
      SourceBufferListEventMap: base_config_1.TYPE,
      SourceBufferList: base_config_1.TYPE_VALUE,
      SpeechRecognitionAlternative: base_config_1.TYPE_VALUE,
      SpeechRecognitionResult: base_config_1.TYPE_VALUE,
      SpeechRecognitionResultList: base_config_1.TYPE_VALUE,
      SpeechSynthesisEventMap: base_config_1.TYPE,
      SpeechSynthesis: base_config_1.TYPE_VALUE,
      SpeechSynthesisErrorEvent: base_config_1.TYPE_VALUE,
      SpeechSynthesisEvent: base_config_1.TYPE_VALUE,
      SpeechSynthesisUtteranceEventMap: base_config_1.TYPE,
      SpeechSynthesisUtterance: base_config_1.TYPE_VALUE,
      SpeechSynthesisVoice: base_config_1.TYPE_VALUE,
      StaticRange: base_config_1.TYPE_VALUE,
      StereoPannerNode: base_config_1.TYPE_VALUE,
      Storage: base_config_1.TYPE_VALUE,
      StorageEvent: base_config_1.TYPE_VALUE,
      StorageManager: base_config_1.TYPE_VALUE,
      StyleMedia: base_config_1.TYPE,
      StyleSheet: base_config_1.TYPE_VALUE,
      StyleSheetList: base_config_1.TYPE_VALUE,
      SubmitEvent: base_config_1.TYPE_VALUE,
      SubtleCrypto: base_config_1.TYPE_VALUE,
      Text: base_config_1.TYPE_VALUE,
      TextDecoder: base_config_1.TYPE_VALUE,
      TextDecoderCommon: base_config_1.TYPE,
      TextDecoderStream: base_config_1.TYPE_VALUE,
      TextEncoder: base_config_1.TYPE_VALUE,
      TextEncoderCommon: base_config_1.TYPE,
      TextEncoderStream: base_config_1.TYPE_VALUE,
      TextMetrics: base_config_1.TYPE_VALUE,
      TextTrackEventMap: base_config_1.TYPE,
      TextTrack: base_config_1.TYPE_VALUE,
      TextTrackCueEventMap: base_config_1.TYPE,
      TextTrackCue: base_config_1.TYPE_VALUE,
      TextTrackCueList: base_config_1.TYPE_VALUE,
      TextTrackListEventMap: base_config_1.TYPE,
      TextTrackList: base_config_1.TYPE_VALUE,
      TimeRanges: base_config_1.TYPE_VALUE,
      Touch: base_config_1.TYPE_VALUE,
      TouchEvent: base_config_1.TYPE_VALUE,
      TouchList: base_config_1.TYPE_VALUE,
      TrackEvent: base_config_1.TYPE_VALUE,
      TransformStream: base_config_1.TYPE_VALUE,
      TransformStreamDefaultController: base_config_1.TYPE_VALUE,
      TransitionEvent: base_config_1.TYPE_VALUE,
      TreeWalker: base_config_1.TYPE_VALUE,
      UIEvent: base_config_1.TYPE_VALUE,
      URL: base_config_1.TYPE_VALUE,
      webkitURL: base_config_1.TYPE_VALUE,
      URLSearchParams: base_config_1.TYPE_VALUE,
      VTTCue: base_config_1.TYPE_VALUE,
      VTTRegion: base_config_1.TYPE_VALUE,
      ValidityState: base_config_1.TYPE_VALUE,
      VideoColorSpace: base_config_1.TYPE_VALUE,
      VideoPlaybackQuality: base_config_1.TYPE_VALUE,
      VisualViewportEventMap: base_config_1.TYPE,
      VisualViewport: base_config_1.TYPE_VALUE,
      WEBGL_color_buffer_float: base_config_1.TYPE,
      WEBGL_compressed_texture_astc: base_config_1.TYPE,
      WEBGL_compressed_texture_etc: base_config_1.TYPE,
      WEBGL_compressed_texture_etc1: base_config_1.TYPE,
      WEBGL_compressed_texture_s3tc: base_config_1.TYPE,
      WEBGL_compressed_texture_s3tc_srgb: base_config_1.TYPE,
      WEBGL_debug_renderer_info: base_config_1.TYPE,
      WEBGL_debug_shaders: base_config_1.TYPE,
      WEBGL_depth_texture: base_config_1.TYPE,
      WEBGL_draw_buffers: base_config_1.TYPE,
      WEBGL_lose_context: base_config_1.TYPE,
      WEBGL_multi_draw: base_config_1.TYPE,
      WaveShaperNode: base_config_1.TYPE_VALUE,
      WebGL2RenderingContext: base_config_1.TYPE_VALUE,
      WebGL2RenderingContextBase: base_config_1.TYPE,
      WebGL2RenderingContextOverloads: base_config_1.TYPE,
      WebGLActiveInfo: base_config_1.TYPE_VALUE,
      WebGLBuffer: base_config_1.TYPE_VALUE,
      WebGLContextEvent: base_config_1.TYPE_VALUE,
      WebGLFramebuffer: base_config_1.TYPE_VALUE,
      WebGLProgram: base_config_1.TYPE_VALUE,
      WebGLQuery: base_config_1.TYPE_VALUE,
      WebGLRenderbuffer: base_config_1.TYPE_VALUE,
      WebGLRenderingContext: base_config_1.TYPE_VALUE,
      WebGLRenderingContextBase: base_config_1.TYPE,
      WebGLRenderingContextOverloads: base_config_1.TYPE,
      WebGLSampler: base_config_1.TYPE_VALUE,
      WebGLShader: base_config_1.TYPE_VALUE,
      WebGLShaderPrecisionFormat: base_config_1.TYPE_VALUE,
      WebGLSync: base_config_1.TYPE_VALUE,
      WebGLTexture: base_config_1.TYPE_VALUE,
      WebGLTransformFeedback: base_config_1.TYPE_VALUE,
      WebGLUniformLocation: base_config_1.TYPE_VALUE,
      WebGLVertexArrayObject: base_config_1.TYPE_VALUE,
      WebGLVertexArrayObjectOES: base_config_1.TYPE,
      WebSocketEventMap: base_config_1.TYPE,
      WebSocket: base_config_1.TYPE_VALUE,
      WheelEvent: base_config_1.TYPE_VALUE,
      WindowEventMap: base_config_1.TYPE,
      Window: base_config_1.TYPE_VALUE,
      WindowEventHandlersEventMap: base_config_1.TYPE,
      WindowEventHandlers: base_config_1.TYPE,
      WindowLocalStorage: base_config_1.TYPE,
      WindowOrWorkerGlobalScope: base_config_1.TYPE,
      WindowSessionStorage: base_config_1.TYPE,
      WorkerEventMap: base_config_1.TYPE,
      Worker: base_config_1.TYPE_VALUE,
      Worklet: base_config_1.TYPE_VALUE,
      WritableStream: base_config_1.TYPE_VALUE,
      WritableStreamDefaultController: base_config_1.TYPE_VALUE,
      WritableStreamDefaultWriter: base_config_1.TYPE_VALUE,
      XMLDocument: base_config_1.TYPE_VALUE,
      XMLHttpRequestEventMap: base_config_1.TYPE,
      XMLHttpRequest: base_config_1.TYPE_VALUE,
      XMLHttpRequestEventTargetEventMap: base_config_1.TYPE,
      XMLHttpRequestEventTarget: base_config_1.TYPE_VALUE,
      XMLHttpRequestUpload: base_config_1.TYPE_VALUE,
      XMLSerializer: base_config_1.TYPE_VALUE,
      XPathEvaluator: base_config_1.TYPE_VALUE,
      XPathEvaluatorBase: base_config_1.TYPE,
      XPathExpression: base_config_1.TYPE_VALUE,
      XPathResult: base_config_1.TYPE_VALUE,
      XSLTProcessor: base_config_1.TYPE_VALUE,
      Console: base_config_1.TYPE,
      CSS: base_config_1.TYPE_VALUE,
      WebAssembly: base_config_1.TYPE_VALUE,
      BlobCallback: base_config_1.TYPE,
      CustomElementConstructor: base_config_1.TYPE,
      DecodeErrorCallback: base_config_1.TYPE,
      DecodeSuccessCallback: base_config_1.TYPE,
      ErrorCallback: base_config_1.TYPE,
      FileCallback: base_config_1.TYPE,
      FileSystemEntriesCallback: base_config_1.TYPE,
      FileSystemEntryCallback: base_config_1.TYPE,
      FrameRequestCallback: base_config_1.TYPE,
      FunctionStringCallback: base_config_1.TYPE,
      IdleRequestCallback: base_config_1.TYPE,
      IntersectionObserverCallback: base_config_1.TYPE,
      LockGrantedCallback: base_config_1.TYPE,
      MediaSessionActionHandler: base_config_1.TYPE,
      MutationCallback: base_config_1.TYPE,
      NotificationPermissionCallback: base_config_1.TYPE,
      OnBeforeUnloadEventHandlerNonNull: base_config_1.TYPE,
      OnErrorEventHandlerNonNull: base_config_1.TYPE,
      PerformanceObserverCallback: base_config_1.TYPE,
      PositionCallback: base_config_1.TYPE,
      PositionErrorCallback: base_config_1.TYPE,
      QueuingStrategySize: base_config_1.TYPE,
      RTCPeerConnectionErrorCallback: base_config_1.TYPE,
      RTCSessionDescriptionCallback: base_config_1.TYPE,
      RemotePlaybackAvailabilityCallback: base_config_1.TYPE,
      ResizeObserverCallback: base_config_1.TYPE,
      TransformerFlushCallback: base_config_1.TYPE,
      TransformerStartCallback: base_config_1.TYPE,
      TransformerTransformCallback: base_config_1.TYPE,
      UnderlyingSinkAbortCallback: base_config_1.TYPE,
      UnderlyingSinkCloseCallback: base_config_1.TYPE,
      UnderlyingSinkStartCallback: base_config_1.TYPE,
      UnderlyingSinkWriteCallback: base_config_1.TYPE,
      UnderlyingSourceCancelCallback: base_config_1.TYPE,
      UnderlyingSourcePullCallback: base_config_1.TYPE,
      UnderlyingSourceStartCallback: base_config_1.TYPE,
      VideoFrameRequestCallback: base_config_1.TYPE,
      VoidFunction: base_config_1.TYPE,
      HTMLElementTagNameMap: base_config_1.TYPE,
      HTMLElementDeprecatedTagNameMap: base_config_1.TYPE,
      SVGElementTagNameMap: base_config_1.TYPE,
      MathMLElementTagNameMap: base_config_1.TYPE,
      ElementTagNameMap: base_config_1.TYPE,
      AlgorithmIdentifier: base_config_1.TYPE,
      BigInteger: base_config_1.TYPE,
      BinaryData: base_config_1.TYPE,
      BlobPart: base_config_1.TYPE,
      BodyInit: base_config_1.TYPE,
      BufferSource: base_config_1.TYPE,
      COSEAlgorithmIdentifier: base_config_1.TYPE,
      CSSNumberish: base_config_1.TYPE,
      CanvasImageSource: base_config_1.TYPE,
      ClipboardItemData: base_config_1.TYPE,
      ClipboardItems: base_config_1.TYPE,
      ConstrainBoolean: base_config_1.TYPE,
      ConstrainDOMString: base_config_1.TYPE,
      ConstrainDouble: base_config_1.TYPE,
      ConstrainULong: base_config_1.TYPE,
      DOMHighResTimeStamp: base_config_1.TYPE,
      EpochTimeStamp: base_config_1.TYPE,
      EventListenerOrEventListenerObject: base_config_1.TYPE,
      Float32List: base_config_1.TYPE,
      FormDataEntryValue: base_config_1.TYPE,
      GLbitfield: base_config_1.TYPE,
      GLboolean: base_config_1.TYPE,
      GLclampf: base_config_1.TYPE,
      GLenum: base_config_1.TYPE,
      GLfloat: base_config_1.TYPE,
      GLint: base_config_1.TYPE,
      GLint64: base_config_1.TYPE,
      GLintptr: base_config_1.TYPE,
      GLsizei: base_config_1.TYPE,
      GLsizeiptr: base_config_1.TYPE,
      GLuint: base_config_1.TYPE,
      GLuint64: base_config_1.TYPE,
      HTMLOrSVGImageElement: base_config_1.TYPE,
      HTMLOrSVGScriptElement: base_config_1.TYPE,
      HashAlgorithmIdentifier: base_config_1.TYPE,
      HeadersInit: base_config_1.TYPE,
      IDBValidKey: base_config_1.TYPE,
      ImageBitmapSource: base_config_1.TYPE,
      Int32List: base_config_1.TYPE,
      LineAndPositionSetting: base_config_1.TYPE,
      MediaProvider: base_config_1.TYPE,
      MessageEventSource: base_config_1.TYPE,
      MutationRecordType: base_config_1.TYPE,
      NamedCurve: base_config_1.TYPE,
      OffscreenRenderingContext: base_config_1.TYPE,
      OnBeforeUnloadEventHandler: base_config_1.TYPE,
      OnErrorEventHandler: base_config_1.TYPE,
      PerformanceEntryList: base_config_1.TYPE,
      ReadableStreamController: base_config_1.TYPE,
      ReadableStreamReadResult: base_config_1.TYPE,
      ReadableStreamReader: base_config_1.TYPE,
      RenderingContext: base_config_1.TYPE,
      RequestInfo: base_config_1.TYPE,
      TexImageSource: base_config_1.TYPE,
      TimerHandler: base_config_1.TYPE,
      Transferable: base_config_1.TYPE,
      Uint32List: base_config_1.TYPE,
      VibratePattern: base_config_1.TYPE,
      WindowProxy: base_config_1.TYPE,
      XMLHttpRequestBodyInit: base_config_1.TYPE,
      AlignSetting: base_config_1.TYPE,
      AnimationPlayState: base_config_1.TYPE,
      AnimationReplaceState: base_config_1.TYPE,
      AppendMode: base_config_1.TYPE,
      AttestationConveyancePreference: base_config_1.TYPE,
      AudioContextLatencyCategory: base_config_1.TYPE,
      AudioContextState: base_config_1.TYPE,
      AuthenticatorAttachment: base_config_1.TYPE,
      AuthenticatorTransport: base_config_1.TYPE,
      AutoKeyword: base_config_1.TYPE,
      AutomationRate: base_config_1.TYPE,
      BinaryType: base_config_1.TYPE,
      BiquadFilterType: base_config_1.TYPE,
      CanPlayTypeResult: base_config_1.TYPE,
      CanvasDirection: base_config_1.TYPE,
      CanvasFillRule: base_config_1.TYPE,
      CanvasFontKerning: base_config_1.TYPE,
      CanvasFontStretch: base_config_1.TYPE,
      CanvasFontVariantCaps: base_config_1.TYPE,
      CanvasLineCap: base_config_1.TYPE,
      CanvasLineJoin: base_config_1.TYPE,
      CanvasTextAlign: base_config_1.TYPE,
      CanvasTextBaseline: base_config_1.TYPE,
      CanvasTextRendering: base_config_1.TYPE,
      ChannelCountMode: base_config_1.TYPE,
      ChannelInterpretation: base_config_1.TYPE,
      ClientTypes: base_config_1.TYPE,
      ColorGamut: base_config_1.TYPE,
      ColorSpaceConversion: base_config_1.TYPE,
      CompositeOperation: base_config_1.TYPE,
      CompositeOperationOrAuto: base_config_1.TYPE,
      CredentialMediationRequirement: base_config_1.TYPE,
      DOMParserSupportedType: base_config_1.TYPE,
      DirectionSetting: base_config_1.TYPE,
      DisplayCaptureSurfaceType: base_config_1.TYPE,
      DistanceModelType: base_config_1.TYPE,
      DocumentReadyState: base_config_1.TYPE,
      DocumentVisibilityState: base_config_1.TYPE,
      EndOfStreamError: base_config_1.TYPE,
      EndingType: base_config_1.TYPE,
      FileSystemHandleKind: base_config_1.TYPE,
      FillMode: base_config_1.TYPE,
      FontDisplay: base_config_1.TYPE,
      FontFaceLoadStatus: base_config_1.TYPE,
      FontFaceSetLoadStatus: base_config_1.TYPE,
      FullscreenNavigationUI: base_config_1.TYPE,
      GamepadHapticActuatorType: base_config_1.TYPE,
      GamepadMappingType: base_config_1.TYPE,
      GlobalCompositeOperation: base_config_1.TYPE,
      HdrMetadataType: base_config_1.TYPE,
      IDBCursorDirection: base_config_1.TYPE,
      IDBRequestReadyState: base_config_1.TYPE,
      IDBTransactionDurability: base_config_1.TYPE,
      IDBTransactionMode: base_config_1.TYPE,
      ImageOrientation: base_config_1.TYPE,
      ImageSmoothingQuality: base_config_1.TYPE,
      InsertPosition: base_config_1.TYPE,
      IterationCompositeOperation: base_config_1.TYPE,
      KeyFormat: base_config_1.TYPE,
      KeyType: base_config_1.TYPE,
      KeyUsage: base_config_1.TYPE,
      LineAlignSetting: base_config_1.TYPE,
      LockMode: base_config_1.TYPE,
      MIDIPortConnectionState: base_config_1.TYPE,
      MIDIPortDeviceState: base_config_1.TYPE,
      MIDIPortType: base_config_1.TYPE,
      MediaDecodingType: base_config_1.TYPE,
      MediaDeviceKind: base_config_1.TYPE,
      MediaEncodingType: base_config_1.TYPE,
      MediaKeyMessageType: base_config_1.TYPE,
      MediaKeySessionClosedReason: base_config_1.TYPE,
      MediaKeySessionType: base_config_1.TYPE,
      MediaKeyStatus: base_config_1.TYPE,
      MediaKeysRequirement: base_config_1.TYPE,
      MediaSessionAction: base_config_1.TYPE,
      MediaSessionPlaybackState: base_config_1.TYPE,
      MediaStreamTrackState: base_config_1.TYPE,
      NavigationTimingType: base_config_1.TYPE,
      NotificationDirection: base_config_1.TYPE,
      NotificationPermission: base_config_1.TYPE,
      OffscreenRenderingContextId: base_config_1.TYPE,
      OrientationLockType: base_config_1.TYPE,
      OrientationType: base_config_1.TYPE,
      OscillatorType: base_config_1.TYPE,
      OverSampleType: base_config_1.TYPE,
      PanningModelType: base_config_1.TYPE,
      PaymentComplete: base_config_1.TYPE,
      PermissionName: base_config_1.TYPE,
      PermissionState: base_config_1.TYPE,
      PlaybackDirection: base_config_1.TYPE,
      PositionAlignSetting: base_config_1.TYPE,
      PredefinedColorSpace: base_config_1.TYPE,
      PremultiplyAlpha: base_config_1.TYPE,
      PresentationStyle: base_config_1.TYPE,
      PublicKeyCredentialType: base_config_1.TYPE,
      PushEncryptionKeyName: base_config_1.TYPE,
      RTCBundlePolicy: base_config_1.TYPE,
      RTCDataChannelState: base_config_1.TYPE,
      RTCDegradationPreference: base_config_1.TYPE,
      RTCDtlsTransportState: base_config_1.TYPE,
      RTCEncodedVideoFrameType: base_config_1.TYPE,
      RTCErrorDetailType: base_config_1.TYPE,
      RTCIceCandidateType: base_config_1.TYPE,
      RTCIceComponent: base_config_1.TYPE,
      RTCIceConnectionState: base_config_1.TYPE,
      RTCIceGathererState: base_config_1.TYPE,
      RTCIceGatheringState: base_config_1.TYPE,
      RTCIceProtocol: base_config_1.TYPE,
      RTCIceTcpCandidateType: base_config_1.TYPE,
      RTCIceTransportPolicy: base_config_1.TYPE,
      RTCIceTransportState: base_config_1.TYPE,
      RTCPeerConnectionState: base_config_1.TYPE,
      RTCPriorityType: base_config_1.TYPE,
      RTCRtcpMuxPolicy: base_config_1.TYPE,
      RTCRtpTransceiverDirection: base_config_1.TYPE,
      RTCSctpTransportState: base_config_1.TYPE,
      RTCSdpType: base_config_1.TYPE,
      RTCSignalingState: base_config_1.TYPE,
      RTCStatsIceCandidatePairState: base_config_1.TYPE,
      RTCStatsType: base_config_1.TYPE,
      ReadableStreamReaderMode: base_config_1.TYPE,
      ReadableStreamType: base_config_1.TYPE,
      ReadyState: base_config_1.TYPE,
      RecordingState: base_config_1.TYPE,
      ReferrerPolicy: base_config_1.TYPE,
      RemotePlaybackState: base_config_1.TYPE,
      RequestCache: base_config_1.TYPE,
      RequestCredentials: base_config_1.TYPE,
      RequestDestination: base_config_1.TYPE,
      RequestMode: base_config_1.TYPE,
      RequestRedirect: base_config_1.TYPE,
      ResidentKeyRequirement: base_config_1.TYPE,
      ResizeObserverBoxOptions: base_config_1.TYPE,
      ResizeQuality: base_config_1.TYPE,
      ResponseType: base_config_1.TYPE,
      ScrollBehavior: base_config_1.TYPE,
      ScrollLogicalPosition: base_config_1.TYPE,
      ScrollRestoration: base_config_1.TYPE,
      ScrollSetting: base_config_1.TYPE,
      SecurityPolicyViolationEventDisposition: base_config_1.TYPE,
      SelectionMode: base_config_1.TYPE,
      ServiceWorkerState: base_config_1.TYPE,
      ServiceWorkerUpdateViaCache: base_config_1.TYPE,
      ShadowRootMode: base_config_1.TYPE,
      SlotAssignmentMode: base_config_1.TYPE,
      SpeechSynthesisErrorCode: base_config_1.TYPE,
      TextTrackKind: base_config_1.TYPE,
      TextTrackMode: base_config_1.TYPE,
      TouchType: base_config_1.TYPE,
      TransferFunction: base_config_1.TYPE,
      UserVerificationRequirement: base_config_1.TYPE,
      VideoColorPrimaries: base_config_1.TYPE,
      VideoFacingModeEnum: base_config_1.TYPE,
      VideoMatrixCoefficients: base_config_1.TYPE,
      VideoTransferCharacteristics: base_config_1.TYPE,
      WebGLPowerPreference: base_config_1.TYPE,
      WorkerType: base_config_1.TYPE,
      XMLHttpRequestResponseType: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/dom.iterable.js
var require_dom_iterable = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/dom.iterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dom_iterable = void 0;
    var base_config_1 = require_base_config();
    exports.dom_iterable = {
      AudioParam: base_config_1.TYPE,
      AudioParamMap: base_config_1.TYPE,
      BaseAudioContext: base_config_1.TYPE,
      CSSKeyframesRule: base_config_1.TYPE,
      CSSRuleList: base_config_1.TYPE,
      CSSStyleDeclaration: base_config_1.TYPE,
      Cache: base_config_1.TYPE,
      CanvasPath: base_config_1.TYPE,
      CanvasPathDrawingStyles: base_config_1.TYPE,
      DOMRectList: base_config_1.TYPE,
      DOMStringList: base_config_1.TYPE,
      DOMTokenList: base_config_1.TYPE,
      DataTransferItemList: base_config_1.TYPE,
      EventCounts: base_config_1.TYPE,
      FileList: base_config_1.TYPE,
      FontFaceSet: base_config_1.TYPE,
      FormData: base_config_1.TYPE,
      HTMLAllCollection: base_config_1.TYPE,
      HTMLCollectionBase: base_config_1.TYPE,
      HTMLCollectionOf: base_config_1.TYPE,
      HTMLFormElement: base_config_1.TYPE,
      HTMLSelectElement: base_config_1.TYPE,
      Headers: base_config_1.TYPE,
      IDBDatabase: base_config_1.TYPE,
      IDBObjectStore: base_config_1.TYPE,
      MIDIInputMap: base_config_1.TYPE,
      MIDIOutput: base_config_1.TYPE,
      MIDIOutputMap: base_config_1.TYPE,
      MediaKeyStatusMap: base_config_1.TYPE,
      MediaList: base_config_1.TYPE,
      MessageEvent: base_config_1.TYPE,
      MimeTypeArray: base_config_1.TYPE,
      NamedNodeMap: base_config_1.TYPE,
      Navigator: base_config_1.TYPE,
      NodeList: base_config_1.TYPE,
      NodeListOf: base_config_1.TYPE,
      Plugin: base_config_1.TYPE,
      PluginArray: base_config_1.TYPE,
      RTCRtpTransceiver: base_config_1.TYPE,
      RTCStatsReport: base_config_1.TYPE,
      SVGLengthList: base_config_1.TYPE,
      SVGNumberList: base_config_1.TYPE,
      SVGPointList: base_config_1.TYPE,
      SVGStringList: base_config_1.TYPE,
      SVGTransformList: base_config_1.TYPE,
      SourceBufferList: base_config_1.TYPE,
      SpeechRecognitionResult: base_config_1.TYPE,
      SpeechRecognitionResultList: base_config_1.TYPE,
      StyleSheetList: base_config_1.TYPE,
      SubtleCrypto: base_config_1.TYPE,
      TextTrackCueList: base_config_1.TYPE,
      TextTrackList: base_config_1.TYPE,
      TouchList: base_config_1.TYPE,
      URLSearchParams: base_config_1.TYPE,
      WEBGL_draw_buffers: base_config_1.TYPE,
      WEBGL_multi_draw: base_config_1.TYPE,
      WebGL2RenderingContextBase: base_config_1.TYPE,
      WebGL2RenderingContextOverloads: base_config_1.TYPE,
      WebGLRenderingContextBase: base_config_1.TYPE,
      WebGLRenderingContextOverloads: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es5.js
var require_es5 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es5 = void 0;
    var base_config_1 = require_base_config();
    var decorators_1 = require_decorators();
    var decorators_legacy_1 = require_decorators_legacy();
    exports.es5 = Object.assign(Object.assign(Object.assign({}, decorators_1.decorators), decorators_legacy_1.decorators_legacy), { Symbol: base_config_1.TYPE, PropertyKey: base_config_1.TYPE, PropertyDescriptor: base_config_1.TYPE, PropertyDescriptorMap: base_config_1.TYPE, Object: base_config_1.TYPE_VALUE, ObjectConstructor: base_config_1.TYPE, Function: base_config_1.TYPE_VALUE, FunctionConstructor: base_config_1.TYPE, ThisParameterType: base_config_1.TYPE, OmitThisParameter: base_config_1.TYPE, CallableFunction: base_config_1.TYPE, NewableFunction: base_config_1.TYPE, IArguments: base_config_1.TYPE, String: base_config_1.TYPE_VALUE, StringConstructor: base_config_1.TYPE, Boolean: base_config_1.TYPE_VALUE, BooleanConstructor: base_config_1.TYPE, Number: base_config_1.TYPE_VALUE, NumberConstructor: base_config_1.TYPE, TemplateStringsArray: base_config_1.TYPE, ImportMeta: base_config_1.TYPE, ImportCallOptions: base_config_1.TYPE, ImportAssertions: base_config_1.TYPE, Math: base_config_1.TYPE_VALUE, Date: base_config_1.TYPE_VALUE, DateConstructor: base_config_1.TYPE, RegExpMatchArray: base_config_1.TYPE, RegExpExecArray: base_config_1.TYPE, RegExp: base_config_1.TYPE_VALUE, RegExpConstructor: base_config_1.TYPE, Error: base_config_1.TYPE_VALUE, ErrorConstructor: base_config_1.TYPE, EvalError: base_config_1.TYPE_VALUE, EvalErrorConstructor: base_config_1.TYPE, RangeError: base_config_1.TYPE_VALUE, RangeErrorConstructor: base_config_1.TYPE, ReferenceError: base_config_1.TYPE_VALUE, ReferenceErrorConstructor: base_config_1.TYPE, SyntaxError: base_config_1.TYPE_VALUE, SyntaxErrorConstructor: base_config_1.TYPE, TypeError: base_config_1.TYPE_VALUE, TypeErrorConstructor: base_config_1.TYPE, URIError: base_config_1.TYPE_VALUE, URIErrorConstructor: base_config_1.TYPE, JSON: base_config_1.TYPE_VALUE, ReadonlyArray: base_config_1.TYPE, ConcatArray: base_config_1.TYPE, Array: base_config_1.TYPE_VALUE, ArrayConstructor: base_config_1.TYPE, TypedPropertyDescriptor: base_config_1.TYPE, PromiseConstructorLike: base_config_1.TYPE, PromiseLike: base_config_1.TYPE, Promise: base_config_1.TYPE, Awaited: base_config_1.TYPE, ArrayLike: base_config_1.TYPE, Partial: base_config_1.TYPE, Required: base_config_1.TYPE, Readonly: base_config_1.TYPE, Pick: base_config_1.TYPE, Record: base_config_1.TYPE, Exclude: base_config_1.TYPE, Extract: base_config_1.TYPE, Omit: base_config_1.TYPE, NonNullable: base_config_1.TYPE, Parameters: base_config_1.TYPE, ConstructorParameters: base_config_1.TYPE, ReturnType: base_config_1.TYPE, InstanceType: base_config_1.TYPE, Uppercase: base_config_1.TYPE, Lowercase: base_config_1.TYPE, Capitalize: base_config_1.TYPE, Uncapitalize: base_config_1.TYPE, ThisType: base_config_1.TYPE, ArrayBuffer: base_config_1.TYPE_VALUE, ArrayBufferTypes: base_config_1.TYPE, ArrayBufferLike: base_config_1.TYPE, ArrayBufferConstructor: base_config_1.TYPE, ArrayBufferView: base_config_1.TYPE, DataView: base_config_1.TYPE_VALUE, DataViewConstructor: base_config_1.TYPE, Int8Array: base_config_1.TYPE_VALUE, Int8ArrayConstructor: base_config_1.TYPE, Uint8Array: base_config_1.TYPE_VALUE, Uint8ArrayConstructor: base_config_1.TYPE, Uint8ClampedArray: base_config_1.TYPE_VALUE, Uint8ClampedArrayConstructor: base_config_1.TYPE, Int16Array: base_config_1.TYPE_VALUE, Int16ArrayConstructor: base_config_1.TYPE, Uint16Array: base_config_1.TYPE_VALUE, Uint16ArrayConstructor: base_config_1.TYPE, Int32Array: base_config_1.TYPE_VALUE, Int32ArrayConstructor: base_config_1.TYPE, Uint32Array: base_config_1.TYPE_VALUE, Uint32ArrayConstructor: base_config_1.TYPE, Float32Array: base_config_1.TYPE_VALUE, Float32ArrayConstructor: base_config_1.TYPE, Float64Array: base_config_1.TYPE_VALUE, Float64ArrayConstructor: base_config_1.TYPE, Intl: base_config_1.TYPE_VALUE });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2015.collection.js
var require_es2015_collection = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2015.collection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2015_collection = void 0;
    var base_config_1 = require_base_config();
    exports.es2015_collection = {
      Map: base_config_1.TYPE_VALUE,
      MapConstructor: base_config_1.TYPE,
      ReadonlyMap: base_config_1.TYPE,
      WeakMap: base_config_1.TYPE_VALUE,
      WeakMapConstructor: base_config_1.TYPE,
      Set: base_config_1.TYPE_VALUE,
      SetConstructor: base_config_1.TYPE,
      ReadonlySet: base_config_1.TYPE,
      WeakSet: base_config_1.TYPE_VALUE,
      WeakSetConstructor: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2015.core.js
var require_es2015_core = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2015.core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2015_core = void 0;
    var base_config_1 = require_base_config();
    exports.es2015_core = {
      Array: base_config_1.TYPE,
      ArrayConstructor: base_config_1.TYPE,
      DateConstructor: base_config_1.TYPE,
      Function: base_config_1.TYPE,
      Math: base_config_1.TYPE,
      NumberConstructor: base_config_1.TYPE,
      ObjectConstructor: base_config_1.TYPE,
      ReadonlyArray: base_config_1.TYPE,
      RegExp: base_config_1.TYPE,
      RegExpConstructor: base_config_1.TYPE,
      String: base_config_1.TYPE,
      StringConstructor: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2015.symbol.js
var require_es2015_symbol = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2015.symbol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2015_symbol = void 0;
    var base_config_1 = require_base_config();
    exports.es2015_symbol = {
      SymbolConstructor: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2015.iterable.js
var require_es2015_iterable = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2015.iterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2015_iterable = void 0;
    var base_config_1 = require_base_config();
    var es2015_symbol_1 = require_es2015_symbol();
    exports.es2015_iterable = Object.assign(Object.assign({}, es2015_symbol_1.es2015_symbol), { SymbolConstructor: base_config_1.TYPE, IteratorYieldResult: base_config_1.TYPE, IteratorReturnResult: base_config_1.TYPE, IteratorResult: base_config_1.TYPE, Iterator: base_config_1.TYPE, Iterable: base_config_1.TYPE, IterableIterator: base_config_1.TYPE, Array: base_config_1.TYPE, ArrayConstructor: base_config_1.TYPE, ReadonlyArray: base_config_1.TYPE, IArguments: base_config_1.TYPE, Map: base_config_1.TYPE, ReadonlyMap: base_config_1.TYPE, MapConstructor: base_config_1.TYPE, WeakMap: base_config_1.TYPE, WeakMapConstructor: base_config_1.TYPE, Set: base_config_1.TYPE, ReadonlySet: base_config_1.TYPE, SetConstructor: base_config_1.TYPE, WeakSet: base_config_1.TYPE, WeakSetConstructor: base_config_1.TYPE, Promise: base_config_1.TYPE, PromiseConstructor: base_config_1.TYPE, String: base_config_1.TYPE, Int8Array: base_config_1.TYPE, Int8ArrayConstructor: base_config_1.TYPE, Uint8Array: base_config_1.TYPE, Uint8ArrayConstructor: base_config_1.TYPE, Uint8ClampedArray: base_config_1.TYPE, Uint8ClampedArrayConstructor: base_config_1.TYPE, Int16Array: base_config_1.TYPE, Int16ArrayConstructor: base_config_1.TYPE, Uint16Array: base_config_1.TYPE, Uint16ArrayConstructor: base_config_1.TYPE, Int32Array: base_config_1.TYPE, Int32ArrayConstructor: base_config_1.TYPE, Uint32Array: base_config_1.TYPE, Uint32ArrayConstructor: base_config_1.TYPE, Float32Array: base_config_1.TYPE, Float32ArrayConstructor: base_config_1.TYPE, Float64Array: base_config_1.TYPE, Float64ArrayConstructor: base_config_1.TYPE });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2015.generator.js
var require_es2015_generator = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2015.generator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2015_generator = void 0;
    var base_config_1 = require_base_config();
    var es2015_iterable_1 = require_es2015_iterable();
    exports.es2015_generator = Object.assign(Object.assign({}, es2015_iterable_1.es2015_iterable), { Generator: base_config_1.TYPE, GeneratorFunction: base_config_1.TYPE, GeneratorFunctionConstructor: base_config_1.TYPE });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2015.promise.js
var require_es2015_promise = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2015.promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2015_promise = void 0;
    var base_config_1 = require_base_config();
    exports.es2015_promise = {
      PromiseConstructor: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2015.proxy.js
var require_es2015_proxy = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2015.proxy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2015_proxy = void 0;
    var base_config_1 = require_base_config();
    exports.es2015_proxy = {
      ProxyHandler: base_config_1.TYPE,
      ProxyConstructor: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2015.reflect.js
var require_es2015_reflect = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2015.reflect.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2015_reflect = void 0;
    var base_config_1 = require_base_config();
    exports.es2015_reflect = {
      Reflect: base_config_1.TYPE_VALUE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2015.symbol.wellknown.js
var require_es2015_symbol_wellknown = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2015.symbol.wellknown.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2015_symbol_wellknown = void 0;
    var base_config_1 = require_base_config();
    var es2015_symbol_1 = require_es2015_symbol();
    exports.es2015_symbol_wellknown = Object.assign(Object.assign({}, es2015_symbol_1.es2015_symbol), { SymbolConstructor: base_config_1.TYPE, Symbol: base_config_1.TYPE, Array: base_config_1.TYPE, ReadonlyArray: base_config_1.TYPE, Date: base_config_1.TYPE, Map: base_config_1.TYPE, WeakMap: base_config_1.TYPE, Set: base_config_1.TYPE, WeakSet: base_config_1.TYPE, JSON: base_config_1.TYPE, Function: base_config_1.TYPE, GeneratorFunction: base_config_1.TYPE, Math: base_config_1.TYPE, Promise: base_config_1.TYPE, PromiseConstructor: base_config_1.TYPE, RegExp: base_config_1.TYPE, RegExpConstructor: base_config_1.TYPE, String: base_config_1.TYPE, ArrayBuffer: base_config_1.TYPE, DataView: base_config_1.TYPE, Int8Array: base_config_1.TYPE, Uint8Array: base_config_1.TYPE, Uint8ClampedArray: base_config_1.TYPE, Int16Array: base_config_1.TYPE, Uint16Array: base_config_1.TYPE, Int32Array: base_config_1.TYPE, Uint32Array: base_config_1.TYPE, Float32Array: base_config_1.TYPE, Float64Array: base_config_1.TYPE, ArrayConstructor: base_config_1.TYPE, MapConstructor: base_config_1.TYPE, SetConstructor: base_config_1.TYPE, ArrayBufferConstructor: base_config_1.TYPE });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es6.js
var require_es6 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es6.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es6 = void 0;
    var es5_1 = require_es5();
    var es2015_collection_1 = require_es2015_collection();
    var es2015_core_1 = require_es2015_core();
    var es2015_generator_1 = require_es2015_generator();
    var es2015_iterable_1 = require_es2015_iterable();
    var es2015_promise_1 = require_es2015_promise();
    var es2015_proxy_1 = require_es2015_proxy();
    var es2015_reflect_1 = require_es2015_reflect();
    var es2015_symbol_1 = require_es2015_symbol();
    var es2015_symbol_wellknown_1 = require_es2015_symbol_wellknown();
    exports.es6 = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, es5_1.es5), es2015_core_1.es2015_core), es2015_collection_1.es2015_collection), es2015_iterable_1.es2015_iterable), es2015_generator_1.es2015_generator), es2015_promise_1.es2015_promise), es2015_proxy_1.es2015_proxy), es2015_reflect_1.es2015_reflect), es2015_symbol_1.es2015_symbol), es2015_symbol_wellknown_1.es2015_symbol_wellknown);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2015.js
var require_es2015 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2015.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2015 = void 0;
    var es5_1 = require_es5();
    var es2015_collection_1 = require_es2015_collection();
    var es2015_core_1 = require_es2015_core();
    var es2015_generator_1 = require_es2015_generator();
    var es2015_iterable_1 = require_es2015_iterable();
    var es2015_promise_1 = require_es2015_promise();
    var es2015_proxy_1 = require_es2015_proxy();
    var es2015_reflect_1 = require_es2015_reflect();
    var es2015_symbol_1 = require_es2015_symbol();
    var es2015_symbol_wellknown_1 = require_es2015_symbol_wellknown();
    exports.es2015 = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, es5_1.es5), es2015_core_1.es2015_core), es2015_collection_1.es2015_collection), es2015_iterable_1.es2015_iterable), es2015_generator_1.es2015_generator), es2015_promise_1.es2015_promise), es2015_proxy_1.es2015_proxy), es2015_reflect_1.es2015_reflect), es2015_symbol_1.es2015_symbol), es2015_symbol_wellknown_1.es2015_symbol_wellknown);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2016.array.include.js
var require_es2016_array_include = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2016.array.include.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2016_array_include = void 0;
    var base_config_1 = require_base_config();
    exports.es2016_array_include = {
      Array: base_config_1.TYPE,
      ReadonlyArray: base_config_1.TYPE,
      Int8Array: base_config_1.TYPE,
      Uint8Array: base_config_1.TYPE,
      Uint8ClampedArray: base_config_1.TYPE,
      Int16Array: base_config_1.TYPE,
      Uint16Array: base_config_1.TYPE,
      Int32Array: base_config_1.TYPE,
      Uint32Array: base_config_1.TYPE,
      Float32Array: base_config_1.TYPE,
      Float64Array: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es7.js
var require_es7 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es7.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es7 = void 0;
    var es2015_1 = require_es2015();
    var es2016_array_include_1 = require_es2016_array_include();
    exports.es7 = Object.assign(Object.assign({}, es2015_1.es2015), es2016_array_include_1.es2016_array_include);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2016.js
var require_es2016 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2016.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2016 = void 0;
    var es2015_1 = require_es2015();
    var es2016_array_include_1 = require_es2016_array_include();
    exports.es2016 = Object.assign(Object.assign({}, es2015_1.es2015), es2016_array_include_1.es2016_array_include);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/scripthost.js
var require_scripthost = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/scripthost.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scripthost = void 0;
    var base_config_1 = require_base_config();
    exports.scripthost = {
      ActiveXObject: base_config_1.TYPE_VALUE,
      ITextWriter: base_config_1.TYPE,
      TextStreamBase: base_config_1.TYPE,
      TextStreamWriter: base_config_1.TYPE,
      TextStreamReader: base_config_1.TYPE,
      SafeArray: base_config_1.TYPE_VALUE,
      Enumerator: base_config_1.TYPE_VALUE,
      EnumeratorConstructor: base_config_1.TYPE,
      VBArray: base_config_1.TYPE_VALUE,
      VBArrayConstructor: base_config_1.TYPE,
      VarDate: base_config_1.TYPE_VALUE,
      DateConstructor: base_config_1.TYPE,
      Date: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/webworker.importscripts.js
var require_webworker_importscripts = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/webworker.importscripts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.webworker_importscripts = void 0;
    exports.webworker_importscripts = {};
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2016.full.js
var require_es2016_full = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2016.full.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2016_full = void 0;
    var dom_1 = require_dom();
    var dom_iterable_1 = require_dom_iterable();
    var es2016_1 = require_es2016();
    var scripthost_1 = require_scripthost();
    var webworker_importscripts_1 = require_webworker_importscripts();
    exports.es2016_full = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, es2016_1.es2016), dom_1.dom), webworker_importscripts_1.webworker_importscripts), scripthost_1.scripthost), dom_iterable_1.dom_iterable);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2017.intl.js
var require_es2017_intl = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2017.intl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2017_intl = void 0;
    var base_config_1 = require_base_config();
    exports.es2017_intl = {
      Intl: base_config_1.TYPE_VALUE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2017.object.js
var require_es2017_object = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2017.object.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2017_object = void 0;
    var base_config_1 = require_base_config();
    exports.es2017_object = {
      ObjectConstructor: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2017.sharedmemory.js
var require_es2017_sharedmemory = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2017.sharedmemory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2017_sharedmemory = void 0;
    var base_config_1 = require_base_config();
    var es2015_symbol_1 = require_es2015_symbol();
    var es2015_symbol_wellknown_1 = require_es2015_symbol_wellknown();
    exports.es2017_sharedmemory = Object.assign(Object.assign(Object.assign({}, es2015_symbol_1.es2015_symbol), es2015_symbol_wellknown_1.es2015_symbol_wellknown), { SharedArrayBuffer: base_config_1.TYPE_VALUE, SharedArrayBufferConstructor: base_config_1.TYPE, ArrayBufferTypes: base_config_1.TYPE, Atomics: base_config_1.TYPE_VALUE });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2017.string.js
var require_es2017_string = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2017.string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2017_string = void 0;
    var base_config_1 = require_base_config();
    exports.es2017_string = {
      String: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2017.typedarrays.js
var require_es2017_typedarrays = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2017.typedarrays.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2017_typedarrays = void 0;
    var base_config_1 = require_base_config();
    exports.es2017_typedarrays = {
      Int8ArrayConstructor: base_config_1.TYPE,
      Uint8ArrayConstructor: base_config_1.TYPE,
      Uint8ClampedArrayConstructor: base_config_1.TYPE,
      Int16ArrayConstructor: base_config_1.TYPE,
      Uint16ArrayConstructor: base_config_1.TYPE,
      Int32ArrayConstructor: base_config_1.TYPE,
      Uint32ArrayConstructor: base_config_1.TYPE,
      Float32ArrayConstructor: base_config_1.TYPE,
      Float64ArrayConstructor: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2017.js
var require_es2017 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2017.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2017 = void 0;
    var es2016_1 = require_es2016();
    var es2017_intl_1 = require_es2017_intl();
    var es2017_object_1 = require_es2017_object();
    var es2017_sharedmemory_1 = require_es2017_sharedmemory();
    var es2017_string_1 = require_es2017_string();
    var es2017_typedarrays_1 = require_es2017_typedarrays();
    exports.es2017 = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, es2016_1.es2016), es2017_object_1.es2017_object), es2017_sharedmemory_1.es2017_sharedmemory), es2017_string_1.es2017_string), es2017_intl_1.es2017_intl), es2017_typedarrays_1.es2017_typedarrays);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2017.full.js
var require_es2017_full = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2017.full.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2017_full = void 0;
    var dom_1 = require_dom();
    var dom_iterable_1 = require_dom_iterable();
    var es2017_1 = require_es2017();
    var scripthost_1 = require_scripthost();
    var webworker_importscripts_1 = require_webworker_importscripts();
    exports.es2017_full = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, es2017_1.es2017), dom_1.dom), webworker_importscripts_1.webworker_importscripts), scripthost_1.scripthost), dom_iterable_1.dom_iterable);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2018.asynciterable.js
var require_es2018_asynciterable = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2018.asynciterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2018_asynciterable = void 0;
    var base_config_1 = require_base_config();
    var es2015_iterable_1 = require_es2015_iterable();
    var es2015_symbol_1 = require_es2015_symbol();
    exports.es2018_asynciterable = Object.assign(Object.assign(Object.assign({}, es2015_symbol_1.es2015_symbol), es2015_iterable_1.es2015_iterable), { SymbolConstructor: base_config_1.TYPE, AsyncIterator: base_config_1.TYPE, AsyncIterable: base_config_1.TYPE, AsyncIterableIterator: base_config_1.TYPE });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2018.asyncgenerator.js
var require_es2018_asyncgenerator = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2018.asyncgenerator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2018_asyncgenerator = void 0;
    var base_config_1 = require_base_config();
    var es2018_asynciterable_1 = require_es2018_asynciterable();
    exports.es2018_asyncgenerator = Object.assign(Object.assign({}, es2018_asynciterable_1.es2018_asynciterable), { AsyncGenerator: base_config_1.TYPE, AsyncGeneratorFunction: base_config_1.TYPE, AsyncGeneratorFunctionConstructor: base_config_1.TYPE });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2018.intl.js
var require_es2018_intl = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2018.intl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2018_intl = void 0;
    var base_config_1 = require_base_config();
    exports.es2018_intl = {
      Intl: base_config_1.TYPE_VALUE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2018.promise.js
var require_es2018_promise = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2018.promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2018_promise = void 0;
    var base_config_1 = require_base_config();
    exports.es2018_promise = {
      Promise: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2018.regexp.js
var require_es2018_regexp = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2018.regexp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2018_regexp = void 0;
    var base_config_1 = require_base_config();
    exports.es2018_regexp = {
      RegExpMatchArray: base_config_1.TYPE,
      RegExpExecArray: base_config_1.TYPE,
      RegExp: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2018.js
var require_es2018 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2018.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2018 = void 0;
    var es2017_1 = require_es2017();
    var es2018_asyncgenerator_1 = require_es2018_asyncgenerator();
    var es2018_asynciterable_1 = require_es2018_asynciterable();
    var es2018_intl_1 = require_es2018_intl();
    var es2018_promise_1 = require_es2018_promise();
    var es2018_regexp_1 = require_es2018_regexp();
    exports.es2018 = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, es2017_1.es2017), es2018_asynciterable_1.es2018_asynciterable), es2018_asyncgenerator_1.es2018_asyncgenerator), es2018_promise_1.es2018_promise), es2018_regexp_1.es2018_regexp), es2018_intl_1.es2018_intl);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2018.full.js
var require_es2018_full = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2018.full.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2018_full = void 0;
    var dom_1 = require_dom();
    var dom_iterable_1 = require_dom_iterable();
    var es2018_1 = require_es2018();
    var scripthost_1 = require_scripthost();
    var webworker_importscripts_1 = require_webworker_importscripts();
    exports.es2018_full = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, es2018_1.es2018), dom_1.dom), webworker_importscripts_1.webworker_importscripts), scripthost_1.scripthost), dom_iterable_1.dom_iterable);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2019.array.js
var require_es2019_array = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2019.array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2019_array = void 0;
    var base_config_1 = require_base_config();
    exports.es2019_array = {
      FlatArray: base_config_1.TYPE,
      ReadonlyArray: base_config_1.TYPE,
      Array: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2019.intl.js
var require_es2019_intl = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2019.intl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2019_intl = void 0;
    var base_config_1 = require_base_config();
    exports.es2019_intl = {
      Intl: base_config_1.TYPE_VALUE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2019.object.js
var require_es2019_object = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2019.object.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2019_object = void 0;
    var base_config_1 = require_base_config();
    var es2015_iterable_1 = require_es2015_iterable();
    exports.es2019_object = Object.assign(Object.assign({}, es2015_iterable_1.es2015_iterable), { ObjectConstructor: base_config_1.TYPE });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2019.string.js
var require_es2019_string = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2019.string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2019_string = void 0;
    var base_config_1 = require_base_config();
    exports.es2019_string = {
      String: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2019.symbol.js
var require_es2019_symbol = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2019.symbol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2019_symbol = void 0;
    var base_config_1 = require_base_config();
    exports.es2019_symbol = {
      Symbol: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2019.js
var require_es2019 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2019.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2019 = void 0;
    var es2018_1 = require_es2018();
    var es2019_array_1 = require_es2019_array();
    var es2019_intl_1 = require_es2019_intl();
    var es2019_object_1 = require_es2019_object();
    var es2019_string_1 = require_es2019_string();
    var es2019_symbol_1 = require_es2019_symbol();
    exports.es2019 = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, es2018_1.es2018), es2019_array_1.es2019_array), es2019_object_1.es2019_object), es2019_string_1.es2019_string), es2019_symbol_1.es2019_symbol), es2019_intl_1.es2019_intl);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2019.full.js
var require_es2019_full = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2019.full.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2019_full = void 0;
    var dom_1 = require_dom();
    var dom_iterable_1 = require_dom_iterable();
    var es2019_1 = require_es2019();
    var scripthost_1 = require_scripthost();
    var webworker_importscripts_1 = require_webworker_importscripts();
    exports.es2019_full = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, es2019_1.es2019), dom_1.dom), webworker_importscripts_1.webworker_importscripts), scripthost_1.scripthost), dom_iterable_1.dom_iterable);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2020.intl.js
var require_es2020_intl = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2020.intl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2020_intl = void 0;
    var base_config_1 = require_base_config();
    var es2018_intl_1 = require_es2018_intl();
    exports.es2020_intl = Object.assign(Object.assign({}, es2018_intl_1.es2018_intl), { Intl: base_config_1.TYPE_VALUE });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2020.bigint.js
var require_es2020_bigint = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2020.bigint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2020_bigint = void 0;
    var base_config_1 = require_base_config();
    var es2020_intl_1 = require_es2020_intl();
    exports.es2020_bigint = Object.assign(Object.assign({}, es2020_intl_1.es2020_intl), { BigIntToLocaleStringOptions: base_config_1.TYPE, BigInt: base_config_1.TYPE_VALUE, BigIntConstructor: base_config_1.TYPE, BigInt64Array: base_config_1.TYPE_VALUE, BigInt64ArrayConstructor: base_config_1.TYPE, BigUint64Array: base_config_1.TYPE_VALUE, BigUint64ArrayConstructor: base_config_1.TYPE, DataView: base_config_1.TYPE, Intl: base_config_1.TYPE_VALUE });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2020.date.js
var require_es2020_date = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2020.date.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2020_date = void 0;
    var base_config_1 = require_base_config();
    var es2020_intl_1 = require_es2020_intl();
    exports.es2020_date = Object.assign(Object.assign({}, es2020_intl_1.es2020_intl), { Date: base_config_1.TYPE });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2020.number.js
var require_es2020_number = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2020.number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2020_number = void 0;
    var base_config_1 = require_base_config();
    var es2020_intl_1 = require_es2020_intl();
    exports.es2020_number = Object.assign(Object.assign({}, es2020_intl_1.es2020_intl), { Number: base_config_1.TYPE });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2020.promise.js
var require_es2020_promise = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2020.promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2020_promise = void 0;
    var base_config_1 = require_base_config();
    exports.es2020_promise = {
      PromiseFulfilledResult: base_config_1.TYPE,
      PromiseRejectedResult: base_config_1.TYPE,
      PromiseSettledResult: base_config_1.TYPE,
      PromiseConstructor: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2020.sharedmemory.js
var require_es2020_sharedmemory = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2020.sharedmemory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2020_sharedmemory = void 0;
    var base_config_1 = require_base_config();
    exports.es2020_sharedmemory = {
      Atomics: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2020.string.js
var require_es2020_string = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2020.string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2020_string = void 0;
    var base_config_1 = require_base_config();
    var es2015_iterable_1 = require_es2015_iterable();
    exports.es2020_string = Object.assign(Object.assign({}, es2015_iterable_1.es2015_iterable), { String: base_config_1.TYPE });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2020.symbol.wellknown.js
var require_es2020_symbol_wellknown = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2020.symbol.wellknown.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2020_symbol_wellknown = void 0;
    var base_config_1 = require_base_config();
    var es2015_iterable_1 = require_es2015_iterable();
    var es2015_symbol_1 = require_es2015_symbol();
    exports.es2020_symbol_wellknown = Object.assign(Object.assign(Object.assign({}, es2015_iterable_1.es2015_iterable), es2015_symbol_1.es2015_symbol), { SymbolConstructor: base_config_1.TYPE, RegExp: base_config_1.TYPE });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2020.js
var require_es2020 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2020.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2020 = void 0;
    var es2019_1 = require_es2019();
    var es2020_bigint_1 = require_es2020_bigint();
    var es2020_date_1 = require_es2020_date();
    var es2020_intl_1 = require_es2020_intl();
    var es2020_number_1 = require_es2020_number();
    var es2020_promise_1 = require_es2020_promise();
    var es2020_sharedmemory_1 = require_es2020_sharedmemory();
    var es2020_string_1 = require_es2020_string();
    var es2020_symbol_wellknown_1 = require_es2020_symbol_wellknown();
    exports.es2020 = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, es2019_1.es2019), es2020_bigint_1.es2020_bigint), es2020_date_1.es2020_date), es2020_number_1.es2020_number), es2020_promise_1.es2020_promise), es2020_sharedmemory_1.es2020_sharedmemory), es2020_string_1.es2020_string), es2020_symbol_wellknown_1.es2020_symbol_wellknown), es2020_intl_1.es2020_intl);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2020.full.js
var require_es2020_full = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2020.full.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2020_full = void 0;
    var dom_1 = require_dom();
    var dom_iterable_1 = require_dom_iterable();
    var es2020_1 = require_es2020();
    var scripthost_1 = require_scripthost();
    var webworker_importscripts_1 = require_webworker_importscripts();
    exports.es2020_full = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, es2020_1.es2020), dom_1.dom), webworker_importscripts_1.webworker_importscripts), scripthost_1.scripthost), dom_iterable_1.dom_iterable);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2021.intl.js
var require_es2021_intl = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2021.intl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2021_intl = void 0;
    var base_config_1 = require_base_config();
    exports.es2021_intl = {
      Intl: base_config_1.TYPE_VALUE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2021.promise.js
var require_es2021_promise = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2021.promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2021_promise = void 0;
    var base_config_1 = require_base_config();
    exports.es2021_promise = {
      AggregateError: base_config_1.TYPE_VALUE,
      AggregateErrorConstructor: base_config_1.TYPE,
      PromiseConstructor: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2021.string.js
var require_es2021_string = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2021.string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2021_string = void 0;
    var base_config_1 = require_base_config();
    exports.es2021_string = {
      String: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2021.weakref.js
var require_es2021_weakref = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2021.weakref.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2021_weakref = void 0;
    var base_config_1 = require_base_config();
    exports.es2021_weakref = {
      WeakRef: base_config_1.TYPE_VALUE,
      WeakRefConstructor: base_config_1.TYPE,
      FinalizationRegistry: base_config_1.TYPE_VALUE,
      FinalizationRegistryConstructor: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2021.js
var require_es2021 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2021.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2021 = void 0;
    var es2020_1 = require_es2020();
    var es2021_intl_1 = require_es2021_intl();
    var es2021_promise_1 = require_es2021_promise();
    var es2021_string_1 = require_es2021_string();
    var es2021_weakref_1 = require_es2021_weakref();
    exports.es2021 = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, es2020_1.es2020), es2021_promise_1.es2021_promise), es2021_string_1.es2021_string), es2021_weakref_1.es2021_weakref), es2021_intl_1.es2021_intl);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2021.full.js
var require_es2021_full = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2021.full.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2021_full = void 0;
    var dom_1 = require_dom();
    var dom_iterable_1 = require_dom_iterable();
    var es2021_1 = require_es2021();
    var scripthost_1 = require_scripthost();
    var webworker_importscripts_1 = require_webworker_importscripts();
    exports.es2021_full = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, es2021_1.es2021), dom_1.dom), webworker_importscripts_1.webworker_importscripts), scripthost_1.scripthost), dom_iterable_1.dom_iterable);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2022.array.js
var require_es2022_array = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2022.array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2022_array = void 0;
    var base_config_1 = require_base_config();
    exports.es2022_array = {
      Array: base_config_1.TYPE,
      ReadonlyArray: base_config_1.TYPE,
      Int8Array: base_config_1.TYPE,
      Uint8Array: base_config_1.TYPE,
      Uint8ClampedArray: base_config_1.TYPE,
      Int16Array: base_config_1.TYPE,
      Uint16Array: base_config_1.TYPE,
      Int32Array: base_config_1.TYPE,
      Uint32Array: base_config_1.TYPE,
      Float32Array: base_config_1.TYPE,
      Float64Array: base_config_1.TYPE,
      BigInt64Array: base_config_1.TYPE,
      BigUint64Array: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2022.error.js
var require_es2022_error = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2022.error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2022_error = void 0;
    var base_config_1 = require_base_config();
    exports.es2022_error = {
      ErrorOptions: base_config_1.TYPE,
      Error: base_config_1.TYPE,
      ErrorConstructor: base_config_1.TYPE,
      EvalErrorConstructor: base_config_1.TYPE,
      RangeErrorConstructor: base_config_1.TYPE,
      ReferenceErrorConstructor: base_config_1.TYPE,
      SyntaxErrorConstructor: base_config_1.TYPE,
      TypeErrorConstructor: base_config_1.TYPE,
      URIErrorConstructor: base_config_1.TYPE,
      AggregateErrorConstructor: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2022.intl.js
var require_es2022_intl = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2022.intl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2022_intl = void 0;
    var base_config_1 = require_base_config();
    exports.es2022_intl = {
      Intl: base_config_1.TYPE_VALUE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2022.object.js
var require_es2022_object = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2022.object.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2022_object = void 0;
    var base_config_1 = require_base_config();
    exports.es2022_object = {
      ObjectConstructor: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2022.regexp.js
var require_es2022_regexp = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2022.regexp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2022_regexp = void 0;
    var base_config_1 = require_base_config();
    exports.es2022_regexp = {
      RegExpMatchArray: base_config_1.TYPE,
      RegExpExecArray: base_config_1.TYPE,
      RegExpIndicesArray: base_config_1.TYPE,
      RegExp: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2022.sharedmemory.js
var require_es2022_sharedmemory = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2022.sharedmemory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2022_sharedmemory = void 0;
    var base_config_1 = require_base_config();
    exports.es2022_sharedmemory = {
      Atomics: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2022.string.js
var require_es2022_string = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2022.string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2022_string = void 0;
    var base_config_1 = require_base_config();
    exports.es2022_string = {
      String: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2022.js
var require_es2022 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2022.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2022 = void 0;
    var es2021_1 = require_es2021();
    var es2022_array_1 = require_es2022_array();
    var es2022_error_1 = require_es2022_error();
    var es2022_intl_1 = require_es2022_intl();
    var es2022_object_1 = require_es2022_object();
    var es2022_regexp_1 = require_es2022_regexp();
    var es2022_sharedmemory_1 = require_es2022_sharedmemory();
    var es2022_string_1 = require_es2022_string();
    exports.es2022 = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, es2021_1.es2021), es2022_array_1.es2022_array), es2022_error_1.es2022_error), es2022_intl_1.es2022_intl), es2022_object_1.es2022_object), es2022_sharedmemory_1.es2022_sharedmemory), es2022_string_1.es2022_string), es2022_regexp_1.es2022_regexp);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2022.full.js
var require_es2022_full = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2022.full.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2022_full = void 0;
    var dom_1 = require_dom();
    var dom_iterable_1 = require_dom_iterable();
    var es2022_1 = require_es2022();
    var scripthost_1 = require_scripthost();
    var webworker_importscripts_1 = require_webworker_importscripts();
    exports.es2022_full = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, es2022_1.es2022), dom_1.dom), webworker_importscripts_1.webworker_importscripts), scripthost_1.scripthost), dom_iterable_1.dom_iterable);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2023.array.js
var require_es2023_array = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2023.array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2023_array = void 0;
    var base_config_1 = require_base_config();
    exports.es2023_array = {
      Array: base_config_1.TYPE,
      ReadonlyArray: base_config_1.TYPE,
      Int8Array: base_config_1.TYPE,
      Uint8Array: base_config_1.TYPE,
      Uint8ClampedArray: base_config_1.TYPE,
      Int16Array: base_config_1.TYPE,
      Uint16Array: base_config_1.TYPE,
      Int32Array: base_config_1.TYPE,
      Uint32Array: base_config_1.TYPE,
      Float32Array: base_config_1.TYPE,
      Float64Array: base_config_1.TYPE,
      BigInt64Array: base_config_1.TYPE,
      BigUint64Array: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2023.js
var require_es2023 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2023.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2023 = void 0;
    var es2022_1 = require_es2022();
    var es2023_array_1 = require_es2023_array();
    exports.es2023 = Object.assign(Object.assign({}, es2022_1.es2022), es2023_array_1.es2023_array);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2023.full.js
var require_es2023_full = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/es2023.full.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.es2023_full = void 0;
    var dom_1 = require_dom();
    var dom_iterable_1 = require_dom_iterable();
    var es2023_1 = require_es2023();
    var scripthost_1 = require_scripthost();
    var webworker_importscripts_1 = require_webworker_importscripts();
    exports.es2023_full = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, es2023_1.es2023), dom_1.dom), webworker_importscripts_1.webworker_importscripts), scripthost_1.scripthost), dom_iterable_1.dom_iterable);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/esnext.intl.js
var require_esnext_intl = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/esnext.intl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.esnext_intl = void 0;
    var base_config_1 = require_base_config();
    exports.esnext_intl = {
      Intl: base_config_1.TYPE_VALUE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/esnext.js
var require_esnext = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/esnext.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.esnext = void 0;
    var es2023_1 = require_es2023();
    var esnext_intl_1 = require_esnext_intl();
    exports.esnext = Object.assign(Object.assign({}, es2023_1.es2023), esnext_intl_1.esnext_intl);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/esnext.array.js
var require_esnext_array = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/esnext.array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.esnext_array = void 0;
    var base_config_1 = require_base_config();
    exports.esnext_array = {
      Array: base_config_1.TYPE,
      ReadonlyArray: base_config_1.TYPE,
      Int8Array: base_config_1.TYPE,
      Uint8Array: base_config_1.TYPE,
      Uint8ClampedArray: base_config_1.TYPE,
      Int16Array: base_config_1.TYPE,
      Uint16Array: base_config_1.TYPE,
      Int32Array: base_config_1.TYPE,
      Uint32Array: base_config_1.TYPE,
      Float32Array: base_config_1.TYPE,
      Float64Array: base_config_1.TYPE,
      BigInt64Array: base_config_1.TYPE,
      BigUint64Array: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/esnext.asynciterable.js
var require_esnext_asynciterable = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/esnext.asynciterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.esnext_asynciterable = void 0;
    var base_config_1 = require_base_config();
    var es2015_iterable_1 = require_es2015_iterable();
    var es2015_symbol_1 = require_es2015_symbol();
    exports.esnext_asynciterable = Object.assign(Object.assign(Object.assign({}, es2015_symbol_1.es2015_symbol), es2015_iterable_1.es2015_iterable), { SymbolConstructor: base_config_1.TYPE, AsyncIterator: base_config_1.TYPE, AsyncIterable: base_config_1.TYPE, AsyncIterableIterator: base_config_1.TYPE });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/esnext.bigint.js
var require_esnext_bigint = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/esnext.bigint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.esnext_bigint = void 0;
    var base_config_1 = require_base_config();
    var es2020_intl_1 = require_es2020_intl();
    exports.esnext_bigint = Object.assign(Object.assign({}, es2020_intl_1.es2020_intl), { BigIntToLocaleStringOptions: base_config_1.TYPE, BigInt: base_config_1.TYPE_VALUE, BigIntConstructor: base_config_1.TYPE, BigInt64Array: base_config_1.TYPE_VALUE, BigInt64ArrayConstructor: base_config_1.TYPE, BigUint64Array: base_config_1.TYPE_VALUE, BigUint64ArrayConstructor: base_config_1.TYPE, DataView: base_config_1.TYPE, Intl: base_config_1.TYPE_VALUE });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/esnext.full.js
var require_esnext_full = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/esnext.full.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.esnext_full = void 0;
    var dom_1 = require_dom();
    var dom_iterable_1 = require_dom_iterable();
    var esnext_1 = require_esnext();
    var scripthost_1 = require_scripthost();
    var webworker_importscripts_1 = require_webworker_importscripts();
    exports.esnext_full = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, esnext_1.esnext), dom_1.dom), webworker_importscripts_1.webworker_importscripts), scripthost_1.scripthost), dom_iterable_1.dom_iterable);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/esnext.promise.js
var require_esnext_promise = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/esnext.promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.esnext_promise = void 0;
    var base_config_1 = require_base_config();
    exports.esnext_promise = {
      AggregateError: base_config_1.TYPE_VALUE,
      AggregateErrorConstructor: base_config_1.TYPE,
      PromiseConstructor: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/esnext.string.js
var require_esnext_string = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/esnext.string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.esnext_string = void 0;
    var base_config_1 = require_base_config();
    exports.esnext_string = {
      String: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/esnext.symbol.js
var require_esnext_symbol = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/esnext.symbol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.esnext_symbol = void 0;
    var base_config_1 = require_base_config();
    exports.esnext_symbol = {
      Symbol: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/esnext.weakref.js
var require_esnext_weakref = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/esnext.weakref.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.esnext_weakref = void 0;
    var base_config_1 = require_base_config();
    exports.esnext_weakref = {
      WeakRef: base_config_1.TYPE_VALUE,
      WeakRefConstructor: base_config_1.TYPE,
      FinalizationRegistry: base_config_1.TYPE_VALUE,
      FinalizationRegistryConstructor: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/lib.js
var require_lib2 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/lib.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lib = void 0;
    var dom_1 = require_dom();
    var es5_1 = require_es5();
    var scripthost_1 = require_scripthost();
    var webworker_importscripts_1 = require_webworker_importscripts();
    exports.lib = Object.assign(Object.assign(Object.assign(Object.assign({}, es5_1.es5), dom_1.dom), webworker_importscripts_1.webworker_importscripts), scripthost_1.scripthost);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/webworker.js
var require_webworker = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/webworker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.webworker = void 0;
    var base_config_1 = require_base_config();
    exports.webworker = {
      AddEventListenerOptions: base_config_1.TYPE,
      AesCbcParams: base_config_1.TYPE,
      AesCtrParams: base_config_1.TYPE,
      AesDerivedKeyParams: base_config_1.TYPE,
      AesGcmParams: base_config_1.TYPE,
      AesKeyAlgorithm: base_config_1.TYPE,
      AesKeyGenParams: base_config_1.TYPE,
      Algorithm: base_config_1.TYPE,
      AudioConfiguration: base_config_1.TYPE,
      BlobPropertyBag: base_config_1.TYPE,
      CacheQueryOptions: base_config_1.TYPE,
      ClientQueryOptions: base_config_1.TYPE,
      CloseEventInit: base_config_1.TYPE,
      CryptoKeyPair: base_config_1.TYPE,
      CustomEventInit: base_config_1.TYPE,
      DOMMatrix2DInit: base_config_1.TYPE,
      DOMMatrixInit: base_config_1.TYPE,
      DOMPointInit: base_config_1.TYPE,
      DOMQuadInit: base_config_1.TYPE,
      DOMRectInit: base_config_1.TYPE,
      EcKeyGenParams: base_config_1.TYPE,
      EcKeyImportParams: base_config_1.TYPE,
      EcdhKeyDeriveParams: base_config_1.TYPE,
      EcdsaParams: base_config_1.TYPE,
      ErrorEventInit: base_config_1.TYPE,
      EventInit: base_config_1.TYPE,
      EventListenerOptions: base_config_1.TYPE,
      EventSourceInit: base_config_1.TYPE,
      ExtendableEventInit: base_config_1.TYPE,
      ExtendableMessageEventInit: base_config_1.TYPE,
      FetchEventInit: base_config_1.TYPE,
      FilePropertyBag: base_config_1.TYPE,
      FileSystemGetDirectoryOptions: base_config_1.TYPE,
      FileSystemGetFileOptions: base_config_1.TYPE,
      FileSystemReadWriteOptions: base_config_1.TYPE,
      FileSystemRemoveOptions: base_config_1.TYPE,
      FontFaceDescriptors: base_config_1.TYPE,
      FontFaceSetLoadEventInit: base_config_1.TYPE,
      GetNotificationOptions: base_config_1.TYPE,
      HkdfParams: base_config_1.TYPE,
      HmacImportParams: base_config_1.TYPE,
      HmacKeyGenParams: base_config_1.TYPE,
      IDBDatabaseInfo: base_config_1.TYPE,
      IDBIndexParameters: base_config_1.TYPE,
      IDBObjectStoreParameters: base_config_1.TYPE,
      IDBTransactionOptions: base_config_1.TYPE,
      IDBVersionChangeEventInit: base_config_1.TYPE,
      ImageBitmapOptions: base_config_1.TYPE,
      ImageBitmapRenderingContextSettings: base_config_1.TYPE,
      ImageDataSettings: base_config_1.TYPE,
      ImageEncodeOptions: base_config_1.TYPE,
      ImportMeta: base_config_1.TYPE,
      JsonWebKey: base_config_1.TYPE,
      KeyAlgorithm: base_config_1.TYPE,
      LockInfo: base_config_1.TYPE,
      LockManagerSnapshot: base_config_1.TYPE,
      LockOptions: base_config_1.TYPE,
      MediaCapabilitiesDecodingInfo: base_config_1.TYPE,
      MediaCapabilitiesEncodingInfo: base_config_1.TYPE,
      MediaCapabilitiesInfo: base_config_1.TYPE,
      MediaConfiguration: base_config_1.TYPE,
      MediaDecodingConfiguration: base_config_1.TYPE,
      MediaEncodingConfiguration: base_config_1.TYPE,
      MessageEventInit: base_config_1.TYPE,
      MultiCacheQueryOptions: base_config_1.TYPE,
      NavigationPreloadState: base_config_1.TYPE,
      NotificationAction: base_config_1.TYPE,
      NotificationEventInit: base_config_1.TYPE,
      NotificationOptions: base_config_1.TYPE,
      Pbkdf2Params: base_config_1.TYPE,
      PerformanceMarkOptions: base_config_1.TYPE,
      PerformanceMeasureOptions: base_config_1.TYPE,
      PerformanceObserverInit: base_config_1.TYPE,
      PermissionDescriptor: base_config_1.TYPE,
      ProgressEventInit: base_config_1.TYPE,
      PromiseRejectionEventInit: base_config_1.TYPE,
      PushEventInit: base_config_1.TYPE,
      PushSubscriptionJSON: base_config_1.TYPE,
      PushSubscriptionOptionsInit: base_config_1.TYPE,
      QueuingStrategy: base_config_1.TYPE,
      QueuingStrategyInit: base_config_1.TYPE,
      RTCEncodedAudioFrameMetadata: base_config_1.TYPE,
      RTCEncodedVideoFrameMetadata: base_config_1.TYPE,
      ReadableStreamGetReaderOptions: base_config_1.TYPE,
      ReadableStreamReadDoneResult: base_config_1.TYPE,
      ReadableStreamReadValueResult: base_config_1.TYPE,
      ReadableWritablePair: base_config_1.TYPE,
      RegistrationOptions: base_config_1.TYPE,
      RequestInit: base_config_1.TYPE,
      ResponseInit: base_config_1.TYPE,
      RsaHashedImportParams: base_config_1.TYPE,
      RsaHashedKeyGenParams: base_config_1.TYPE,
      RsaKeyGenParams: base_config_1.TYPE,
      RsaOaepParams: base_config_1.TYPE,
      RsaOtherPrimesInfo: base_config_1.TYPE,
      RsaPssParams: base_config_1.TYPE,
      SecurityPolicyViolationEventInit: base_config_1.TYPE,
      StorageEstimate: base_config_1.TYPE,
      StreamPipeOptions: base_config_1.TYPE,
      StructuredSerializeOptions: base_config_1.TYPE,
      TextDecodeOptions: base_config_1.TYPE,
      TextDecoderOptions: base_config_1.TYPE,
      TextEncoderEncodeIntoResult: base_config_1.TYPE,
      Transformer: base_config_1.TYPE,
      UnderlyingByteSource: base_config_1.TYPE,
      UnderlyingDefaultSource: base_config_1.TYPE,
      UnderlyingSink: base_config_1.TYPE,
      UnderlyingSource: base_config_1.TYPE,
      VideoColorSpaceInit: base_config_1.TYPE,
      VideoConfiguration: base_config_1.TYPE,
      WebGLContextAttributes: base_config_1.TYPE,
      WebGLContextEventInit: base_config_1.TYPE,
      WorkerOptions: base_config_1.TYPE,
      ANGLE_instanced_arrays: base_config_1.TYPE,
      AbortController: base_config_1.TYPE_VALUE,
      AbortSignalEventMap: base_config_1.TYPE,
      AbortSignal: base_config_1.TYPE_VALUE,
      AbstractWorkerEventMap: base_config_1.TYPE,
      AbstractWorker: base_config_1.TYPE,
      AnimationFrameProvider: base_config_1.TYPE,
      Blob: base_config_1.TYPE_VALUE,
      Body: base_config_1.TYPE,
      BroadcastChannelEventMap: base_config_1.TYPE,
      BroadcastChannel: base_config_1.TYPE_VALUE,
      ByteLengthQueuingStrategy: base_config_1.TYPE_VALUE,
      Cache: base_config_1.TYPE_VALUE,
      CacheStorage: base_config_1.TYPE_VALUE,
      CanvasCompositing: base_config_1.TYPE,
      CanvasDrawImage: base_config_1.TYPE,
      CanvasDrawPath: base_config_1.TYPE,
      CanvasFillStrokeStyles: base_config_1.TYPE,
      CanvasFilters: base_config_1.TYPE,
      CanvasGradient: base_config_1.TYPE_VALUE,
      CanvasImageData: base_config_1.TYPE,
      CanvasImageSmoothing: base_config_1.TYPE,
      CanvasPath: base_config_1.TYPE,
      CanvasPathDrawingStyles: base_config_1.TYPE,
      CanvasPattern: base_config_1.TYPE_VALUE,
      CanvasRect: base_config_1.TYPE,
      CanvasShadowStyles: base_config_1.TYPE,
      CanvasState: base_config_1.TYPE,
      CanvasText: base_config_1.TYPE,
      CanvasTextDrawingStyles: base_config_1.TYPE,
      CanvasTransform: base_config_1.TYPE,
      Client: base_config_1.TYPE_VALUE,
      Clients: base_config_1.TYPE_VALUE,
      CloseEvent: base_config_1.TYPE_VALUE,
      CountQueuingStrategy: base_config_1.TYPE_VALUE,
      Crypto: base_config_1.TYPE_VALUE,
      CryptoKey: base_config_1.TYPE_VALUE,
      CustomEvent: base_config_1.TYPE_VALUE,
      DOMException: base_config_1.TYPE_VALUE,
      DOMMatrix: base_config_1.TYPE_VALUE,
      DOMMatrixReadOnly: base_config_1.TYPE_VALUE,
      DOMPoint: base_config_1.TYPE_VALUE,
      DOMPointReadOnly: base_config_1.TYPE_VALUE,
      DOMQuad: base_config_1.TYPE_VALUE,
      DOMRect: base_config_1.TYPE_VALUE,
      DOMRectReadOnly: base_config_1.TYPE_VALUE,
      DOMStringList: base_config_1.TYPE_VALUE,
      DedicatedWorkerGlobalScopeEventMap: base_config_1.TYPE,
      DedicatedWorkerGlobalScope: base_config_1.TYPE_VALUE,
      EXT_blend_minmax: base_config_1.TYPE,
      EXT_color_buffer_float: base_config_1.TYPE,
      EXT_color_buffer_half_float: base_config_1.TYPE,
      EXT_float_blend: base_config_1.TYPE,
      EXT_frag_depth: base_config_1.TYPE,
      EXT_sRGB: base_config_1.TYPE,
      EXT_shader_texture_lod: base_config_1.TYPE,
      EXT_texture_compression_bptc: base_config_1.TYPE,
      EXT_texture_compression_rgtc: base_config_1.TYPE,
      EXT_texture_filter_anisotropic: base_config_1.TYPE,
      EXT_texture_norm16: base_config_1.TYPE,
      ErrorEvent: base_config_1.TYPE_VALUE,
      Event: base_config_1.TYPE_VALUE,
      EventListener: base_config_1.TYPE,
      EventListenerObject: base_config_1.TYPE,
      EventSourceEventMap: base_config_1.TYPE,
      EventSource: base_config_1.TYPE_VALUE,
      EventTarget: base_config_1.TYPE_VALUE,
      ExtendableEvent: base_config_1.TYPE_VALUE,
      ExtendableMessageEvent: base_config_1.TYPE_VALUE,
      FetchEvent: base_config_1.TYPE_VALUE,
      File: base_config_1.TYPE_VALUE,
      FileList: base_config_1.TYPE_VALUE,
      FileReaderEventMap: base_config_1.TYPE,
      FileReader: base_config_1.TYPE_VALUE,
      FileReaderSync: base_config_1.TYPE_VALUE,
      FileSystemDirectoryHandle: base_config_1.TYPE_VALUE,
      FileSystemFileHandle: base_config_1.TYPE_VALUE,
      FileSystemHandle: base_config_1.TYPE_VALUE,
      FileSystemSyncAccessHandle: base_config_1.TYPE_VALUE,
      FontFace: base_config_1.TYPE_VALUE,
      FontFaceSetEventMap: base_config_1.TYPE,
      FontFaceSet: base_config_1.TYPE_VALUE,
      FontFaceSetLoadEvent: base_config_1.TYPE_VALUE,
      FontFaceSource: base_config_1.TYPE,
      FormData: base_config_1.TYPE_VALUE,
      GenericTransformStream: base_config_1.TYPE,
      Headers: base_config_1.TYPE_VALUE,
      IDBCursor: base_config_1.TYPE_VALUE,
      IDBCursorWithValue: base_config_1.TYPE_VALUE,
      IDBDatabaseEventMap: base_config_1.TYPE,
      IDBDatabase: base_config_1.TYPE_VALUE,
      IDBFactory: base_config_1.TYPE_VALUE,
      IDBIndex: base_config_1.TYPE_VALUE,
      IDBKeyRange: base_config_1.TYPE_VALUE,
      IDBObjectStore: base_config_1.TYPE_VALUE,
      IDBOpenDBRequestEventMap: base_config_1.TYPE,
      IDBOpenDBRequest: base_config_1.TYPE_VALUE,
      IDBRequestEventMap: base_config_1.TYPE,
      IDBRequest: base_config_1.TYPE_VALUE,
      IDBTransactionEventMap: base_config_1.TYPE,
      IDBTransaction: base_config_1.TYPE_VALUE,
      IDBVersionChangeEvent: base_config_1.TYPE_VALUE,
      ImageBitmap: base_config_1.TYPE_VALUE,
      ImageBitmapRenderingContext: base_config_1.TYPE_VALUE,
      ImageData: base_config_1.TYPE_VALUE,
      KHR_parallel_shader_compile: base_config_1.TYPE,
      Lock: base_config_1.TYPE_VALUE,
      LockManager: base_config_1.TYPE_VALUE,
      MediaCapabilities: base_config_1.TYPE_VALUE,
      MessageChannel: base_config_1.TYPE_VALUE,
      MessageEvent: base_config_1.TYPE_VALUE,
      MessagePortEventMap: base_config_1.TYPE,
      MessagePort: base_config_1.TYPE_VALUE,
      NavigationPreloadManager: base_config_1.TYPE_VALUE,
      NavigatorConcurrentHardware: base_config_1.TYPE,
      NavigatorID: base_config_1.TYPE,
      NavigatorLanguage: base_config_1.TYPE,
      NavigatorLocks: base_config_1.TYPE,
      NavigatorOnLine: base_config_1.TYPE,
      NavigatorStorage: base_config_1.TYPE,
      NotificationEventMap: base_config_1.TYPE,
      Notification: base_config_1.TYPE_VALUE,
      NotificationEvent: base_config_1.TYPE_VALUE,
      OES_draw_buffers_indexed: base_config_1.TYPE,
      OES_element_index_uint: base_config_1.TYPE,
      OES_fbo_render_mipmap: base_config_1.TYPE,
      OES_standard_derivatives: base_config_1.TYPE,
      OES_texture_float: base_config_1.TYPE,
      OES_texture_float_linear: base_config_1.TYPE,
      OES_texture_half_float: base_config_1.TYPE,
      OES_texture_half_float_linear: base_config_1.TYPE,
      OES_vertex_array_object: base_config_1.TYPE,
      OVR_multiview2: base_config_1.TYPE,
      OffscreenCanvasEventMap: base_config_1.TYPE,
      OffscreenCanvas: base_config_1.TYPE_VALUE,
      OffscreenCanvasRenderingContext2D: base_config_1.TYPE_VALUE,
      Path2D: base_config_1.TYPE_VALUE,
      PerformanceEventMap: base_config_1.TYPE,
      Performance: base_config_1.TYPE_VALUE,
      PerformanceEntry: base_config_1.TYPE_VALUE,
      PerformanceMark: base_config_1.TYPE_VALUE,
      PerformanceMeasure: base_config_1.TYPE_VALUE,
      PerformanceObserver: base_config_1.TYPE_VALUE,
      PerformanceObserverEntryList: base_config_1.TYPE_VALUE,
      PerformanceResourceTiming: base_config_1.TYPE_VALUE,
      PerformanceServerTiming: base_config_1.TYPE_VALUE,
      PermissionStatusEventMap: base_config_1.TYPE,
      PermissionStatus: base_config_1.TYPE_VALUE,
      Permissions: base_config_1.TYPE_VALUE,
      ProgressEvent: base_config_1.TYPE_VALUE,
      PromiseRejectionEvent: base_config_1.TYPE_VALUE,
      PushEvent: base_config_1.TYPE_VALUE,
      PushManager: base_config_1.TYPE_VALUE,
      PushMessageData: base_config_1.TYPE_VALUE,
      PushSubscription: base_config_1.TYPE_VALUE,
      PushSubscriptionOptions: base_config_1.TYPE_VALUE,
      RTCEncodedAudioFrame: base_config_1.TYPE_VALUE,
      RTCEncodedVideoFrame: base_config_1.TYPE_VALUE,
      ReadableByteStreamController: base_config_1.TYPE_VALUE,
      ReadableStream: base_config_1.TYPE_VALUE,
      ReadableStreamBYOBReader: base_config_1.TYPE_VALUE,
      ReadableStreamBYOBRequest: base_config_1.TYPE_VALUE,
      ReadableStreamDefaultController: base_config_1.TYPE_VALUE,
      ReadableStreamDefaultReader: base_config_1.TYPE_VALUE,
      ReadableStreamGenericReader: base_config_1.TYPE,
      Request: base_config_1.TYPE_VALUE,
      Response: base_config_1.TYPE_VALUE,
      SecurityPolicyViolationEvent: base_config_1.TYPE_VALUE,
      ServiceWorkerEventMap: base_config_1.TYPE,
      ServiceWorker: base_config_1.TYPE_VALUE,
      ServiceWorkerContainerEventMap: base_config_1.TYPE,
      ServiceWorkerContainer: base_config_1.TYPE_VALUE,
      ServiceWorkerGlobalScopeEventMap: base_config_1.TYPE,
      ServiceWorkerGlobalScope: base_config_1.TYPE_VALUE,
      ServiceWorkerRegistrationEventMap: base_config_1.TYPE,
      ServiceWorkerRegistration: base_config_1.TYPE_VALUE,
      SharedWorkerGlobalScopeEventMap: base_config_1.TYPE,
      SharedWorkerGlobalScope: base_config_1.TYPE_VALUE,
      StorageManager: base_config_1.TYPE_VALUE,
      SubtleCrypto: base_config_1.TYPE_VALUE,
      TextDecoder: base_config_1.TYPE_VALUE,
      TextDecoderCommon: base_config_1.TYPE,
      TextDecoderStream: base_config_1.TYPE_VALUE,
      TextEncoder: base_config_1.TYPE_VALUE,
      TextEncoderCommon: base_config_1.TYPE,
      TextEncoderStream: base_config_1.TYPE_VALUE,
      TextMetrics: base_config_1.TYPE_VALUE,
      TransformStream: base_config_1.TYPE_VALUE,
      TransformStreamDefaultController: base_config_1.TYPE_VALUE,
      URL: base_config_1.TYPE_VALUE,
      URLSearchParams: base_config_1.TYPE_VALUE,
      VideoColorSpace: base_config_1.TYPE_VALUE,
      WEBGL_color_buffer_float: base_config_1.TYPE,
      WEBGL_compressed_texture_astc: base_config_1.TYPE,
      WEBGL_compressed_texture_etc: base_config_1.TYPE,
      WEBGL_compressed_texture_etc1: base_config_1.TYPE,
      WEBGL_compressed_texture_s3tc: base_config_1.TYPE,
      WEBGL_compressed_texture_s3tc_srgb: base_config_1.TYPE,
      WEBGL_debug_renderer_info: base_config_1.TYPE,
      WEBGL_debug_shaders: base_config_1.TYPE,
      WEBGL_depth_texture: base_config_1.TYPE,
      WEBGL_draw_buffers: base_config_1.TYPE,
      WEBGL_lose_context: base_config_1.TYPE,
      WEBGL_multi_draw: base_config_1.TYPE,
      WebGL2RenderingContext: base_config_1.TYPE_VALUE,
      WebGL2RenderingContextBase: base_config_1.TYPE,
      WebGL2RenderingContextOverloads: base_config_1.TYPE,
      WebGLActiveInfo: base_config_1.TYPE_VALUE,
      WebGLBuffer: base_config_1.TYPE_VALUE,
      WebGLContextEvent: base_config_1.TYPE_VALUE,
      WebGLFramebuffer: base_config_1.TYPE_VALUE,
      WebGLProgram: base_config_1.TYPE_VALUE,
      WebGLQuery: base_config_1.TYPE_VALUE,
      WebGLRenderbuffer: base_config_1.TYPE_VALUE,
      WebGLRenderingContext: base_config_1.TYPE_VALUE,
      WebGLRenderingContextBase: base_config_1.TYPE,
      WebGLRenderingContextOverloads: base_config_1.TYPE,
      WebGLSampler: base_config_1.TYPE_VALUE,
      WebGLShader: base_config_1.TYPE_VALUE,
      WebGLShaderPrecisionFormat: base_config_1.TYPE_VALUE,
      WebGLSync: base_config_1.TYPE_VALUE,
      WebGLTexture: base_config_1.TYPE_VALUE,
      WebGLTransformFeedback: base_config_1.TYPE_VALUE,
      WebGLUniformLocation: base_config_1.TYPE_VALUE,
      WebGLVertexArrayObject: base_config_1.TYPE_VALUE,
      WebGLVertexArrayObjectOES: base_config_1.TYPE,
      WebSocketEventMap: base_config_1.TYPE,
      WebSocket: base_config_1.TYPE_VALUE,
      WindowClient: base_config_1.TYPE_VALUE,
      WindowOrWorkerGlobalScope: base_config_1.TYPE,
      WorkerEventMap: base_config_1.TYPE,
      Worker: base_config_1.TYPE_VALUE,
      WorkerGlobalScopeEventMap: base_config_1.TYPE,
      WorkerGlobalScope: base_config_1.TYPE_VALUE,
      WorkerLocation: base_config_1.TYPE_VALUE,
      WorkerNavigator: base_config_1.TYPE_VALUE,
      WritableStream: base_config_1.TYPE_VALUE,
      WritableStreamDefaultController: base_config_1.TYPE_VALUE,
      WritableStreamDefaultWriter: base_config_1.TYPE_VALUE,
      XMLHttpRequestEventMap: base_config_1.TYPE,
      XMLHttpRequest: base_config_1.TYPE_VALUE,
      XMLHttpRequestEventTargetEventMap: base_config_1.TYPE,
      XMLHttpRequestEventTarget: base_config_1.TYPE_VALUE,
      XMLHttpRequestUpload: base_config_1.TYPE_VALUE,
      Console: base_config_1.TYPE,
      WebAssembly: base_config_1.TYPE_VALUE,
      FrameRequestCallback: base_config_1.TYPE,
      LockGrantedCallback: base_config_1.TYPE,
      OnErrorEventHandlerNonNull: base_config_1.TYPE,
      PerformanceObserverCallback: base_config_1.TYPE,
      QueuingStrategySize: base_config_1.TYPE,
      TransformerFlushCallback: base_config_1.TYPE,
      TransformerStartCallback: base_config_1.TYPE,
      TransformerTransformCallback: base_config_1.TYPE,
      UnderlyingSinkAbortCallback: base_config_1.TYPE,
      UnderlyingSinkCloseCallback: base_config_1.TYPE,
      UnderlyingSinkStartCallback: base_config_1.TYPE,
      UnderlyingSinkWriteCallback: base_config_1.TYPE,
      UnderlyingSourceCancelCallback: base_config_1.TYPE,
      UnderlyingSourcePullCallback: base_config_1.TYPE,
      UnderlyingSourceStartCallback: base_config_1.TYPE,
      VoidFunction: base_config_1.TYPE,
      AlgorithmIdentifier: base_config_1.TYPE,
      BigInteger: base_config_1.TYPE,
      BinaryData: base_config_1.TYPE,
      BlobPart: base_config_1.TYPE,
      BodyInit: base_config_1.TYPE,
      BufferSource: base_config_1.TYPE,
      CanvasImageSource: base_config_1.TYPE,
      DOMHighResTimeStamp: base_config_1.TYPE,
      EpochTimeStamp: base_config_1.TYPE,
      EventListenerOrEventListenerObject: base_config_1.TYPE,
      Float32List: base_config_1.TYPE,
      FormDataEntryValue: base_config_1.TYPE,
      GLbitfield: base_config_1.TYPE,
      GLboolean: base_config_1.TYPE,
      GLclampf: base_config_1.TYPE,
      GLenum: base_config_1.TYPE,
      GLfloat: base_config_1.TYPE,
      GLint: base_config_1.TYPE,
      GLint64: base_config_1.TYPE,
      GLintptr: base_config_1.TYPE,
      GLsizei: base_config_1.TYPE,
      GLsizeiptr: base_config_1.TYPE,
      GLuint: base_config_1.TYPE,
      GLuint64: base_config_1.TYPE,
      HashAlgorithmIdentifier: base_config_1.TYPE,
      HeadersInit: base_config_1.TYPE,
      IDBValidKey: base_config_1.TYPE,
      ImageBitmapSource: base_config_1.TYPE,
      Int32List: base_config_1.TYPE,
      MessageEventSource: base_config_1.TYPE,
      NamedCurve: base_config_1.TYPE,
      OffscreenRenderingContext: base_config_1.TYPE,
      OnErrorEventHandler: base_config_1.TYPE,
      PerformanceEntryList: base_config_1.TYPE,
      PushMessageDataInit: base_config_1.TYPE,
      ReadableStreamController: base_config_1.TYPE,
      ReadableStreamReadResult: base_config_1.TYPE,
      ReadableStreamReader: base_config_1.TYPE,
      RequestInfo: base_config_1.TYPE,
      TexImageSource: base_config_1.TYPE,
      TimerHandler: base_config_1.TYPE,
      Transferable: base_config_1.TYPE,
      Uint32List: base_config_1.TYPE,
      VibratePattern: base_config_1.TYPE,
      XMLHttpRequestBodyInit: base_config_1.TYPE,
      BinaryType: base_config_1.TYPE,
      CanvasDirection: base_config_1.TYPE,
      CanvasFillRule: base_config_1.TYPE,
      CanvasFontKerning: base_config_1.TYPE,
      CanvasFontStretch: base_config_1.TYPE,
      CanvasFontVariantCaps: base_config_1.TYPE,
      CanvasLineCap: base_config_1.TYPE,
      CanvasLineJoin: base_config_1.TYPE,
      CanvasTextAlign: base_config_1.TYPE,
      CanvasTextBaseline: base_config_1.TYPE,
      CanvasTextRendering: base_config_1.TYPE,
      ClientTypes: base_config_1.TYPE,
      ColorGamut: base_config_1.TYPE,
      ColorSpaceConversion: base_config_1.TYPE,
      DocumentVisibilityState: base_config_1.TYPE,
      EndingType: base_config_1.TYPE,
      FileSystemHandleKind: base_config_1.TYPE,
      FontDisplay: base_config_1.TYPE,
      FontFaceLoadStatus: base_config_1.TYPE,
      FontFaceSetLoadStatus: base_config_1.TYPE,
      FrameType: base_config_1.TYPE,
      GlobalCompositeOperation: base_config_1.TYPE,
      HdrMetadataType: base_config_1.TYPE,
      IDBCursorDirection: base_config_1.TYPE,
      IDBRequestReadyState: base_config_1.TYPE,
      IDBTransactionDurability: base_config_1.TYPE,
      IDBTransactionMode: base_config_1.TYPE,
      ImageOrientation: base_config_1.TYPE,
      ImageSmoothingQuality: base_config_1.TYPE,
      KeyFormat: base_config_1.TYPE,
      KeyType: base_config_1.TYPE,
      KeyUsage: base_config_1.TYPE,
      LockMode: base_config_1.TYPE,
      MediaDecodingType: base_config_1.TYPE,
      MediaEncodingType: base_config_1.TYPE,
      NotificationDirection: base_config_1.TYPE,
      NotificationPermission: base_config_1.TYPE,
      OffscreenRenderingContextId: base_config_1.TYPE,
      PermissionName: base_config_1.TYPE,
      PermissionState: base_config_1.TYPE,
      PredefinedColorSpace: base_config_1.TYPE,
      PremultiplyAlpha: base_config_1.TYPE,
      PushEncryptionKeyName: base_config_1.TYPE,
      RTCEncodedVideoFrameType: base_config_1.TYPE,
      ReadableStreamReaderMode: base_config_1.TYPE,
      ReadableStreamType: base_config_1.TYPE,
      ReferrerPolicy: base_config_1.TYPE,
      RequestCache: base_config_1.TYPE,
      RequestCredentials: base_config_1.TYPE,
      RequestDestination: base_config_1.TYPE,
      RequestMode: base_config_1.TYPE,
      RequestRedirect: base_config_1.TYPE,
      ResizeQuality: base_config_1.TYPE,
      ResponseType: base_config_1.TYPE,
      SecurityPolicyViolationEventDisposition: base_config_1.TYPE,
      ServiceWorkerState: base_config_1.TYPE,
      ServiceWorkerUpdateViaCache: base_config_1.TYPE,
      TransferFunction: base_config_1.TYPE,
      VideoColorPrimaries: base_config_1.TYPE,
      VideoMatrixCoefficients: base_config_1.TYPE,
      VideoTransferCharacteristics: base_config_1.TYPE,
      WebGLPowerPreference: base_config_1.TYPE,
      WorkerType: base_config_1.TYPE,
      XMLHttpRequestResponseType: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/webworker.iterable.js
var require_webworker_iterable = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/webworker.iterable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.webworker_iterable = void 0;
    var base_config_1 = require_base_config();
    exports.webworker_iterable = {
      Cache: base_config_1.TYPE,
      CanvasPath: base_config_1.TYPE,
      CanvasPathDrawingStyles: base_config_1.TYPE,
      DOMStringList: base_config_1.TYPE,
      FileList: base_config_1.TYPE,
      FontFaceSet: base_config_1.TYPE,
      FormData: base_config_1.TYPE,
      Headers: base_config_1.TYPE,
      IDBDatabase: base_config_1.TYPE,
      IDBObjectStore: base_config_1.TYPE,
      MessageEvent: base_config_1.TYPE,
      SubtleCrypto: base_config_1.TYPE,
      URLSearchParams: base_config_1.TYPE,
      WEBGL_draw_buffers: base_config_1.TYPE,
      WEBGL_multi_draw: base_config_1.TYPE,
      WebGL2RenderingContextBase: base_config_1.TYPE,
      WebGL2RenderingContextOverloads: base_config_1.TYPE,
      WebGLRenderingContextBase: base_config_1.TYPE,
      WebGLRenderingContextOverloads: base_config_1.TYPE
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lib = void 0;
    var decorators_1 = require_decorators();
    var decorators_legacy_1 = require_decorators_legacy();
    var dom_1 = require_dom();
    var dom_iterable_1 = require_dom_iterable();
    var es5_1 = require_es5();
    var es6_1 = require_es6();
    var es7_1 = require_es7();
    var es2015_1 = require_es2015();
    var es2015_collection_1 = require_es2015_collection();
    var es2015_core_1 = require_es2015_core();
    var es2015_generator_1 = require_es2015_generator();
    var es2015_iterable_1 = require_es2015_iterable();
    var es2015_promise_1 = require_es2015_promise();
    var es2015_proxy_1 = require_es2015_proxy();
    var es2015_reflect_1 = require_es2015_reflect();
    var es2015_symbol_1 = require_es2015_symbol();
    var es2015_symbol_wellknown_1 = require_es2015_symbol_wellknown();
    var es2016_1 = require_es2016();
    var es2016_array_include_1 = require_es2016_array_include();
    var es2016_full_1 = require_es2016_full();
    var es2017_1 = require_es2017();
    var es2017_full_1 = require_es2017_full();
    var es2017_intl_1 = require_es2017_intl();
    var es2017_object_1 = require_es2017_object();
    var es2017_sharedmemory_1 = require_es2017_sharedmemory();
    var es2017_string_1 = require_es2017_string();
    var es2017_typedarrays_1 = require_es2017_typedarrays();
    var es2018_1 = require_es2018();
    var es2018_asyncgenerator_1 = require_es2018_asyncgenerator();
    var es2018_asynciterable_1 = require_es2018_asynciterable();
    var es2018_full_1 = require_es2018_full();
    var es2018_intl_1 = require_es2018_intl();
    var es2018_promise_1 = require_es2018_promise();
    var es2018_regexp_1 = require_es2018_regexp();
    var es2019_1 = require_es2019();
    var es2019_array_1 = require_es2019_array();
    var es2019_full_1 = require_es2019_full();
    var es2019_intl_1 = require_es2019_intl();
    var es2019_object_1 = require_es2019_object();
    var es2019_string_1 = require_es2019_string();
    var es2019_symbol_1 = require_es2019_symbol();
    var es2020_1 = require_es2020();
    var es2020_bigint_1 = require_es2020_bigint();
    var es2020_date_1 = require_es2020_date();
    var es2020_full_1 = require_es2020_full();
    var es2020_intl_1 = require_es2020_intl();
    var es2020_number_1 = require_es2020_number();
    var es2020_promise_1 = require_es2020_promise();
    var es2020_sharedmemory_1 = require_es2020_sharedmemory();
    var es2020_string_1 = require_es2020_string();
    var es2020_symbol_wellknown_1 = require_es2020_symbol_wellknown();
    var es2021_1 = require_es2021();
    var es2021_full_1 = require_es2021_full();
    var es2021_intl_1 = require_es2021_intl();
    var es2021_promise_1 = require_es2021_promise();
    var es2021_string_1 = require_es2021_string();
    var es2021_weakref_1 = require_es2021_weakref();
    var es2022_1 = require_es2022();
    var es2022_array_1 = require_es2022_array();
    var es2022_error_1 = require_es2022_error();
    var es2022_full_1 = require_es2022_full();
    var es2022_intl_1 = require_es2022_intl();
    var es2022_object_1 = require_es2022_object();
    var es2022_regexp_1 = require_es2022_regexp();
    var es2022_sharedmemory_1 = require_es2022_sharedmemory();
    var es2022_string_1 = require_es2022_string();
    var es2023_1 = require_es2023();
    var es2023_array_1 = require_es2023_array();
    var es2023_full_1 = require_es2023_full();
    var esnext_1 = require_esnext();
    var esnext_array_1 = require_esnext_array();
    var esnext_asynciterable_1 = require_esnext_asynciterable();
    var esnext_bigint_1 = require_esnext_bigint();
    var esnext_full_1 = require_esnext_full();
    var esnext_intl_1 = require_esnext_intl();
    var esnext_promise_1 = require_esnext_promise();
    var esnext_string_1 = require_esnext_string();
    var esnext_symbol_1 = require_esnext_symbol();
    var esnext_weakref_1 = require_esnext_weakref();
    var lib_1 = require_lib2();
    var scripthost_1 = require_scripthost();
    var webworker_1 = require_webworker();
    var webworker_importscripts_1 = require_webworker_importscripts();
    var webworker_iterable_1 = require_webworker_iterable();
    var lib = {
      es5: es5_1.es5,
      es6: es6_1.es6,
      es2015: es2015_1.es2015,
      es7: es7_1.es7,
      es2016: es2016_1.es2016,
      es2017: es2017_1.es2017,
      es2018: es2018_1.es2018,
      es2019: es2019_1.es2019,
      es2020: es2020_1.es2020,
      es2021: es2021_1.es2021,
      es2022: es2022_1.es2022,
      es2023: es2023_1.es2023,
      esnext: esnext_1.esnext,
      dom: dom_1.dom,
      "dom.iterable": dom_iterable_1.dom_iterable,
      webworker: webworker_1.webworker,
      "webworker.importscripts": webworker_importscripts_1.webworker_importscripts,
      "webworker.iterable": webworker_iterable_1.webworker_iterable,
      scripthost: scripthost_1.scripthost,
      "es2015.core": es2015_core_1.es2015_core,
      "es2015.collection": es2015_collection_1.es2015_collection,
      "es2015.generator": es2015_generator_1.es2015_generator,
      "es2015.iterable": es2015_iterable_1.es2015_iterable,
      "es2015.promise": es2015_promise_1.es2015_promise,
      "es2015.proxy": es2015_proxy_1.es2015_proxy,
      "es2015.reflect": es2015_reflect_1.es2015_reflect,
      "es2015.symbol": es2015_symbol_1.es2015_symbol,
      "es2015.symbol.wellknown": es2015_symbol_wellknown_1.es2015_symbol_wellknown,
      "es2016.array.include": es2016_array_include_1.es2016_array_include,
      "es2017.object": es2017_object_1.es2017_object,
      "es2017.sharedmemory": es2017_sharedmemory_1.es2017_sharedmemory,
      "es2017.string": es2017_string_1.es2017_string,
      "es2017.intl": es2017_intl_1.es2017_intl,
      "es2017.typedarrays": es2017_typedarrays_1.es2017_typedarrays,
      "es2018.asyncgenerator": es2018_asyncgenerator_1.es2018_asyncgenerator,
      "es2018.asynciterable": es2018_asynciterable_1.es2018_asynciterable,
      "es2018.intl": es2018_intl_1.es2018_intl,
      "es2018.promise": es2018_promise_1.es2018_promise,
      "es2018.regexp": es2018_regexp_1.es2018_regexp,
      "es2019.array": es2019_array_1.es2019_array,
      "es2019.object": es2019_object_1.es2019_object,
      "es2019.string": es2019_string_1.es2019_string,
      "es2019.symbol": es2019_symbol_1.es2019_symbol,
      "es2019.intl": es2019_intl_1.es2019_intl,
      "es2020.bigint": es2020_bigint_1.es2020_bigint,
      "es2020.date": es2020_date_1.es2020_date,
      "es2020.promise": es2020_promise_1.es2020_promise,
      "es2020.sharedmemory": es2020_sharedmemory_1.es2020_sharedmemory,
      "es2020.string": es2020_string_1.es2020_string,
      "es2020.symbol.wellknown": es2020_symbol_wellknown_1.es2020_symbol_wellknown,
      "es2020.intl": es2020_intl_1.es2020_intl,
      "es2020.number": es2020_number_1.es2020_number,
      "es2021.promise": es2021_promise_1.es2021_promise,
      "es2021.string": es2021_string_1.es2021_string,
      "es2021.weakref": es2021_weakref_1.es2021_weakref,
      "es2021.intl": es2021_intl_1.es2021_intl,
      "es2022.array": es2022_array_1.es2022_array,
      "es2022.error": es2022_error_1.es2022_error,
      "es2022.intl": es2022_intl_1.es2022_intl,
      "es2022.object": es2022_object_1.es2022_object,
      "es2022.sharedmemory": es2022_sharedmemory_1.es2022_sharedmemory,
      "es2022.string": es2022_string_1.es2022_string,
      "es2022.regexp": es2022_regexp_1.es2022_regexp,
      "es2023.array": es2023_array_1.es2023_array,
      "esnext.array": esnext_array_1.esnext_array,
      "esnext.symbol": esnext_symbol_1.esnext_symbol,
      "esnext.asynciterable": esnext_asynciterable_1.esnext_asynciterable,
      "esnext.intl": esnext_intl_1.esnext_intl,
      "esnext.bigint": esnext_bigint_1.esnext_bigint,
      "esnext.string": esnext_string_1.esnext_string,
      "esnext.promise": esnext_promise_1.esnext_promise,
      "esnext.weakref": esnext_weakref_1.esnext_weakref,
      decorators: decorators_1.decorators,
      "decorators.legacy": decorators_legacy_1.decorators_legacy,
      "es2016.full": es2016_full_1.es2016_full,
      "es2017.full": es2017_full_1.es2017_full,
      "es2018.full": es2018_full_1.es2018_full,
      "es2019.full": es2019_full_1.es2019_full,
      "es2020.full": es2020_full_1.es2020_full,
      "es2021.full": es2021_full_1.es2021_full,
      "es2022.full": es2022_full_1.es2022_full,
      "es2023.full": es2023_full_1.es2023_full,
      "esnext.full": esnext_full_1.esnext_full,
      lib: lib_1.lib
    };
    exports.lib = lib;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/assert.js
var require_assert = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assert = void 0;
    function assert(value, message) {
      if (value == null) {
        throw new Error(message);
      }
    }
    exports.assert = assert;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/ID.js
var require_ID = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/ID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resetIds = exports.createIdGenerator = void 0;
    var ID_CACHE = /* @__PURE__ */ new Map();
    var NEXT_KEY = 0;
    function createIdGenerator() {
      const key = NEXT_KEY += 1;
      ID_CACHE.set(key, 0);
      return () => {
        var _a2;
        const current = (_a2 = ID_CACHE.get(key)) !== null && _a2 !== void 0 ? _a2 : 0;
        const next = current + 1;
        ID_CACHE.set(key, next);
        return next;
      };
    }
    exports.createIdGenerator = createIdGenerator;
    function resetIds() {
      ID_CACHE.clear();
    }
    exports.resetIds = resetIds;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/DefinitionBase.js
var require_DefinitionBase = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/DefinitionBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefinitionBase = void 0;
    var ID_1 = require_ID();
    var generator = (0, ID_1.createIdGenerator)();
    var DefinitionBase = class {
      constructor(type, name, node, parent) {
        this.$id = generator();
        this.type = type;
        this.name = name;
        this.node = node;
        this.parent = parent;
      }
    };
    exports.DefinitionBase = DefinitionBase;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/DefinitionType.js
var require_DefinitionType = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/DefinitionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefinitionType = void 0;
    var DefinitionType;
    (function(DefinitionType2) {
      DefinitionType2["CatchClause"] = "CatchClause";
      DefinitionType2["ClassName"] = "ClassName";
      DefinitionType2["FunctionName"] = "FunctionName";
      DefinitionType2["ImplicitGlobalVariable"] = "ImplicitGlobalVariable";
      DefinitionType2["ImportBinding"] = "ImportBinding";
      DefinitionType2["Parameter"] = "Parameter";
      DefinitionType2["TSEnumName"] = "TSEnumName";
      DefinitionType2["TSEnumMember"] = "TSEnumMemberName";
      DefinitionType2["TSModuleName"] = "TSModuleName";
      DefinitionType2["Type"] = "Type";
      DefinitionType2["Variable"] = "Variable";
    })(DefinitionType || (DefinitionType = {}));
    exports.DefinitionType = DefinitionType;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/CatchClauseDefinition.js
var require_CatchClauseDefinition = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/CatchClauseDefinition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CatchClauseDefinition = void 0;
    var DefinitionBase_1 = require_DefinitionBase();
    var DefinitionType_1 = require_DefinitionType();
    var CatchClauseDefinition = class extends DefinitionBase_1.DefinitionBase {
      constructor(name, node) {
        super(DefinitionType_1.DefinitionType.CatchClause, name, node, null);
        this.isTypeDefinition = false;
        this.isVariableDefinition = true;
      }
    };
    exports.CatchClauseDefinition = CatchClauseDefinition;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/ClassNameDefinition.js
var require_ClassNameDefinition = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/ClassNameDefinition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassNameDefinition = void 0;
    var DefinitionBase_1 = require_DefinitionBase();
    var DefinitionType_1 = require_DefinitionType();
    var ClassNameDefinition = class extends DefinitionBase_1.DefinitionBase {
      constructor(name, node) {
        super(DefinitionType_1.DefinitionType.ClassName, name, node, null);
        this.isTypeDefinition = true;
        this.isVariableDefinition = true;
      }
    };
    exports.ClassNameDefinition = ClassNameDefinition;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/Definition.js
var require_Definition = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/Definition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/FunctionNameDefinition.js
var require_FunctionNameDefinition = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/FunctionNameDefinition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FunctionNameDefinition = void 0;
    var DefinitionBase_1 = require_DefinitionBase();
    var DefinitionType_1 = require_DefinitionType();
    var FunctionNameDefinition = class extends DefinitionBase_1.DefinitionBase {
      constructor(name, node) {
        super(DefinitionType_1.DefinitionType.FunctionName, name, node, null);
        this.isTypeDefinition = false;
        this.isVariableDefinition = true;
      }
    };
    exports.FunctionNameDefinition = FunctionNameDefinition;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/ImplicitGlobalVariableDefinition.js
var require_ImplicitGlobalVariableDefinition = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/ImplicitGlobalVariableDefinition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImplicitGlobalVariableDefinition = void 0;
    var DefinitionBase_1 = require_DefinitionBase();
    var DefinitionType_1 = require_DefinitionType();
    var ImplicitGlobalVariableDefinition = class extends DefinitionBase_1.DefinitionBase {
      constructor(name, node) {
        super(DefinitionType_1.DefinitionType.ImplicitGlobalVariable, name, node, null);
        this.isTypeDefinition = false;
        this.isVariableDefinition = true;
      }
    };
    exports.ImplicitGlobalVariableDefinition = ImplicitGlobalVariableDefinition;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/ImportBindingDefinition.js
var require_ImportBindingDefinition = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/ImportBindingDefinition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImportBindingDefinition = void 0;
    var DefinitionBase_1 = require_DefinitionBase();
    var DefinitionType_1 = require_DefinitionType();
    var ImportBindingDefinition = class extends DefinitionBase_1.DefinitionBase {
      constructor(name, node, decl) {
        super(DefinitionType_1.DefinitionType.ImportBinding, name, node, decl);
        this.isTypeDefinition = true;
        this.isVariableDefinition = true;
      }
    };
    exports.ImportBindingDefinition = ImportBindingDefinition;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/ParameterDefinition.js
var require_ParameterDefinition = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/ParameterDefinition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParameterDefinition = void 0;
    var DefinitionBase_1 = require_DefinitionBase();
    var DefinitionType_1 = require_DefinitionType();
    var ParameterDefinition = class extends DefinitionBase_1.DefinitionBase {
      constructor(name, node, rest) {
        super(DefinitionType_1.DefinitionType.Parameter, name, node, null);
        this.isTypeDefinition = false;
        this.isVariableDefinition = true;
        this.rest = rest;
      }
    };
    exports.ParameterDefinition = ParameterDefinition;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/TSEnumMemberDefinition.js
var require_TSEnumMemberDefinition = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/TSEnumMemberDefinition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TSEnumMemberDefinition = void 0;
    var DefinitionBase_1 = require_DefinitionBase();
    var DefinitionType_1 = require_DefinitionType();
    var TSEnumMemberDefinition = class extends DefinitionBase_1.DefinitionBase {
      constructor(name, node) {
        super(DefinitionType_1.DefinitionType.TSEnumMember, name, node, null);
        this.isTypeDefinition = true;
        this.isVariableDefinition = true;
      }
    };
    exports.TSEnumMemberDefinition = TSEnumMemberDefinition;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/TSEnumNameDefinition.js
var require_TSEnumNameDefinition = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/TSEnumNameDefinition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TSEnumNameDefinition = void 0;
    var DefinitionBase_1 = require_DefinitionBase();
    var DefinitionType_1 = require_DefinitionType();
    var TSEnumNameDefinition = class extends DefinitionBase_1.DefinitionBase {
      constructor(name, node) {
        super(DefinitionType_1.DefinitionType.TSEnumName, name, node, null);
        this.isTypeDefinition = true;
        this.isVariableDefinition = true;
      }
    };
    exports.TSEnumNameDefinition = TSEnumNameDefinition;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/TSModuleNameDefinition.js
var require_TSModuleNameDefinition = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/TSModuleNameDefinition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TSModuleNameDefinition = void 0;
    var DefinitionBase_1 = require_DefinitionBase();
    var DefinitionType_1 = require_DefinitionType();
    var TSModuleNameDefinition = class extends DefinitionBase_1.DefinitionBase {
      constructor(name, node) {
        super(DefinitionType_1.DefinitionType.TSModuleName, name, node, null);
        this.isTypeDefinition = true;
        this.isVariableDefinition = true;
      }
    };
    exports.TSModuleNameDefinition = TSModuleNameDefinition;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/TypeDefinition.js
var require_TypeDefinition = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/TypeDefinition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeDefinition = void 0;
    var DefinitionBase_1 = require_DefinitionBase();
    var DefinitionType_1 = require_DefinitionType();
    var TypeDefinition = class extends DefinitionBase_1.DefinitionBase {
      constructor(name, node) {
        super(DefinitionType_1.DefinitionType.Type, name, node, null);
        this.isTypeDefinition = true;
        this.isVariableDefinition = false;
      }
    };
    exports.TypeDefinition = TypeDefinition;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/VariableDefinition.js
var require_VariableDefinition = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/VariableDefinition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VariableDefinition = void 0;
    var DefinitionBase_1 = require_DefinitionBase();
    var DefinitionType_1 = require_DefinitionType();
    var VariableDefinition = class extends DefinitionBase_1.DefinitionBase {
      constructor(name, node, decl) {
        super(DefinitionType_1.DefinitionType.Variable, name, node, decl);
        this.isTypeDefinition = false;
        this.isVariableDefinition = true;
      }
    };
    exports.VariableDefinition = VariableDefinition;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/index.js
var require_definition = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/definition/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding2(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar2(require_CatchClauseDefinition(), exports);
    __exportStar2(require_ClassNameDefinition(), exports);
    __exportStar2(require_Definition(), exports);
    __exportStar2(require_DefinitionType(), exports);
    __exportStar2(require_FunctionNameDefinition(), exports);
    __exportStar2(require_ImplicitGlobalVariableDefinition(), exports);
    __exportStar2(require_ImportBindingDefinition(), exports);
    __exportStar2(require_ParameterDefinition(), exports);
    __exportStar2(require_TSEnumMemberDefinition(), exports);
    __exportStar2(require_TSEnumNameDefinition(), exports);
    __exportStar2(require_TSModuleNameDefinition(), exports);
    __exportStar2(require_TypeDefinition(), exports);
    __exportStar2(require_VariableDefinition(), exports);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/referencer/Reference.js
var require_Reference = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/referencer/Reference.js"(exports) {
    "use strict";
    var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var _Reference_flag;
    var _Reference_referenceType;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReferenceTypeFlag = exports.ReferenceFlag = exports.Reference = void 0;
    var ID_1 = require_ID();
    var ReferenceFlag;
    (function(ReferenceFlag2) {
      ReferenceFlag2[ReferenceFlag2["Read"] = 1] = "Read";
      ReferenceFlag2[ReferenceFlag2["Write"] = 2] = "Write";
      ReferenceFlag2[ReferenceFlag2["ReadWrite"] = 3] = "ReadWrite";
    })(ReferenceFlag || (ReferenceFlag = {}));
    exports.ReferenceFlag = ReferenceFlag;
    var generator = (0, ID_1.createIdGenerator)();
    var ReferenceTypeFlag;
    (function(ReferenceTypeFlag2) {
      ReferenceTypeFlag2[ReferenceTypeFlag2["Value"] = 1] = "Value";
      ReferenceTypeFlag2[ReferenceTypeFlag2["Type"] = 2] = "Type";
    })(ReferenceTypeFlag || (ReferenceTypeFlag = {}));
    exports.ReferenceTypeFlag = ReferenceTypeFlag;
    var Reference = class {
      /**
       * True if this reference can reference types
       */
      get isTypeReference() {
        return (__classPrivateFieldGet2(this, _Reference_referenceType, "f") & ReferenceTypeFlag.Type) !== 0;
      }
      /**
       * True if this reference can reference values
       */
      get isValueReference() {
        return (__classPrivateFieldGet2(this, _Reference_referenceType, "f") & ReferenceTypeFlag.Value) !== 0;
      }
      constructor(identifier, scope, flag, writeExpr, maybeImplicitGlobal, init, referenceType = ReferenceTypeFlag.Value) {
        this.$id = generator();
        _Reference_flag.set(this, void 0);
        _Reference_referenceType.set(this, void 0);
        this.identifier = identifier;
        this.from = scope;
        this.resolved = null;
        __classPrivateFieldSet2(this, _Reference_flag, flag, "f");
        if (this.isWrite()) {
          this.writeExpr = writeExpr;
          this.init = init;
        }
        this.maybeImplicitGlobal = maybeImplicitGlobal;
        __classPrivateFieldSet2(this, _Reference_referenceType, referenceType, "f");
      }
      /**
       * Whether the reference is writeable.
       * @public
       */
      isWrite() {
        return !!(__classPrivateFieldGet2(this, _Reference_flag, "f") & ReferenceFlag.Write);
      }
      /**
       * Whether the reference is readable.
       * @public
       */
      isRead() {
        return !!(__classPrivateFieldGet2(this, _Reference_flag, "f") & ReferenceFlag.Read);
      }
      /**
       * Whether the reference is read-only.
       * @public
       */
      isReadOnly() {
        return __classPrivateFieldGet2(this, _Reference_flag, "f") === ReferenceFlag.Read;
      }
      /**
       * Whether the reference is write-only.
       * @public
       */
      isWriteOnly() {
        return __classPrivateFieldGet2(this, _Reference_flag, "f") === ReferenceFlag.Write;
      }
      /**
       * Whether the reference is read-write.
       * @public
       */
      isReadWrite() {
        return __classPrivateFieldGet2(this, _Reference_flag, "f") === ReferenceFlag.ReadWrite;
      }
    };
    exports.Reference = Reference;
    _Reference_flag = /* @__PURE__ */ new WeakMap(), _Reference_referenceType = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/variable/VariableBase.js
var require_VariableBase = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/variable/VariableBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VariableBase = void 0;
    var ID_1 = require_ID();
    var generator = (0, ID_1.createIdGenerator)();
    var VariableBase = class {
      constructor(name, scope) {
        this.$id = generator();
        this.defs = [];
        this.eslintUsed = false;
        this.identifiers = [];
        this.references = [];
        this.name = name;
        this.scope = scope;
      }
    };
    exports.VariableBase = VariableBase;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/variable/ESLintScopeVariable.js
var require_ESLintScopeVariable = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/variable/ESLintScopeVariable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ESLintScopeVariable = void 0;
    var VariableBase_1 = require_VariableBase();
    var ESLintScopeVariable = class extends VariableBase_1.VariableBase {
    };
    exports.ESLintScopeVariable = ESLintScopeVariable;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/variable/ImplicitLibVariable.js
var require_ImplicitLibVariable = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/variable/ImplicitLibVariable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImplicitLibVariable = void 0;
    var ESLintScopeVariable_1 = require_ESLintScopeVariable();
    var ImplicitLibVariable = class extends ESLintScopeVariable_1.ESLintScopeVariable {
      constructor(scope, name, { isTypeVariable, isValueVariable, writeable, eslintImplicitGlobalSetting }) {
        super(name, scope);
        this.isTypeVariable = isTypeVariable !== null && isTypeVariable !== void 0 ? isTypeVariable : false;
        this.isValueVariable = isValueVariable !== null && isValueVariable !== void 0 ? isValueVariable : false;
        this.writeable = writeable !== null && writeable !== void 0 ? writeable : false;
        this.eslintImplicitGlobalSetting = eslintImplicitGlobalSetting !== null && eslintImplicitGlobalSetting !== void 0 ? eslintImplicitGlobalSetting : "readonly";
      }
    };
    exports.ImplicitLibVariable = ImplicitLibVariable;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/variable/Variable.js
var require_Variable = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/variable/Variable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Variable = void 0;
    var VariableBase_1 = require_VariableBase();
    var Variable = class extends VariableBase_1.VariableBase {
      /**
       * `true` if the variable is valid in a type context, false otherwise
       * @public
       */
      get isTypeVariable() {
        if (this.defs.length === 0) {
          return true;
        }
        return this.defs.some((def) => def.isTypeDefinition);
      }
      /**
       * `true` if the variable is valid in a value context, false otherwise
       * @public
       */
      get isValueVariable() {
        if (this.defs.length === 0) {
          return true;
        }
        return this.defs.some((def) => def.isVariableDefinition);
      }
    };
    exports.Variable = Variable;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/variable/index.js
var require_variable = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/variable/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Variable = exports.ImplicitLibVariable = exports.ESLintScopeVariable = void 0;
    var ESLintScopeVariable_1 = require_ESLintScopeVariable();
    Object.defineProperty(exports, "ESLintScopeVariable", { enumerable: true, get: function() {
      return ESLintScopeVariable_1.ESLintScopeVariable;
    } });
    var ImplicitLibVariable_1 = require_ImplicitLibVariable();
    Object.defineProperty(exports, "ImplicitLibVariable", { enumerable: true, get: function() {
      return ImplicitLibVariable_1.ImplicitLibVariable;
    } });
    var Variable_1 = require_Variable();
    Object.defineProperty(exports, "Variable", { enumerable: true, get: function() {
      return Variable_1.Variable;
    } });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/ScopeType.js
var require_ScopeType = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/ScopeType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScopeType = void 0;
    var ScopeType;
    (function(ScopeType2) {
      ScopeType2["block"] = "block";
      ScopeType2["catch"] = "catch";
      ScopeType2["class"] = "class";
      ScopeType2["classFieldInitializer"] = "class-field-initializer";
      ScopeType2["classStaticBlock"] = "class-static-block";
      ScopeType2["conditionalType"] = "conditionalType";
      ScopeType2["for"] = "for";
      ScopeType2["function"] = "function";
      ScopeType2["functionExpressionName"] = "function-expression-name";
      ScopeType2["functionType"] = "functionType";
      ScopeType2["global"] = "global";
      ScopeType2["mappedType"] = "mappedType";
      ScopeType2["module"] = "module";
      ScopeType2["switch"] = "switch";
      ScopeType2["tsEnum"] = "tsEnum";
      ScopeType2["tsModule"] = "tsModule";
      ScopeType2["type"] = "type";
      ScopeType2["with"] = "with";
    })(ScopeType || (ScopeType = {}));
    exports.ScopeType = ScopeType;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/ScopeBase.js
var require_ScopeBase = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/ScopeBase.js"(exports) {
    "use strict";
    var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _ScopeBase_declaredVariables;
    var _ScopeBase_dynamic;
    var _ScopeBase_staticCloseRef;
    var _ScopeBase_dynamicCloseRef;
    var _ScopeBase_globalCloseRef;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScopeBase = void 0;
    var types_1 = require_dist();
    var assert_1 = require_assert();
    var definition_1 = require_definition();
    var ID_1 = require_ID();
    var Reference_1 = require_Reference();
    var variable_1 = require_variable();
    var ScopeType_1 = require_ScopeType();
    function isStrictScope(scope, block, isMethodDefinition) {
      var _a2;
      let body;
      if ((_a2 = scope.upper) === null || _a2 === void 0 ? void 0 : _a2.isStrict) {
        return true;
      }
      if (isMethodDefinition) {
        return true;
      }
      if (scope.type === ScopeType_1.ScopeType.class || scope.type === ScopeType_1.ScopeType.conditionalType || scope.type === ScopeType_1.ScopeType.functionType || scope.type === ScopeType_1.ScopeType.mappedType || scope.type === ScopeType_1.ScopeType.module || scope.type === ScopeType_1.ScopeType.tsEnum || scope.type === ScopeType_1.ScopeType.tsModule || scope.type === ScopeType_1.ScopeType.type) {
        return true;
      }
      if (scope.type === ScopeType_1.ScopeType.block || scope.type === ScopeType_1.ScopeType.switch) {
        return false;
      }
      if (scope.type === ScopeType_1.ScopeType.function) {
        const functionBody = block;
        switch (functionBody.type) {
          case types_1.AST_NODE_TYPES.ArrowFunctionExpression:
            if (functionBody.body.type !== types_1.AST_NODE_TYPES.BlockStatement) {
              return false;
            }
            body = functionBody.body;
            break;
          case types_1.AST_NODE_TYPES.Program:
            body = functionBody;
            break;
          default:
            body = functionBody.body;
        }
        if (!body) {
          return false;
        }
      } else if (scope.type === ScopeType_1.ScopeType.global) {
        body = block;
      } else {
        return false;
      }
      for (const stmt of body.body) {
        if (stmt.type !== types_1.AST_NODE_TYPES.ExpressionStatement) {
          break;
        }
        if (stmt.directive === "use strict") {
          return true;
        }
        const expr = stmt.expression;
        if (expr.type !== types_1.AST_NODE_TYPES.Literal) {
          break;
        }
        if (expr.raw === '"use strict"' || expr.raw === "'use strict'") {
          return true;
        }
        if (expr.value === "use strict") {
          return true;
        }
      }
      return false;
    }
    function registerScope(scopeManager, scope) {
      scopeManager.scopes.push(scope);
      const scopes = scopeManager.nodeToScope.get(scope.block);
      if (scopes) {
        scopes.push(scope);
      } else {
        scopeManager.nodeToScope.set(scope.block, [scope]);
      }
    }
    var generator = (0, ID_1.createIdGenerator)();
    var VARIABLE_SCOPE_TYPES = /* @__PURE__ */ new Set([
      ScopeType_1.ScopeType.classFieldInitializer,
      ScopeType_1.ScopeType.classStaticBlock,
      ScopeType_1.ScopeType.function,
      ScopeType_1.ScopeType.global,
      ScopeType_1.ScopeType.module,
      ScopeType_1.ScopeType.tsModule
    ]);
    var ScopeBase = class {
      constructor(scopeManager, type, upperScope, block, isMethodDefinition) {
        this.$id = generator();
        this.childScopes = [];
        _ScopeBase_declaredVariables.set(this, void 0);
        _ScopeBase_dynamic.set(this, void 0);
        this.functionExpressionScope = false;
        this.leftToResolve = [];
        this.references = [];
        this.set = /* @__PURE__ */ new Map();
        this.through = [];
        this.variables = [];
        _ScopeBase_staticCloseRef.set(this, (ref) => {
          const resolve = () => {
            const name = ref.identifier.name;
            const variable = this.set.get(name);
            if (!variable) {
              return false;
            }
            if (!this.isValidResolution(ref, variable)) {
              return false;
            }
            const isValidTypeReference = ref.isTypeReference && variable.isTypeVariable;
            const isValidValueReference = ref.isValueReference && variable.isValueVariable;
            if (!isValidTypeReference && !isValidValueReference) {
              return false;
            }
            variable.references.push(ref);
            ref.resolved = variable;
            return true;
          };
          if (!resolve()) {
            this.delegateToUpperScope(ref);
          }
        });
        _ScopeBase_dynamicCloseRef.set(this, (ref) => {
          let current = this;
          do {
            current.through.push(ref);
            current = current.upper;
          } while (current);
        });
        _ScopeBase_globalCloseRef.set(this, (ref, scopeManager2) => {
          if (this.shouldStaticallyCloseForGlobal(ref, scopeManager2)) {
            __classPrivateFieldGet2(this, _ScopeBase_staticCloseRef, "f").call(this, ref);
          } else {
            __classPrivateFieldGet2(this, _ScopeBase_dynamicCloseRef, "f").call(this, ref);
          }
        });
        const upperScopeAsScopeBase = upperScope;
        this.type = type;
        __classPrivateFieldSet2(this, _ScopeBase_dynamic, this.type === ScopeType_1.ScopeType.global || this.type === ScopeType_1.ScopeType.with, "f");
        this.block = block;
        this.variableScope = this.isVariableScope() ? this : upperScopeAsScopeBase.variableScope;
        this.upper = upperScope;
        this.isStrict = isStrictScope(this, block, isMethodDefinition);
        if (upperScopeAsScopeBase) {
          upperScopeAsScopeBase.childScopes.push(this);
        }
        __classPrivateFieldSet2(this, _ScopeBase_declaredVariables, scopeManager.declaredVariables, "f");
        registerScope(scopeManager, this);
      }
      isVariableScope() {
        return VARIABLE_SCOPE_TYPES.has(this.type);
      }
      shouldStaticallyClose() {
        return !__classPrivateFieldGet2(this, _ScopeBase_dynamic, "f");
      }
      shouldStaticallyCloseForGlobal(ref, scopeManager) {
        const name = ref.identifier.name;
        const variable = this.set.get(name);
        if (!variable) {
          return false;
        }
        if (scopeManager.isModule()) {
          return true;
        }
        const defs = variable.defs;
        return defs.length > 0 && defs.every((def) => {
          var _a2;
          if (def.type === definition_1.DefinitionType.Variable && ((_a2 = def.parent) === null || _a2 === void 0 ? void 0 : _a2.type) === types_1.AST_NODE_TYPES.VariableDeclaration && def.parent.kind === "var") {
            return false;
          }
          return true;
        });
      }
      close(scopeManager) {
        let closeRef;
        if (this.shouldStaticallyClose()) {
          closeRef = __classPrivateFieldGet2(this, _ScopeBase_staticCloseRef, "f");
        } else if (this.type !== "global") {
          closeRef = __classPrivateFieldGet2(this, _ScopeBase_dynamicCloseRef, "f");
        } else {
          closeRef = __classPrivateFieldGet2(this, _ScopeBase_globalCloseRef, "f");
        }
        (0, assert_1.assert)(this.leftToResolve);
        this.leftToResolve.forEach((ref) => closeRef(ref, scopeManager));
        this.leftToResolve = null;
        return this.upper;
      }
      /**
       * To override by function scopes.
       * References in default parameters isn't resolved to variables which are in their function body.
       */
      isValidResolution(_ref, _variable) {
        return true;
      }
      delegateToUpperScope(ref) {
        const upper = this.upper;
        if (upper === null || upper === void 0 ? void 0 : upper.leftToResolve) {
          upper.leftToResolve.push(ref);
        }
        this.through.push(ref);
      }
      addDeclaredVariablesOfNode(variable, node) {
        if (node == null) {
          return;
        }
        let variables = __classPrivateFieldGet2(this, _ScopeBase_declaredVariables, "f").get(node);
        if (variables == null) {
          variables = [];
          __classPrivateFieldGet2(this, _ScopeBase_declaredVariables, "f").set(node, variables);
        }
        if (!variables.includes(variable)) {
          variables.push(variable);
        }
      }
      defineVariable(nameOrVariable, set, variables, node, def) {
        const name = typeof nameOrVariable === "string" ? nameOrVariable : nameOrVariable.name;
        let variable = set.get(name);
        if (!variable) {
          variable = typeof nameOrVariable === "string" ? new variable_1.Variable(name, this) : nameOrVariable;
          set.set(name, variable);
          variables.push(variable);
        }
        if (def) {
          variable.defs.push(def);
          this.addDeclaredVariablesOfNode(variable, def.node);
          this.addDeclaredVariablesOfNode(variable, def.parent);
        }
        if (node) {
          variable.identifiers.push(node);
        }
      }
      defineIdentifier(node, def) {
        this.defineVariable(node.name, this.set, this.variables, node, def);
      }
      defineLiteralIdentifier(node, def) {
        this.defineVariable(node.value, this.set, this.variables, null, def);
      }
      referenceValue(node, assign = Reference_1.ReferenceFlag.Read, writeExpr, maybeImplicitGlobal, init = false) {
        var _a2;
        const ref = new Reference_1.Reference(node, this, assign, writeExpr, maybeImplicitGlobal, init, Reference_1.ReferenceTypeFlag.Value);
        this.references.push(ref);
        (_a2 = this.leftToResolve) === null || _a2 === void 0 ? void 0 : _a2.push(ref);
      }
      referenceType(node) {
        var _a2;
        const ref = new Reference_1.Reference(node, this, Reference_1.ReferenceFlag.Read, null, null, false, Reference_1.ReferenceTypeFlag.Type);
        this.references.push(ref);
        (_a2 = this.leftToResolve) === null || _a2 === void 0 ? void 0 : _a2.push(ref);
      }
      referenceDualValueType(node) {
        var _a2;
        const ref = new Reference_1.Reference(node, this, Reference_1.ReferenceFlag.Read, null, null, false, Reference_1.ReferenceTypeFlag.Type | Reference_1.ReferenceTypeFlag.Value);
        this.references.push(ref);
        (_a2 = this.leftToResolve) === null || _a2 === void 0 ? void 0 : _a2.push(ref);
      }
    };
    exports.ScopeBase = ScopeBase;
    _ScopeBase_declaredVariables = /* @__PURE__ */ new WeakMap(), _ScopeBase_dynamic = /* @__PURE__ */ new WeakMap(), _ScopeBase_staticCloseRef = /* @__PURE__ */ new WeakMap(), _ScopeBase_dynamicCloseRef = /* @__PURE__ */ new WeakMap(), _ScopeBase_globalCloseRef = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/BlockScope.js
var require_BlockScope = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/BlockScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockScope = void 0;
    var ScopeBase_1 = require_ScopeBase();
    var ScopeType_1 = require_ScopeType();
    var BlockScope = class extends ScopeBase_1.ScopeBase {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, ScopeType_1.ScopeType.block, upperScope, block, false);
      }
    };
    exports.BlockScope = BlockScope;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/CatchScope.js
var require_CatchScope = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/CatchScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CatchScope = void 0;
    var ScopeBase_1 = require_ScopeBase();
    var ScopeType_1 = require_ScopeType();
    var CatchScope = class extends ScopeBase_1.ScopeBase {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, ScopeType_1.ScopeType.catch, upperScope, block, false);
      }
    };
    exports.CatchScope = CatchScope;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/ClassFieldInitializerScope.js
var require_ClassFieldInitializerScope = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/ClassFieldInitializerScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassFieldInitializerScope = void 0;
    var ScopeBase_1 = require_ScopeBase();
    var ScopeType_1 = require_ScopeType();
    var ClassFieldInitializerScope = class extends ScopeBase_1.ScopeBase {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, ScopeType_1.ScopeType.classFieldInitializer, upperScope, block, false);
      }
    };
    exports.ClassFieldInitializerScope = ClassFieldInitializerScope;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/ClassScope.js
var require_ClassScope = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/ClassScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassScope = void 0;
    var ScopeBase_1 = require_ScopeBase();
    var ScopeType_1 = require_ScopeType();
    var ClassScope = class extends ScopeBase_1.ScopeBase {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, ScopeType_1.ScopeType.class, upperScope, block, false);
      }
    };
    exports.ClassScope = ClassScope;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/ConditionalTypeScope.js
var require_ConditionalTypeScope = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/ConditionalTypeScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConditionalTypeScope = void 0;
    var ScopeBase_1 = require_ScopeBase();
    var ScopeType_1 = require_ScopeType();
    var ConditionalTypeScope = class extends ScopeBase_1.ScopeBase {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, ScopeType_1.ScopeType.conditionalType, upperScope, block, false);
      }
    };
    exports.ConditionalTypeScope = ConditionalTypeScope;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/ForScope.js
var require_ForScope = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/ForScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ForScope = void 0;
    var ScopeBase_1 = require_ScopeBase();
    var ScopeType_1 = require_ScopeType();
    var ForScope = class extends ScopeBase_1.ScopeBase {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, ScopeType_1.ScopeType.for, upperScope, block, false);
      }
    };
    exports.ForScope = ForScope;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/FunctionExpressionNameScope.js
var require_FunctionExpressionNameScope = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/FunctionExpressionNameScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FunctionExpressionNameScope = void 0;
    var definition_1 = require_definition();
    var ScopeBase_1 = require_ScopeBase();
    var ScopeType_1 = require_ScopeType();
    var FunctionExpressionNameScope = class extends ScopeBase_1.ScopeBase {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, ScopeType_1.ScopeType.functionExpressionName, upperScope, block, false);
        if (block.id) {
          this.defineIdentifier(block.id, new definition_1.FunctionNameDefinition(block.id, block));
        }
        this.functionExpressionScope = true;
      }
    };
    exports.FunctionExpressionNameScope = FunctionExpressionNameScope;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/FunctionScope.js
var require_FunctionScope = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/FunctionScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FunctionScope = void 0;
    var types_1 = require_dist();
    var ScopeBase_1 = require_ScopeBase();
    var ScopeType_1 = require_ScopeType();
    var FunctionScope = class extends ScopeBase_1.ScopeBase {
      constructor(scopeManager, upperScope, block, isMethodDefinition) {
        super(scopeManager, ScopeType_1.ScopeType.function, upperScope, block, isMethodDefinition);
        if (this.block.type !== types_1.AST_NODE_TYPES.ArrowFunctionExpression) {
          this.defineVariable("arguments", this.set, this.variables, null, null);
        }
      }
      // References in default parameters isn't resolved to variables which are in their function body.
      //     const x = 1
      //     function f(a = x) { // This `x` is resolved to the `x` in the outer scope.
      //         const x = 2
      //         console.log(a)
      //     }
      isValidResolution(ref, variable) {
        var _a2, _b;
        if (this.block.type === types_1.AST_NODE_TYPES.Program) {
          return true;
        }
        const bodyStart = (_b = (_a2 = this.block.body) === null || _a2 === void 0 ? void 0 : _a2.range[0]) !== null && _b !== void 0 ? _b : -1;
        return !(variable.scope === this && ref.identifier.range[0] < bodyStart && // the reference is in the parameter part.
        variable.defs.every((d) => d.name.range[0] >= bodyStart));
      }
    };
    exports.FunctionScope = FunctionScope;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/FunctionTypeScope.js
var require_FunctionTypeScope = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/FunctionTypeScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FunctionTypeScope = void 0;
    var ScopeBase_1 = require_ScopeBase();
    var ScopeType_1 = require_ScopeType();
    var FunctionTypeScope = class extends ScopeBase_1.ScopeBase {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, ScopeType_1.ScopeType.functionType, upperScope, block, false);
      }
    };
    exports.FunctionTypeScope = FunctionTypeScope;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/GlobalScope.js
var require_GlobalScope = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/GlobalScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GlobalScope = void 0;
    var types_1 = require_dist();
    var assert_1 = require_assert();
    var ImplicitGlobalVariableDefinition_1 = require_ImplicitGlobalVariableDefinition();
    var variable_1 = require_variable();
    var ScopeBase_1 = require_ScopeBase();
    var ScopeType_1 = require_ScopeType();
    var GlobalScope = class extends ScopeBase_1.ScopeBase {
      constructor(scopeManager, block) {
        super(scopeManager, ScopeType_1.ScopeType.global, null, block, false);
        this.implicit = {
          set: /* @__PURE__ */ new Map(),
          variables: [],
          leftToBeResolved: []
        };
      }
      defineImplicitVariable(name, options) {
        this.defineVariable(new variable_1.ImplicitLibVariable(this, name, options), this.set, this.variables, null, null);
      }
      close(scopeManager) {
        (0, assert_1.assert)(this.leftToResolve);
        for (const ref of this.leftToResolve) {
          if (ref.maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {
            const info = ref.maybeImplicitGlobal;
            const node = info.pattern;
            if (node && node.type === types_1.AST_NODE_TYPES.Identifier) {
              this.defineVariable(node.name, this.implicit.set, this.implicit.variables, node, new ImplicitGlobalVariableDefinition_1.ImplicitGlobalVariableDefinition(info.pattern, info.node));
            }
          }
        }
        this.implicit.leftToBeResolved = this.leftToResolve;
        return super.close(scopeManager);
      }
    };
    exports.GlobalScope = GlobalScope;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/MappedTypeScope.js
var require_MappedTypeScope = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/MappedTypeScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MappedTypeScope = void 0;
    var ScopeBase_1 = require_ScopeBase();
    var ScopeType_1 = require_ScopeType();
    var MappedTypeScope = class extends ScopeBase_1.ScopeBase {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, ScopeType_1.ScopeType.mappedType, upperScope, block, false);
      }
    };
    exports.MappedTypeScope = MappedTypeScope;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/ModuleScope.js
var require_ModuleScope = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/ModuleScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ModuleScope = void 0;
    var ScopeBase_1 = require_ScopeBase();
    var ScopeType_1 = require_ScopeType();
    var ModuleScope = class extends ScopeBase_1.ScopeBase {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, ScopeType_1.ScopeType.module, upperScope, block, false);
      }
    };
    exports.ModuleScope = ModuleScope;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/Scope.js
var require_Scope = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/Scope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/SwitchScope.js
var require_SwitchScope = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/SwitchScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SwitchScope = void 0;
    var ScopeBase_1 = require_ScopeBase();
    var ScopeType_1 = require_ScopeType();
    var SwitchScope = class extends ScopeBase_1.ScopeBase {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, ScopeType_1.ScopeType.switch, upperScope, block, false);
      }
    };
    exports.SwitchScope = SwitchScope;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/TSEnumScope.js
var require_TSEnumScope = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/TSEnumScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TSEnumScope = void 0;
    var ScopeBase_1 = require_ScopeBase();
    var ScopeType_1 = require_ScopeType();
    var TSEnumScope = class extends ScopeBase_1.ScopeBase {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, ScopeType_1.ScopeType.tsEnum, upperScope, block, false);
      }
    };
    exports.TSEnumScope = TSEnumScope;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/TSModuleScope.js
var require_TSModuleScope = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/TSModuleScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TSModuleScope = void 0;
    var ScopeBase_1 = require_ScopeBase();
    var ScopeType_1 = require_ScopeType();
    var TSModuleScope = class extends ScopeBase_1.ScopeBase {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, ScopeType_1.ScopeType.tsModule, upperScope, block, false);
      }
    };
    exports.TSModuleScope = TSModuleScope;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/TypeScope.js
var require_TypeScope = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/TypeScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeScope = void 0;
    var ScopeBase_1 = require_ScopeBase();
    var ScopeType_1 = require_ScopeType();
    var TypeScope = class extends ScopeBase_1.ScopeBase {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, ScopeType_1.ScopeType.type, upperScope, block, false);
      }
    };
    exports.TypeScope = TypeScope;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/WithScope.js
var require_WithScope = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/WithScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WithScope = void 0;
    var assert_1 = require_assert();
    var ScopeBase_1 = require_ScopeBase();
    var ScopeType_1 = require_ScopeType();
    var WithScope = class extends ScopeBase_1.ScopeBase {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, ScopeType_1.ScopeType.with, upperScope, block, false);
      }
      close(scopeManager) {
        if (this.shouldStaticallyClose()) {
          return super.close(scopeManager);
        }
        (0, assert_1.assert)(this.leftToResolve);
        this.leftToResolve.forEach((ref) => this.delegateToUpperScope(ref));
        this.leftToResolve = null;
        return this.upper;
      }
    };
    exports.WithScope = WithScope;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/index.js
var require_scope = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding2(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar2(require_BlockScope(), exports);
    __exportStar2(require_CatchScope(), exports);
    __exportStar2(require_ClassFieldInitializerScope(), exports);
    __exportStar2(require_ClassScope(), exports);
    __exportStar2(require_ConditionalTypeScope(), exports);
    __exportStar2(require_ForScope(), exports);
    __exportStar2(require_FunctionExpressionNameScope(), exports);
    __exportStar2(require_FunctionScope(), exports);
    __exportStar2(require_FunctionTypeScope(), exports);
    __exportStar2(require_GlobalScope(), exports);
    __exportStar2(require_MappedTypeScope(), exports);
    __exportStar2(require_ModuleScope(), exports);
    __exportStar2(require_Scope(), exports);
    __exportStar2(require_ScopeType(), exports);
    __exportStar2(require_SwitchScope(), exports);
    __exportStar2(require_TSEnumScope(), exports);
    __exportStar2(require_TSModuleScope(), exports);
    __exportStar2(require_TypeScope(), exports);
    __exportStar2(require_WithScope(), exports);
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/referencer/VisitorBase.js
var require_VisitorBase = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/referencer/VisitorBase.js"(exports) {
    "use strict";
    var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _VisitorBase_childVisitorKeys;
    var _VisitorBase_visitChildrenEvenIfSelectorExists;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VisitorBase = void 0;
    var visitor_keys_1 = require_dist2();
    function isObject(obj) {
      return typeof obj === "object" && obj != null;
    }
    function isNode(node) {
      return isObject(node) && typeof node.type === "string";
    }
    var VisitorBase = class {
      constructor(options) {
        var _a2, _b;
        _VisitorBase_childVisitorKeys.set(this, void 0);
        _VisitorBase_visitChildrenEvenIfSelectorExists.set(this, void 0);
        __classPrivateFieldSet2(this, _VisitorBase_childVisitorKeys, (_a2 = options.childVisitorKeys) !== null && _a2 !== void 0 ? _a2 : visitor_keys_1.visitorKeys, "f");
        __classPrivateFieldSet2(this, _VisitorBase_visitChildrenEvenIfSelectorExists, (_b = options.visitChildrenEvenIfSelectorExists) !== null && _b !== void 0 ? _b : false, "f");
      }
      /**
       * Default method for visiting children.
       * @param node the node whose children should be visited
       * @param exclude a list of keys to not visit
       */
      visitChildren(node, excludeArr = []) {
        var _a2;
        if (node == null || node.type == null) {
          return;
        }
        const exclude = new Set(excludeArr.concat(["parent"]));
        const children = (_a2 = __classPrivateFieldGet2(this, _VisitorBase_childVisitorKeys, "f")[node.type]) !== null && _a2 !== void 0 ? _a2 : Object.keys(node);
        for (const key of children) {
          if (exclude.has(key)) {
            continue;
          }
          const child = node[key];
          if (!child) {
            continue;
          }
          if (Array.isArray(child)) {
            for (const subChild of child) {
              if (isNode(subChild)) {
                this.visit(subChild);
              }
            }
          } else if (isNode(child)) {
            this.visit(child);
          }
        }
      }
      /**
       * Dispatching node.
       */
      visit(node) {
        if (node == null || node.type == null) {
          return;
        }
        const visitor = this[node.type];
        if (visitor) {
          visitor.call(this, node);
          if (!__classPrivateFieldGet2(this, _VisitorBase_visitChildrenEvenIfSelectorExists, "f")) {
            return;
          }
        }
        this.visitChildren(node);
      }
    };
    exports.VisitorBase = VisitorBase;
    _VisitorBase_childVisitorKeys = /* @__PURE__ */ new WeakMap(), _VisitorBase_visitChildrenEvenIfSelectorExists = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/referencer/PatternVisitor.js
var require_PatternVisitor = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/referencer/PatternVisitor.js"(exports) {
    "use strict";
    var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _PatternVisitor_rootPattern;
    var _PatternVisitor_callback;
    var _PatternVisitor_assignments;
    var _PatternVisitor_restElements;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PatternVisitor = void 0;
    var types_1 = require_dist();
    var VisitorBase_1 = require_VisitorBase();
    var PatternVisitor = class extends VisitorBase_1.VisitorBase {
      static isPattern(node) {
        const nodeType = node.type;
        return nodeType === types_1.AST_NODE_TYPES.Identifier || nodeType === types_1.AST_NODE_TYPES.ObjectPattern || nodeType === types_1.AST_NODE_TYPES.ArrayPattern || nodeType === types_1.AST_NODE_TYPES.SpreadElement || nodeType === types_1.AST_NODE_TYPES.RestElement || nodeType === types_1.AST_NODE_TYPES.AssignmentPattern;
      }
      constructor(options, rootPattern, callback) {
        super(options);
        _PatternVisitor_rootPattern.set(this, void 0);
        _PatternVisitor_callback.set(this, void 0);
        _PatternVisitor_assignments.set(this, []);
        this.rightHandNodes = [];
        _PatternVisitor_restElements.set(this, []);
        __classPrivateFieldSet2(this, _PatternVisitor_rootPattern, rootPattern, "f");
        __classPrivateFieldSet2(this, _PatternVisitor_callback, callback, "f");
      }
      ArrayExpression(node) {
        node.elements.forEach(this.visit, this);
      }
      ArrayPattern(pattern) {
        for (const element of pattern.elements) {
          this.visit(element);
        }
      }
      AssignmentExpression(node) {
        __classPrivateFieldGet2(this, _PatternVisitor_assignments, "f").push(node);
        this.visit(node.left);
        this.rightHandNodes.push(node.right);
        __classPrivateFieldGet2(this, _PatternVisitor_assignments, "f").pop();
      }
      AssignmentPattern(pattern) {
        __classPrivateFieldGet2(this, _PatternVisitor_assignments, "f").push(pattern);
        this.visit(pattern.left);
        this.rightHandNodes.push(pattern.right);
        __classPrivateFieldGet2(this, _PatternVisitor_assignments, "f").pop();
      }
      CallExpression(node) {
        node.arguments.forEach((a) => {
          this.rightHandNodes.push(a);
        });
        this.visit(node.callee);
      }
      Decorator() {
      }
      Identifier(pattern) {
        var _a2;
        const lastRestElement = (_a2 = __classPrivateFieldGet2(this, _PatternVisitor_restElements, "f")[__classPrivateFieldGet2(this, _PatternVisitor_restElements, "f").length - 1]) !== null && _a2 !== void 0 ? _a2 : null;
        __classPrivateFieldGet2(this, _PatternVisitor_callback, "f").call(this, pattern, {
          topLevel: pattern === __classPrivateFieldGet2(this, _PatternVisitor_rootPattern, "f"),
          rest: lastRestElement != null && lastRestElement.argument === pattern,
          assignments: __classPrivateFieldGet2(this, _PatternVisitor_assignments, "f")
        });
      }
      MemberExpression(node) {
        if (node.computed) {
          this.rightHandNodes.push(node.property);
        }
        this.rightHandNodes.push(node.object);
      }
      Property(property) {
        if (property.computed) {
          this.rightHandNodes.push(property.key);
        }
        this.visit(property.value);
      }
      RestElement(pattern) {
        __classPrivateFieldGet2(this, _PatternVisitor_restElements, "f").push(pattern);
        this.visit(pattern.argument);
        __classPrivateFieldGet2(this, _PatternVisitor_restElements, "f").pop();
      }
      SpreadElement(node) {
        this.visit(node.argument);
      }
      TSTypeAnnotation() {
      }
    };
    exports.PatternVisitor = PatternVisitor;
    _PatternVisitor_rootPattern = /* @__PURE__ */ new WeakMap(), _PatternVisitor_callback = /* @__PURE__ */ new WeakMap(), _PatternVisitor_assignments = /* @__PURE__ */ new WeakMap(), _PatternVisitor_restElements = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/referencer/Visitor.js
var require_Visitor = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/referencer/Visitor.js"(exports) {
    "use strict";
    var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var _Visitor_options;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VisitorBase = exports.Visitor = void 0;
    var PatternVisitor_1 = require_PatternVisitor();
    var VisitorBase_1 = require_VisitorBase();
    Object.defineProperty(exports, "VisitorBase", { enumerable: true, get: function() {
      return VisitorBase_1.VisitorBase;
    } });
    var Visitor = class extends VisitorBase_1.VisitorBase {
      constructor(optionsOrVisitor) {
        super(optionsOrVisitor instanceof Visitor ? __classPrivateFieldGet2(optionsOrVisitor, _Visitor_options, "f") : optionsOrVisitor);
        _Visitor_options.set(this, void 0);
        __classPrivateFieldSet2(this, _Visitor_options, optionsOrVisitor instanceof Visitor ? __classPrivateFieldGet2(optionsOrVisitor, _Visitor_options, "f") : optionsOrVisitor, "f");
      }
      visitPattern(node, callback, options = { processRightHandNodes: false }) {
        const visitor = new PatternVisitor_1.PatternVisitor(__classPrivateFieldGet2(this, _Visitor_options, "f"), node, callback);
        visitor.visit(node);
        if (options.processRightHandNodes) {
          visitor.rightHandNodes.forEach(this.visit, this);
        }
      }
    };
    exports.Visitor = Visitor;
    _Visitor_options = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/referencer/TypeVisitor.js
var require_TypeVisitor = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/referencer/TypeVisitor.js"(exports) {
    "use strict";
    var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _TypeVisitor_referencer;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeVisitor = void 0;
    var types_1 = require_dist();
    var definition_1 = require_definition();
    var scope_1 = require_scope();
    var Visitor_1 = require_Visitor();
    var TypeVisitor = class extends Visitor_1.Visitor {
      constructor(referencer) {
        super(referencer);
        _TypeVisitor_referencer.set(this, void 0);
        __classPrivateFieldSet2(this, _TypeVisitor_referencer, referencer, "f");
      }
      static visit(referencer, node) {
        const typeReferencer = new TypeVisitor(referencer);
        typeReferencer.visit(node);
      }
      ///////////////////
      // Visit helpers //
      ///////////////////
      visitFunctionType(node) {
        __classPrivateFieldGet2(this, _TypeVisitor_referencer, "f").scopeManager.nestFunctionTypeScope(node);
        this.visit(node.typeParameters);
        for (const param of node.params) {
          let didVisitAnnotation = false;
          this.visitPattern(param, (pattern, info) => {
            __classPrivateFieldGet2(this, _TypeVisitor_referencer, "f").currentScope().defineIdentifier(pattern, new definition_1.ParameterDefinition(pattern, node, info.rest));
            if (pattern.typeAnnotation) {
              this.visit(pattern.typeAnnotation);
              didVisitAnnotation = true;
            }
          });
          if (!didVisitAnnotation && "typeAnnotation" in param) {
            this.visit(param.typeAnnotation);
          }
        }
        this.visit(node.returnType);
        __classPrivateFieldGet2(this, _TypeVisitor_referencer, "f").close(node);
      }
      visitPropertyKey(node) {
        if (!node.computed) {
          return;
        }
        __classPrivateFieldGet2(this, _TypeVisitor_referencer, "f").visit(node.key);
      }
      /////////////////////
      // Visit selectors //
      /////////////////////
      Identifier(node) {
        __classPrivateFieldGet2(this, _TypeVisitor_referencer, "f").currentScope().referenceType(node);
      }
      MemberExpression(node) {
        this.visit(node.object);
      }
      TSCallSignatureDeclaration(node) {
        this.visitFunctionType(node);
      }
      TSConditionalType(node) {
        __classPrivateFieldGet2(this, _TypeVisitor_referencer, "f").scopeManager.nestConditionalTypeScope(node);
        this.visitChildren(node, ["falseType"]);
        __classPrivateFieldGet2(this, _TypeVisitor_referencer, "f").close(node);
        this.visit(node.falseType);
      }
      TSConstructorType(node) {
        this.visitFunctionType(node);
      }
      TSConstructSignatureDeclaration(node) {
        this.visitFunctionType(node);
      }
      TSFunctionType(node) {
        this.visitFunctionType(node);
      }
      TSImportType(node) {
        this.visit(node.typeParameters);
      }
      TSIndexSignature(node) {
        for (const param of node.parameters) {
          if (param.type === types_1.AST_NODE_TYPES.Identifier) {
            this.visit(param.typeAnnotation);
          }
        }
        this.visit(node.typeAnnotation);
      }
      TSInferType(node) {
        const typeParameter = node.typeParameter;
        let scope = __classPrivateFieldGet2(this, _TypeVisitor_referencer, "f").currentScope();
        if (scope.type === scope_1.ScopeType.functionType || scope.type === scope_1.ScopeType.mappedType) {
          let currentScope = scope.upper;
          while (currentScope) {
            if (currentScope.type === scope_1.ScopeType.functionType || currentScope.type === scope_1.ScopeType.mappedType) {
              currentScope = currentScope.upper;
              continue;
            }
            if (currentScope.type === scope_1.ScopeType.conditionalType) {
              scope = currentScope;
              break;
            }
            break;
          }
        }
        scope.defineIdentifier(typeParameter.name, new definition_1.TypeDefinition(typeParameter.name, typeParameter));
        this.visit(typeParameter.constraint);
      }
      TSInterfaceDeclaration(node) {
        var _a2, _b;
        __classPrivateFieldGet2(this, _TypeVisitor_referencer, "f").currentScope().defineIdentifier(node.id, new definition_1.TypeDefinition(node.id, node));
        if (node.typeParameters) {
          __classPrivateFieldGet2(this, _TypeVisitor_referencer, "f").scopeManager.nestTypeScope(node);
          this.visit(node.typeParameters);
        }
        (_a2 = node.extends) === null || _a2 === void 0 ? void 0 : _a2.forEach(this.visit, this);
        (_b = node.implements) === null || _b === void 0 ? void 0 : _b.forEach(this.visit, this);
        this.visit(node.body);
        if (node.typeParameters) {
          __classPrivateFieldGet2(this, _TypeVisitor_referencer, "f").close(node);
        }
      }
      TSMappedType(node) {
        __classPrivateFieldGet2(this, _TypeVisitor_referencer, "f").scopeManager.nestMappedTypeScope(node);
        this.visitChildren(node);
        __classPrivateFieldGet2(this, _TypeVisitor_referencer, "f").close(node);
      }
      TSMethodSignature(node) {
        this.visitPropertyKey(node);
        this.visitFunctionType(node);
      }
      TSNamedTupleMember(node) {
        this.visit(node.elementType);
      }
      TSPropertySignature(node) {
        this.visitPropertyKey(node);
        this.visit(node.typeAnnotation);
      }
      TSQualifiedName(node) {
        this.visit(node.left);
      }
      TSTypeAliasDeclaration(node) {
        __classPrivateFieldGet2(this, _TypeVisitor_referencer, "f").currentScope().defineIdentifier(node.id, new definition_1.TypeDefinition(node.id, node));
        if (node.typeParameters) {
          __classPrivateFieldGet2(this, _TypeVisitor_referencer, "f").scopeManager.nestTypeScope(node);
          this.visit(node.typeParameters);
        }
        this.visit(node.typeAnnotation);
        if (node.typeParameters) {
          __classPrivateFieldGet2(this, _TypeVisitor_referencer, "f").close(node);
        }
      }
      TSTypeParameter(node) {
        __classPrivateFieldGet2(this, _TypeVisitor_referencer, "f").currentScope().defineIdentifier(node.name, new definition_1.TypeDefinition(node.name, node));
        this.visit(node.constraint);
        this.visit(node.default);
      }
      TSTypePredicate(node) {
        if (node.parameterName.type !== types_1.AST_NODE_TYPES.TSThisType) {
          __classPrivateFieldGet2(this, _TypeVisitor_referencer, "f").currentScope().referenceValue(node.parameterName);
        }
        this.visit(node.typeAnnotation);
      }
      // a type query `typeof foo` is a special case that references a _non-type_ variable,
      TSTypeQuery(node) {
        let entityName;
        if (node.exprName.type === types_1.AST_NODE_TYPES.TSQualifiedName) {
          let iter = node.exprName;
          while (iter.left.type === types_1.AST_NODE_TYPES.TSQualifiedName) {
            iter = iter.left;
          }
          entityName = iter.left;
        } else {
          entityName = node.exprName;
        }
        if (entityName.type === types_1.AST_NODE_TYPES.Identifier) {
          __classPrivateFieldGet2(this, _TypeVisitor_referencer, "f").currentScope().referenceValue(entityName);
        }
        this.visit(node.typeParameters);
      }
      TSTypeAnnotation(node) {
        this.visitChildren(node);
      }
    };
    exports.TypeVisitor = TypeVisitor;
    _TypeVisitor_referencer = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/referencer/ClassVisitor.js
var require_ClassVisitor = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/referencer/ClassVisitor.js"(exports) {
    "use strict";
    var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _ClassVisitor_classNode;
    var _ClassVisitor_referencer;
    var _ClassVisitor_emitDecoratorMetadata;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassVisitor = void 0;
    var types_1 = require_dist();
    var definition_1 = require_definition();
    var TypeVisitor_1 = require_TypeVisitor();
    var Visitor_1 = require_Visitor();
    var ClassVisitor = class extends Visitor_1.Visitor {
      constructor(referencer, node, emitDecoratorMetadata) {
        super(referencer);
        _ClassVisitor_classNode.set(this, void 0);
        _ClassVisitor_referencer.set(this, void 0);
        _ClassVisitor_emitDecoratorMetadata.set(this, void 0);
        __classPrivateFieldSet2(this, _ClassVisitor_referencer, referencer, "f");
        __classPrivateFieldSet2(this, _ClassVisitor_classNode, node, "f");
        __classPrivateFieldSet2(this, _ClassVisitor_emitDecoratorMetadata, emitDecoratorMetadata, "f");
      }
      static visit(referencer, node, emitDecoratorMetadata) {
        const classVisitor = new ClassVisitor(referencer, node, emitDecoratorMetadata);
        classVisitor.visitClass(node);
      }
      visit(node) {
        if (node && node.type in this) {
          super.visit(node);
        } else {
          __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").visit(node);
        }
      }
      ///////////////////
      // Visit helpers //
      ///////////////////
      visitClass(node) {
        var _a2, _b;
        if (node.type === types_1.AST_NODE_TYPES.ClassDeclaration && node.id) {
          __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").currentScope().defineIdentifier(node.id, new definition_1.ClassNameDefinition(node.id, node));
        }
        (_a2 = node.decorators) === null || _a2 === void 0 ? void 0 : _a2.forEach((d) => __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").visit(d));
        __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").scopeManager.nestClassScope(node);
        if (node.id) {
          __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").currentScope().defineIdentifier(node.id, new definition_1.ClassNameDefinition(node.id, node));
        }
        __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").visit(node.superClass);
        this.visitType(node.typeParameters);
        this.visitType(node.superTypeParameters);
        (_b = node.implements) === null || _b === void 0 ? void 0 : _b.forEach((imp) => this.visitType(imp));
        this.visit(node.body);
        __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").close(node);
      }
      visitPropertyDefinition(node) {
        this.visitPropertyBase(node);
        this.visitMetadataType(node.typeAnnotation, !!node.decorators);
      }
      visitFunctionParameterTypeAnnotation(node, withDecorators) {
        if ("typeAnnotation" in node) {
          this.visitMetadataType(node.typeAnnotation, withDecorators);
        } else if (node.type === types_1.AST_NODE_TYPES.AssignmentPattern) {
          this.visitMetadataType(node.left.typeAnnotation, withDecorators);
        } else if (node.type === types_1.AST_NODE_TYPES.TSParameterProperty) {
          this.visitFunctionParameterTypeAnnotation(node.parameter, withDecorators);
        }
      }
      visitMethodFunction(node, methodNode) {
        var _a2, _b;
        if (node.id) {
          __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").scopeManager.nestFunctionExpressionNameScope(node);
        }
        __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").scopeManager.nestFunctionScope(node, true);
        let withMethodDecorators = !!methodNode.decorators;
        withMethodDecorators = withMethodDecorators || methodNode.kind !== "set" && node.params.some((param) => param.decorators);
        if (!withMethodDecorators && methodNode.kind === "set") {
          const keyName = getLiteralMethodKeyName(methodNode);
          if (keyName != null && ((_a2 = __classPrivateFieldGet2(this, _ClassVisitor_classNode, "f").body.body.find((node2) => node2 !== methodNode && node2.type === types_1.AST_NODE_TYPES.MethodDefinition && // Node must both be static or not
          node2.static === methodNode.static && getLiteralMethodKeyName(node2) === keyName)) === null || _a2 === void 0 ? void 0 : _a2.decorators)) {
            withMethodDecorators = true;
          }
        }
        if (!withMethodDecorators && methodNode.kind === "constructor" && __classPrivateFieldGet2(this, _ClassVisitor_classNode, "f").decorators) {
          withMethodDecorators = true;
        }
        for (const param of node.params) {
          this.visitPattern(param, (pattern, info) => {
            __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").currentScope().defineIdentifier(pattern, new definition_1.ParameterDefinition(pattern, node, info.rest));
            __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").referencingDefaultValue(pattern, info.assignments, null, true);
          }, { processRightHandNodes: true });
          this.visitFunctionParameterTypeAnnotation(param, withMethodDecorators);
          (_b = param.decorators) === null || _b === void 0 ? void 0 : _b.forEach((d) => this.visit(d));
        }
        this.visitMetadataType(node.returnType, withMethodDecorators);
        this.visitType(node.typeParameters);
        if (node.body) {
          if (node.body.type === types_1.AST_NODE_TYPES.BlockStatement) {
            __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").visitChildren(node.body);
          } else {
            __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").visit(node.body);
          }
        }
        __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").close(node);
      }
      visitPropertyBase(node) {
        var _a2;
        if (node.computed) {
          __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").visit(node.key);
        }
        if (node.value) {
          if (node.type === types_1.AST_NODE_TYPES.PropertyDefinition || node.type === types_1.AST_NODE_TYPES.AccessorProperty) {
            __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").scopeManager.nestClassFieldInitializerScope(node.value);
          }
          __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").visit(node.value);
          if (node.type === types_1.AST_NODE_TYPES.PropertyDefinition || node.type === types_1.AST_NODE_TYPES.AccessorProperty) {
            __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").close(node.value);
          }
        }
        if ("decorators" in node) {
          (_a2 = node.decorators) === null || _a2 === void 0 ? void 0 : _a2.forEach((d) => __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").visit(d));
        }
      }
      visitMethod(node) {
        var _a2;
        if (node.computed) {
          __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").visit(node.key);
        }
        if (node.value.type === types_1.AST_NODE_TYPES.FunctionExpression) {
          this.visitMethodFunction(node.value, node);
        } else {
          __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").visit(node.value);
        }
        if ("decorators" in node) {
          (_a2 = node.decorators) === null || _a2 === void 0 ? void 0 : _a2.forEach((d) => __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").visit(d));
        }
      }
      visitType(node) {
        if (!node) {
          return;
        }
        TypeVisitor_1.TypeVisitor.visit(__classPrivateFieldGet2(this, _ClassVisitor_referencer, "f"), node);
      }
      visitMetadataType(node, withDecorators) {
        if (!node) {
          return;
        }
        if (__classPrivateFieldGet2(this, _ClassVisitor_classNode, "f").type === types_1.AST_NODE_TYPES.ClassDeclaration && !__classPrivateFieldGet2(this, _ClassVisitor_classNode, "f").declare && node.typeAnnotation.type === types_1.AST_NODE_TYPES.TSTypeReference && __classPrivateFieldGet2(this, _ClassVisitor_emitDecoratorMetadata, "f")) {
          let entityName;
          if (node.typeAnnotation.typeName.type === types_1.AST_NODE_TYPES.TSQualifiedName) {
            let iter = node.typeAnnotation.typeName;
            while (iter.left.type === types_1.AST_NODE_TYPES.TSQualifiedName) {
              iter = iter.left;
            }
            entityName = iter.left;
          } else {
            entityName = node.typeAnnotation.typeName;
          }
          if (withDecorators) {
            if (entityName.type === types_1.AST_NODE_TYPES.Identifier) {
              __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").currentScope().referenceDualValueType(entityName);
            }
            if (node.typeAnnotation.typeParameters) {
              this.visitType(node.typeAnnotation.typeParameters);
            }
            return;
          }
        }
        this.visitType(node);
      }
      /////////////////////
      // Visit selectors //
      /////////////////////
      AccessorProperty(node) {
        this.visitPropertyDefinition(node);
      }
      ClassBody(node) {
        this.visitChildren(node);
      }
      PropertyDefinition(node) {
        this.visitPropertyDefinition(node);
      }
      MethodDefinition(node) {
        this.visitMethod(node);
      }
      TSAbstractAccessorProperty(node) {
        this.visitPropertyDefinition(node);
      }
      TSAbstractPropertyDefinition(node) {
        this.visitPropertyDefinition(node);
      }
      TSAbstractMethodDefinition(node) {
        this.visitPropertyBase(node);
      }
      Identifier(node) {
        __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").visit(node);
      }
      PrivateIdentifier() {
      }
      StaticBlock(node) {
        __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").scopeManager.nestClassStaticBlockScope(node);
        node.body.forEach((b) => this.visit(b));
        __classPrivateFieldGet2(this, _ClassVisitor_referencer, "f").close(node);
      }
    };
    exports.ClassVisitor = ClassVisitor;
    _ClassVisitor_classNode = /* @__PURE__ */ new WeakMap(), _ClassVisitor_referencer = /* @__PURE__ */ new WeakMap(), _ClassVisitor_emitDecoratorMetadata = /* @__PURE__ */ new WeakMap();
    function getLiteralMethodKeyName(node) {
      if (node.computed && node.key.type === types_1.AST_NODE_TYPES.Literal) {
        if (typeof node.key.value === "string" || typeof node.key.value === "number") {
          return node.key.value;
        }
      } else if (!node.computed && node.key.type === types_1.AST_NODE_TYPES.Identifier) {
        return node.key.name;
      }
      return null;
    }
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/referencer/ExportVisitor.js
var require_ExportVisitor = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/referencer/ExportVisitor.js"(exports) {
    "use strict";
    var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _ExportVisitor_referencer;
    var _ExportVisitor_exportNode;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExportVisitor = void 0;
    var types_1 = require_dist();
    var Visitor_1 = require_Visitor();
    var ExportVisitor = class extends Visitor_1.Visitor {
      constructor(node, referencer) {
        super(referencer);
        _ExportVisitor_referencer.set(this, void 0);
        _ExportVisitor_exportNode.set(this, void 0);
        __classPrivateFieldSet2(this, _ExportVisitor_exportNode, node, "f");
        __classPrivateFieldSet2(this, _ExportVisitor_referencer, referencer, "f");
      }
      static visit(referencer, node) {
        const exportReferencer = new ExportVisitor(node, referencer);
        exportReferencer.visit(node);
      }
      Identifier(node) {
        if (__classPrivateFieldGet2(this, _ExportVisitor_exportNode, "f").exportKind === "type") {
          __classPrivateFieldGet2(this, _ExportVisitor_referencer, "f").currentScope().referenceType(node);
        } else {
          __classPrivateFieldGet2(this, _ExportVisitor_referencer, "f").currentScope().referenceDualValueType(node);
        }
      }
      ExportDefaultDeclaration(node) {
        if (node.declaration.type === types_1.AST_NODE_TYPES.Identifier) {
          this.visit(node.declaration);
        } else {
        }
      }
      ExportNamedDeclaration(node) {
        if (node.source) {
          return;
        }
        if (!node.declaration) {
          this.visitChildren(node);
        } else {
        }
      }
      ExportSpecifier(node) {
        if (node.exportKind === "type") {
          __classPrivateFieldGet2(this, _ExportVisitor_referencer, "f").currentScope().referenceType(node.local);
        } else {
          this.visit(node.local);
        }
      }
    };
    exports.ExportVisitor = ExportVisitor;
    _ExportVisitor_referencer = /* @__PURE__ */ new WeakMap(), _ExportVisitor_exportNode = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/referencer/ImportVisitor.js
var require_ImportVisitor = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/referencer/ImportVisitor.js"(exports) {
    "use strict";
    var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _ImportVisitor_declaration;
    var _ImportVisitor_referencer;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImportVisitor = void 0;
    var definition_1 = require_definition();
    var Visitor_1 = require_Visitor();
    var ImportVisitor = class extends Visitor_1.Visitor {
      constructor(declaration, referencer) {
        super(referencer);
        _ImportVisitor_declaration.set(this, void 0);
        _ImportVisitor_referencer.set(this, void 0);
        __classPrivateFieldSet2(this, _ImportVisitor_declaration, declaration, "f");
        __classPrivateFieldSet2(this, _ImportVisitor_referencer, referencer, "f");
      }
      static visit(referencer, declaration) {
        const importReferencer = new ImportVisitor(declaration, referencer);
        importReferencer.visit(declaration);
      }
      visitImport(id, specifier) {
        __classPrivateFieldGet2(this, _ImportVisitor_referencer, "f").currentScope().defineIdentifier(id, new definition_1.ImportBindingDefinition(id, specifier, __classPrivateFieldGet2(this, _ImportVisitor_declaration, "f")));
      }
      ImportNamespaceSpecifier(node) {
        const local = node.local;
        this.visitImport(local, node);
      }
      ImportDefaultSpecifier(node) {
        const local = node.local;
        this.visitImport(local, node);
      }
      ImportSpecifier(node) {
        const local = node.local;
        this.visitImport(local, node);
      }
    };
    exports.ImportVisitor = ImportVisitor;
    _ImportVisitor_declaration = /* @__PURE__ */ new WeakMap(), _ImportVisitor_referencer = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/referencer/Referencer.js
var require_Referencer = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/referencer/Referencer.js"(exports) {
    "use strict";
    var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _Referencer_jsxPragma;
    var _Referencer_jsxFragmentName;
    var _Referencer_hasReferencedJsxFactory;
    var _Referencer_hasReferencedJsxFragmentFactory;
    var _Referencer_lib;
    var _Referencer_emitDecoratorMetadata;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Referencer = void 0;
    var types_1 = require_dist();
    var assert_1 = require_assert();
    var definition_1 = require_definition();
    var lib_1 = require_lib3();
    var ClassVisitor_1 = require_ClassVisitor();
    var ExportVisitor_1 = require_ExportVisitor();
    var ImportVisitor_1 = require_ImportVisitor();
    var PatternVisitor_1 = require_PatternVisitor();
    var Reference_1 = require_Reference();
    var TypeVisitor_1 = require_TypeVisitor();
    var Visitor_1 = require_Visitor();
    var Referencer = class extends Visitor_1.Visitor {
      constructor(options, scopeManager) {
        super(options);
        _Referencer_jsxPragma.set(this, void 0);
        _Referencer_jsxFragmentName.set(this, void 0);
        _Referencer_hasReferencedJsxFactory.set(this, false);
        _Referencer_hasReferencedJsxFragmentFactory.set(this, false);
        _Referencer_lib.set(this, void 0);
        _Referencer_emitDecoratorMetadata.set(this, void 0);
        this.scopeManager = scopeManager;
        __classPrivateFieldSet2(this, _Referencer_jsxPragma, options.jsxPragma, "f");
        __classPrivateFieldSet2(this, _Referencer_jsxFragmentName, options.jsxFragmentName, "f");
        __classPrivateFieldSet2(this, _Referencer_lib, options.lib, "f");
        __classPrivateFieldSet2(this, _Referencer_emitDecoratorMetadata, options.emitDecoratorMetadata, "f");
      }
      currentScope(dontThrowOnNull) {
        if (!dontThrowOnNull) {
          (0, assert_1.assert)(this.scopeManager.currentScope, "aaa");
        }
        return this.scopeManager.currentScope;
      }
      close(node) {
        while (this.currentScope(true) && node === this.currentScope().block) {
          this.scopeManager.currentScope = this.currentScope().close(this.scopeManager);
        }
      }
      referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {
        assignments.forEach((assignment) => {
          this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, assignment.right, maybeImplicitGlobal, init);
        });
      }
      populateGlobalsFromLib(globalScope) {
        for (const lib of __classPrivateFieldGet2(this, _Referencer_lib, "f")) {
          const variables = lib_1.lib[lib];
          if (!variables) {
            throw new Error(`Invalid value for lib provided: ${lib}`);
          }
          for (const [name, variable] of Object.entries(variables)) {
            globalScope.defineImplicitVariable(name, variable);
          }
        }
        globalScope.defineImplicitVariable("const", {
          eslintImplicitGlobalSetting: "readonly",
          isTypeVariable: true,
          isValueVariable: false
        });
      }
      /**
       * Searches for a variable named "name" in the upper scopes and adds a pseudo-reference from itself to itself
       */
      referenceInSomeUpperScope(name) {
        let scope = this.scopeManager.currentScope;
        while (scope) {
          const variable = scope.set.get(name);
          if (!variable) {
            scope = scope.upper;
            continue;
          }
          scope.referenceValue(variable.identifiers[0]);
          return true;
        }
        return false;
      }
      referenceJsxPragma() {
        if (__classPrivateFieldGet2(this, _Referencer_jsxPragma, "f") == null || __classPrivateFieldGet2(this, _Referencer_hasReferencedJsxFactory, "f")) {
          return;
        }
        __classPrivateFieldSet2(this, _Referencer_hasReferencedJsxFactory, this.referenceInSomeUpperScope(__classPrivateFieldGet2(this, _Referencer_jsxPragma, "f")), "f");
      }
      referenceJsxFragment() {
        if (__classPrivateFieldGet2(this, _Referencer_jsxFragmentName, "f") == null || __classPrivateFieldGet2(this, _Referencer_hasReferencedJsxFragmentFactory, "f")) {
          return;
        }
        __classPrivateFieldSet2(this, _Referencer_hasReferencedJsxFragmentFactory, this.referenceInSomeUpperScope(__classPrivateFieldGet2(this, _Referencer_jsxFragmentName, "f")), "f");
      }
      ///////////////////
      // Visit helpers //
      ///////////////////
      visitClass(node) {
        ClassVisitor_1.ClassVisitor.visit(this, node, __classPrivateFieldGet2(this, _Referencer_emitDecoratorMetadata, "f"));
      }
      visitForIn(node) {
        if (node.left.type === types_1.AST_NODE_TYPES.VariableDeclaration && node.left.kind !== "var") {
          this.scopeManager.nestForScope(node);
        }
        if (node.left.type === types_1.AST_NODE_TYPES.VariableDeclaration) {
          this.visit(node.left);
          this.visitPattern(node.left.declarations[0].id, (pattern) => {
            this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, node.right, null, true);
          });
        } else {
          this.visitPattern(node.left, (pattern, info) => {
            const maybeImplicitGlobal = !this.currentScope().isStrict ? {
              pattern,
              node
            } : null;
            this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
            this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, node.right, maybeImplicitGlobal, false);
          }, { processRightHandNodes: true });
        }
        this.visit(node.right);
        this.visit(node.body);
        this.close(node);
      }
      visitFunctionParameterTypeAnnotation(node) {
        if ("typeAnnotation" in node) {
          this.visitType(node.typeAnnotation);
        } else if (node.type === types_1.AST_NODE_TYPES.AssignmentPattern) {
          this.visitType(node.left.typeAnnotation);
        } else if (node.type === types_1.AST_NODE_TYPES.TSParameterProperty) {
          this.visitFunctionParameterTypeAnnotation(node.parameter);
        }
      }
      visitFunction(node) {
        var _a2;
        if (node.type === types_1.AST_NODE_TYPES.FunctionExpression) {
          if (node.id) {
            this.scopeManager.nestFunctionExpressionNameScope(node);
          }
        } else if (node.id) {
          this.currentScope().defineIdentifier(node.id, new definition_1.FunctionNameDefinition(node.id, node));
        }
        this.scopeManager.nestFunctionScope(node, false);
        for (const param of node.params) {
          this.visitPattern(param, (pattern, info) => {
            this.currentScope().defineIdentifier(pattern, new definition_1.ParameterDefinition(pattern, node, info.rest));
            this.referencingDefaultValue(pattern, info.assignments, null, true);
          }, { processRightHandNodes: true });
          this.visitFunctionParameterTypeAnnotation(param);
          (_a2 = param.decorators) === null || _a2 === void 0 ? void 0 : _a2.forEach((d) => this.visit(d));
        }
        this.visitType(node.returnType);
        this.visitType(node.typeParameters);
        if (node.body) {
          if (node.body.type === types_1.AST_NODE_TYPES.BlockStatement) {
            this.visitChildren(node.body);
          } else {
            this.visit(node.body);
          }
        }
        this.close(node);
      }
      visitProperty(node) {
        if (node.computed) {
          this.visit(node.key);
        }
        this.visit(node.value);
      }
      visitType(node) {
        if (!node) {
          return;
        }
        TypeVisitor_1.TypeVisitor.visit(this, node);
      }
      visitTypeAssertion(node) {
        this.visit(node.expression);
        this.visitType(node.typeAnnotation);
      }
      /////////////////////
      // Visit selectors //
      /////////////////////
      ArrowFunctionExpression(node) {
        this.visitFunction(node);
      }
      AssignmentExpression(node) {
        let left6 = node.left;
        switch (left6.type) {
          case types_1.AST_NODE_TYPES.TSAsExpression:
          case types_1.AST_NODE_TYPES.TSTypeAssertion:
            this.visitType(left6.typeAnnotation);
          case types_1.AST_NODE_TYPES.TSNonNullExpression:
            left6 = left6.expression;
        }
        if (PatternVisitor_1.PatternVisitor.isPattern(left6)) {
          if (node.operator === "=") {
            this.visitPattern(left6, (pattern, info) => {
              const maybeImplicitGlobal = !this.currentScope().isStrict ? {
                pattern,
                node
              } : null;
              this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
              this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, node.right, maybeImplicitGlobal, false);
            }, { processRightHandNodes: true });
          } else if (left6.type === types_1.AST_NODE_TYPES.Identifier) {
            this.currentScope().referenceValue(left6, Reference_1.ReferenceFlag.ReadWrite, node.right);
          }
        } else {
          this.visit(left6);
        }
        this.visit(node.right);
      }
      BlockStatement(node) {
        if (this.scopeManager.isES6()) {
          this.scopeManager.nestBlockScope(node);
        }
        this.visitChildren(node);
        this.close(node);
      }
      BreakStatement() {
      }
      CallExpression(node) {
        this.visitChildren(node, ["typeParameters"]);
        this.visitType(node.typeParameters);
      }
      CatchClause(node) {
        this.scopeManager.nestCatchScope(node);
        if (node.param) {
          const param = node.param;
          this.visitPattern(param, (pattern, info) => {
            this.currentScope().defineIdentifier(pattern, new definition_1.CatchClauseDefinition(param, node));
            this.referencingDefaultValue(pattern, info.assignments, null, true);
          }, { processRightHandNodes: true });
        }
        this.visit(node.body);
        this.close(node);
      }
      ClassExpression(node) {
        this.visitClass(node);
      }
      ClassDeclaration(node) {
        this.visitClass(node);
      }
      ContinueStatement() {
      }
      ExportAllDeclaration() {
      }
      ExportDefaultDeclaration(node) {
        if (node.declaration.type === types_1.AST_NODE_TYPES.Identifier) {
          ExportVisitor_1.ExportVisitor.visit(this, node);
        } else {
          this.visit(node.declaration);
        }
      }
      ExportNamedDeclaration(node) {
        if (node.declaration) {
          this.visit(node.declaration);
        } else {
          ExportVisitor_1.ExportVisitor.visit(this, node);
        }
      }
      ForInStatement(node) {
        this.visitForIn(node);
      }
      ForOfStatement(node) {
        this.visitForIn(node);
      }
      ForStatement(node) {
        if (node.init && node.init.type === types_1.AST_NODE_TYPES.VariableDeclaration && node.init.kind !== "var") {
          this.scopeManager.nestForScope(node);
        }
        this.visitChildren(node);
        this.close(node);
      }
      FunctionDeclaration(node) {
        this.visitFunction(node);
      }
      FunctionExpression(node) {
        this.visitFunction(node);
      }
      Identifier(node) {
        this.currentScope().referenceValue(node);
        this.visitType(node.typeAnnotation);
      }
      ImportDeclaration(node) {
        (0, assert_1.assert)(this.scopeManager.isES6() && this.scopeManager.isModule(), "ImportDeclaration should appear when the mode is ES6 and in the module context.");
        ImportVisitor_1.ImportVisitor.visit(this, node);
      }
      JSXAttribute(node) {
        this.visit(node.value);
      }
      JSXClosingElement() {
      }
      JSXFragment(node) {
        this.referenceJsxPragma();
        this.referenceJsxFragment();
        this.visitChildren(node);
      }
      JSXIdentifier(node) {
        this.currentScope().referenceValue(node);
      }
      JSXMemberExpression(node) {
        if (node.object.type !== types_1.AST_NODE_TYPES.JSXIdentifier) {
          this.visit(node.object);
        } else {
          if (node.object.name !== "this") {
            this.visit(node.object);
          }
        }
      }
      JSXOpeningElement(node) {
        this.referenceJsxPragma();
        if (node.name.type === types_1.AST_NODE_TYPES.JSXIdentifier) {
          if (node.name.name[0].toUpperCase() === node.name.name[0] || node.name.name === "this") {
            this.visit(node.name);
          }
        } else {
          this.visit(node.name);
        }
        this.visitType(node.typeParameters);
        for (const attr of node.attributes) {
          this.visit(attr);
        }
      }
      LabeledStatement(node) {
        this.visit(node.body);
      }
      MemberExpression(node) {
        this.visit(node.object);
        if (node.computed) {
          this.visit(node.property);
        }
      }
      MetaProperty() {
      }
      NewExpression(node) {
        this.visitChildren(node, ["typeParameters"]);
        this.visitType(node.typeParameters);
      }
      PrivateIdentifier() {
      }
      Program(node) {
        const globalScope = this.scopeManager.nestGlobalScope(node);
        this.populateGlobalsFromLib(globalScope);
        if (this.scopeManager.isGlobalReturn()) {
          this.currentScope().isStrict = false;
          this.scopeManager.nestFunctionScope(node, false);
        }
        if (this.scopeManager.isES6() && this.scopeManager.isModule()) {
          this.scopeManager.nestModuleScope(node);
        }
        if (this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict()) {
          this.currentScope().isStrict = true;
        }
        this.visitChildren(node);
        this.close(node);
      }
      Property(node) {
        this.visitProperty(node);
      }
      SwitchStatement(node) {
        this.visit(node.discriminant);
        if (this.scopeManager.isES6()) {
          this.scopeManager.nestSwitchScope(node);
        }
        for (const switchCase of node.cases) {
          this.visit(switchCase);
        }
        this.close(node);
      }
      TaggedTemplateExpression(node) {
        this.visit(node.tag);
        this.visit(node.quasi);
        this.visitType(node.typeParameters);
      }
      TSAsExpression(node) {
        this.visitTypeAssertion(node);
      }
      TSDeclareFunction(node) {
        this.visitFunction(node);
      }
      TSImportEqualsDeclaration(node) {
        this.currentScope().defineIdentifier(node.id, new definition_1.ImportBindingDefinition(node.id, node, node));
        if (node.moduleReference.type === types_1.AST_NODE_TYPES.TSQualifiedName) {
          this.visit(node.moduleReference.left);
        } else {
          this.visit(node.moduleReference);
        }
      }
      TSEmptyBodyFunctionExpression(node) {
        this.visitFunction(node);
      }
      TSEnumDeclaration(node) {
        this.currentScope().defineIdentifier(node.id, new definition_1.TSEnumNameDefinition(node.id, node));
        this.scopeManager.nestTSEnumScope(node);
        this.currentScope().defineIdentifier(node.id, new definition_1.TSEnumNameDefinition(node.id, node));
        for (const member of node.members) {
          if (member.id.type === types_1.AST_NODE_TYPES.Literal && typeof member.id.value === "string") {
            const name = member.id;
            this.currentScope().defineLiteralIdentifier(name, new definition_1.TSEnumMemberDefinition(name, member));
          } else if (!member.computed && member.id.type === types_1.AST_NODE_TYPES.Identifier) {
            this.currentScope().defineIdentifier(member.id, new definition_1.TSEnumMemberDefinition(member.id, member));
          }
          this.visit(member.initializer);
        }
        this.close(node);
      }
      TSInstantiationExpression(node) {
        this.visitChildren(node, ["typeParameters"]);
        this.visitType(node.typeParameters);
      }
      TSInterfaceDeclaration(node) {
        this.visitType(node);
      }
      TSModuleDeclaration(node) {
        if (node.id.type === types_1.AST_NODE_TYPES.Identifier && !node.global) {
          this.currentScope().defineIdentifier(node.id, new definition_1.TSModuleNameDefinition(node.id, node));
        }
        this.scopeManager.nestTSModuleScope(node);
        this.visit(node.body);
        this.close(node);
      }
      TSSatisfiesExpression(node) {
        this.visitTypeAssertion(node);
      }
      TSTypeAliasDeclaration(node) {
        this.visitType(node);
      }
      TSTypeAssertion(node) {
        this.visitTypeAssertion(node);
      }
      UpdateExpression(node) {
        if (PatternVisitor_1.PatternVisitor.isPattern(node.argument)) {
          this.visitPattern(node.argument, (pattern) => {
            this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.ReadWrite, null);
          });
        } else {
          this.visitChildren(node);
        }
      }
      VariableDeclaration(node) {
        const variableTargetScope = node.kind === "var" ? this.currentScope().variableScope : this.currentScope();
        for (const decl of node.declarations) {
          const init = decl.init;
          this.visitPattern(decl.id, (pattern, info) => {
            variableTargetScope.defineIdentifier(pattern, new definition_1.VariableDefinition(pattern, decl, node));
            this.referencingDefaultValue(pattern, info.assignments, null, true);
            if (init) {
              this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, init, null, true);
            }
          }, { processRightHandNodes: true });
          if (decl.init) {
            this.visit(decl.init);
          }
          if ("typeAnnotation" in decl.id) {
            this.visitType(decl.id.typeAnnotation);
          }
        }
      }
      WithStatement(node) {
        this.visit(node.object);
        this.scopeManager.nestWithScope(node);
        this.visit(node.body);
        this.close(node);
      }
      ImportAttribute() {
      }
    };
    exports.Referencer = Referencer;
    _Referencer_jsxPragma = /* @__PURE__ */ new WeakMap(), _Referencer_jsxFragmentName = /* @__PURE__ */ new WeakMap(), _Referencer_hasReferencedJsxFactory = /* @__PURE__ */ new WeakMap(), _Referencer_hasReferencedJsxFragmentFactory = /* @__PURE__ */ new WeakMap(), _Referencer_lib = /* @__PURE__ */ new WeakMap(), _Referencer_emitDecoratorMetadata = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/referencer/index.js
var require_referencer = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/referencer/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Referencer = void 0;
    var Referencer_1 = require_Referencer();
    Object.defineProperty(exports, "Referencer", { enumerable: true, get: function() {
      return Referencer_1.Referencer;
    } });
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/ClassStaticBlockScope.js
var require_ClassStaticBlockScope = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/scope/ClassStaticBlockScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassStaticBlockScope = void 0;
    var ScopeBase_1 = require_ScopeBase();
    var ScopeType_1 = require_ScopeType();
    var ClassStaticBlockScope = class extends ScopeBase_1.ScopeBase {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, ScopeType_1.ScopeType.classStaticBlock, upperScope, block, false);
      }
    };
    exports.ClassStaticBlockScope = ClassStaticBlockScope;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/ScopeManager.js
var require_ScopeManager = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/ScopeManager.js"(exports) {
    "use strict";
    var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _ScopeManager_options;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScopeManager = void 0;
    var assert_1 = require_assert();
    var scope_1 = require_scope();
    var ClassFieldInitializerScope_1 = require_ClassFieldInitializerScope();
    var ClassStaticBlockScope_1 = require_ClassStaticBlockScope();
    var ScopeManager = class {
      get variables() {
        const variables = /* @__PURE__ */ new Set();
        function recurse(scope) {
          scope.variables.forEach((v) => variables.add(v));
          scope.childScopes.forEach(recurse);
        }
        this.scopes.forEach(recurse);
        return Array.from(variables).sort((a, b) => a.$id - b.$id);
      }
      constructor(options) {
        _ScopeManager_options.set(this, void 0);
        this.scopes = [];
        this.globalScope = null;
        this.nodeToScope = /* @__PURE__ */ new WeakMap();
        this.currentScope = null;
        __classPrivateFieldSet2(this, _ScopeManager_options, options, "f");
        this.declaredVariables = /* @__PURE__ */ new WeakMap();
      }
      isGlobalReturn() {
        return __classPrivateFieldGet2(this, _ScopeManager_options, "f").globalReturn === true;
      }
      isModule() {
        return __classPrivateFieldGet2(this, _ScopeManager_options, "f").sourceType === "module";
      }
      isImpliedStrict() {
        return __classPrivateFieldGet2(this, _ScopeManager_options, "f").impliedStrict === true;
      }
      isStrictModeSupported() {
        return __classPrivateFieldGet2(this, _ScopeManager_options, "f").ecmaVersion != null && __classPrivateFieldGet2(this, _ScopeManager_options, "f").ecmaVersion >= 5;
      }
      isES6() {
        return __classPrivateFieldGet2(this, _ScopeManager_options, "f").ecmaVersion != null && __classPrivateFieldGet2(this, _ScopeManager_options, "f").ecmaVersion >= 6;
      }
      /**
       * Get the variables that a given AST node defines. The gotten variables' `def[].node`/`def[].parent` property is the node.
       * If the node does not define any variable, this returns an empty array.
       * @param node An AST node to get their variables.
       * @public
       */
      getDeclaredVariables(node) {
        var _a2;
        return (_a2 = this.declaredVariables.get(node)) !== null && _a2 !== void 0 ? _a2 : [];
      }
      /**
       * Get the scope of a given AST node. The gotten scope's `block` property is the node.
       * This method never returns `function-expression-name` scope. If the node does not have their scope, this returns `null`.
       *
       * @param node An AST node to get their scope.
       * @param inner If the node has multiple scopes, this returns the outermost scope normally.
       *                If `inner` is `true` then this returns the innermost scope.
       * @public
       */
      acquire(node, inner = false) {
        var _a2;
        function predicate(testScope) {
          if (testScope.type === "function" && testScope.functionExpressionScope) {
            return false;
          }
          return true;
        }
        const scopes = this.nodeToScope.get(node);
        if (!scopes || scopes.length === 0) {
          return null;
        }
        if (scopes.length === 1) {
          return scopes[0];
        }
        if (inner) {
          for (let i = scopes.length - 1; i >= 0; --i) {
            const scope = scopes[i];
            if (predicate(scope)) {
              return scope;
            }
          }
          return null;
        }
        return (_a2 = scopes.find(predicate)) !== null && _a2 !== void 0 ? _a2 : null;
      }
      nestScope(scope) {
        if (scope instanceof scope_1.GlobalScope) {
          (0, assert_1.assert)(this.currentScope == null);
          this.globalScope = scope;
        }
        this.currentScope = scope;
        return scope;
      }
      nestBlockScope(node) {
        (0, assert_1.assert)(this.currentScope);
        return this.nestScope(new scope_1.BlockScope(this, this.currentScope, node));
      }
      nestCatchScope(node) {
        (0, assert_1.assert)(this.currentScope);
        return this.nestScope(new scope_1.CatchScope(this, this.currentScope, node));
      }
      nestClassScope(node) {
        (0, assert_1.assert)(this.currentScope);
        return this.nestScope(new scope_1.ClassScope(this, this.currentScope, node));
      }
      nestClassFieldInitializerScope(node) {
        (0, assert_1.assert)(this.currentScope);
        return this.nestScope(new ClassFieldInitializerScope_1.ClassFieldInitializerScope(this, this.currentScope, node));
      }
      nestClassStaticBlockScope(node) {
        (0, assert_1.assert)(this.currentScope);
        return this.nestScope(new ClassStaticBlockScope_1.ClassStaticBlockScope(this, this.currentScope, node));
      }
      nestConditionalTypeScope(node) {
        (0, assert_1.assert)(this.currentScope);
        return this.nestScope(new scope_1.ConditionalTypeScope(this, this.currentScope, node));
      }
      nestForScope(node) {
        (0, assert_1.assert)(this.currentScope);
        return this.nestScope(new scope_1.ForScope(this, this.currentScope, node));
      }
      nestFunctionExpressionNameScope(node) {
        (0, assert_1.assert)(this.currentScope);
        return this.nestScope(new scope_1.FunctionExpressionNameScope(this, this.currentScope, node));
      }
      nestFunctionScope(node, isMethodDefinition) {
        (0, assert_1.assert)(this.currentScope);
        return this.nestScope(new scope_1.FunctionScope(this, this.currentScope, node, isMethodDefinition));
      }
      nestFunctionTypeScope(node) {
        (0, assert_1.assert)(this.currentScope);
        return this.nestScope(new scope_1.FunctionTypeScope(this, this.currentScope, node));
      }
      nestGlobalScope(node) {
        return this.nestScope(new scope_1.GlobalScope(this, node));
      }
      nestMappedTypeScope(node) {
        (0, assert_1.assert)(this.currentScope);
        return this.nestScope(new scope_1.MappedTypeScope(this, this.currentScope, node));
      }
      nestModuleScope(node) {
        (0, assert_1.assert)(this.currentScope);
        return this.nestScope(new scope_1.ModuleScope(this, this.currentScope, node));
      }
      nestSwitchScope(node) {
        (0, assert_1.assert)(this.currentScope);
        return this.nestScope(new scope_1.SwitchScope(this, this.currentScope, node));
      }
      nestTSEnumScope(node) {
        (0, assert_1.assert)(this.currentScope);
        return this.nestScope(new scope_1.TSEnumScope(this, this.currentScope, node));
      }
      nestTSModuleScope(node) {
        (0, assert_1.assert)(this.currentScope);
        return this.nestScope(new scope_1.TSModuleScope(this, this.currentScope, node));
      }
      nestTypeScope(node) {
        (0, assert_1.assert)(this.currentScope);
        return this.nestScope(new scope_1.TypeScope(this, this.currentScope, node));
      }
      nestWithScope(node) {
        (0, assert_1.assert)(this.currentScope);
        return this.nestScope(new scope_1.WithScope(this, this.currentScope, node));
      }
    };
    exports.ScopeManager = ScopeManager;
    _ScopeManager_options = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/analyze.js
var require_analyze = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/analyze.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.analyze = void 0;
    var visitor_keys_1 = require_dist2();
    var lib_1 = require_lib3();
    var referencer_1 = require_referencer();
    var ScopeManager_1 = require_ScopeManager();
    var DEFAULT_OPTIONS = {
      childVisitorKeys: visitor_keys_1.visitorKeys,
      ecmaVersion: 2018,
      globalReturn: false,
      impliedStrict: false,
      jsxPragma: "React",
      jsxFragmentName: null,
      lib: ["es2018"],
      sourceType: "script",
      emitDecoratorMetadata: false
    };
    function mapEcmaVersion(version) {
      if (version == null || version === 3 || version === 5) {
        return "es5";
      }
      const year = version > 2e3 ? version : 2015 + (version - 6);
      const lib = `es${year}`;
      return lib in lib_1.lib ? lib : year > 2020 ? "esnext" : "es5";
    }
    function analyze(tree, providedOptions) {
      var _a2, _b, _c, _d, _e, _f, _g, _h;
      const ecmaVersion = (_a2 = providedOptions === null || providedOptions === void 0 ? void 0 : providedOptions.ecmaVersion) !== null && _a2 !== void 0 ? _a2 : DEFAULT_OPTIONS.ecmaVersion;
      const options = {
        childVisitorKeys: (_b = providedOptions === null || providedOptions === void 0 ? void 0 : providedOptions.childVisitorKeys) !== null && _b !== void 0 ? _b : DEFAULT_OPTIONS.childVisitorKeys,
        ecmaVersion,
        globalReturn: (_c = providedOptions === null || providedOptions === void 0 ? void 0 : providedOptions.globalReturn) !== null && _c !== void 0 ? _c : DEFAULT_OPTIONS.globalReturn,
        impliedStrict: (_d = providedOptions === null || providedOptions === void 0 ? void 0 : providedOptions.impliedStrict) !== null && _d !== void 0 ? _d : DEFAULT_OPTIONS.impliedStrict,
        jsxPragma: (providedOptions === null || providedOptions === void 0 ? void 0 : providedOptions.jsxPragma) === void 0 ? DEFAULT_OPTIONS.jsxPragma : providedOptions.jsxPragma,
        jsxFragmentName: (_e = providedOptions === null || providedOptions === void 0 ? void 0 : providedOptions.jsxFragmentName) !== null && _e !== void 0 ? _e : DEFAULT_OPTIONS.jsxFragmentName,
        sourceType: (_f = providedOptions === null || providedOptions === void 0 ? void 0 : providedOptions.sourceType) !== null && _f !== void 0 ? _f : DEFAULT_OPTIONS.sourceType,
        lib: (_g = providedOptions === null || providedOptions === void 0 ? void 0 : providedOptions.lib) !== null && _g !== void 0 ? _g : [mapEcmaVersion(ecmaVersion)],
        emitDecoratorMetadata: (_h = providedOptions === null || providedOptions === void 0 ? void 0 : providedOptions.emitDecoratorMetadata) !== null && _h !== void 0 ? _h : DEFAULT_OPTIONS.emitDecoratorMetadata
      };
      options.lib = options.lib.map((l) => l.toLowerCase());
      const scopeManager = new ScopeManager_1.ScopeManager(options);
      const referencer = new referencer_1.Referencer(options, scopeManager);
      referencer.visit(tree);
      return scopeManager;
    }
    exports.analyze = analyze;
  }
});

// node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+scope-manager@5.59.2/node_modules/@typescript-eslint/scope-manager/dist/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding2(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScopeManager = exports.PatternVisitor = exports.Visitor = exports.Reference = exports.analyze = void 0;
    var analyze_1 = require_analyze();
    Object.defineProperty(exports, "analyze", { enumerable: true, get: function() {
      return analyze_1.analyze;
    } });
    __exportStar2(require_definition(), exports);
    var Reference_1 = require_Reference();
    Object.defineProperty(exports, "Reference", { enumerable: true, get: function() {
      return Reference_1.Reference;
    } });
    var Visitor_1 = require_Visitor();
    Object.defineProperty(exports, "Visitor", { enumerable: true, get: function() {
      return Visitor_1.Visitor;
    } });
    var PatternVisitor_1 = require_PatternVisitor();
    Object.defineProperty(exports, "PatternVisitor", { enumerable: true, get: function() {
      return PatternVisitor_1.PatternVisitor;
    } });
    __exportStar2(require_scope(), exports);
    var ScopeManager_1 = require_ScopeManager();
    Object.defineProperty(exports, "ScopeManager", { enumerable: true, get: function() {
      return ScopeManager_1.ScopeManager;
    } });
    __exportStar2(require_variable(), exports);
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint/Scope.js
var require_Scope2 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint/Scope.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Scope = void 0;
    var scopeManager = __importStar2(require_dist4());
    var Scope;
    (function(Scope2) {
      Scope2.ScopeType = scopeManager.ScopeType;
      Scope2.DefinitionType = scopeManager.DefinitionType;
    })(Scope || (Scope = {}));
    exports.Scope = Scope;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint/SourceCode.js
var require_SourceCode = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint/SourceCode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SourceCode = void 0;
    var eslint_1 = require("eslint");
    var SourceCode = class extends eslint_1.SourceCode {
    };
    exports.SourceCode = SourceCode;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint/index.js
var require_ts_eslint = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding2(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar2(require_AST(), exports);
    __exportStar2(require_CLIEngine(), exports);
    __exportStar2(require_ESLint(), exports);
    __exportStar2(require_Linter(), exports);
    __exportStar2(require_ParserOptions(), exports);
    __exportStar2(require_Rule(), exports);
    __exportStar2(require_RuleTester(), exports);
    __exportStar2(require_Scope2(), exports);
    __exportStar2(require_SourceCode(), exports);
  }
});

// node_modules/.pnpm/estraverse@4.3.0/node_modules/estraverse/package.json
var require_package2 = __commonJS({
  "node_modules/.pnpm/estraverse@4.3.0/node_modules/estraverse/package.json"(exports, module2) {
    module2.exports = {
      name: "estraverse",
      description: "ECMAScript JS AST traversal functions",
      homepage: "https://github.com/estools/estraverse",
      main: "estraverse.js",
      version: "4.3.0",
      engines: {
        node: ">=4.0"
      },
      maintainers: [
        {
          name: "Yusuke Suzuki",
          email: "utatane.tea@gmail.com",
          web: "http://github.com/Constellation"
        }
      ],
      repository: {
        type: "git",
        url: "http://github.com/estools/estraverse.git"
      },
      devDependencies: {
        "babel-preset-env": "^1.6.1",
        "babel-register": "^6.3.13",
        chai: "^2.1.1",
        espree: "^1.11.0",
        gulp: "^3.8.10",
        "gulp-bump": "^0.2.2",
        "gulp-filter": "^2.0.0",
        "gulp-git": "^1.0.1",
        "gulp-tag-version": "^1.3.0",
        jshint: "^2.5.6",
        mocha: "^2.1.0"
      },
      license: "BSD-2-Clause",
      scripts: {
        test: "npm run-script lint && npm run-script unit-test",
        lint: "jshint estraverse.js",
        "unit-test": "mocha --compilers js:babel-register"
      }
    };
  }
});

// node_modules/.pnpm/estraverse@4.3.0/node_modules/estraverse/estraverse.js
var require_estraverse = __commonJS({
  "node_modules/.pnpm/estraverse@4.3.0/node_modules/estraverse/estraverse.js"(exports) {
    (function clone(exports2) {
      "use strict";
      var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;
      function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            val = obj[key];
            if (typeof val === "object" && val !== null) {
              ret[key] = deepCopy(val);
            } else {
              ret[key] = val;
            }
          }
        }
        return ret;
      }
      function upperBound(array, func) {
        var diff, len, i, current;
        len = array.length;
        i = 0;
        while (len) {
          diff = len >>> 1;
          current = i + diff;
          if (func(array[current])) {
            len = diff;
          } else {
            i = current + 1;
            len -= diff + 1;
          }
        }
        return i;
      }
      Syntax = {
        AssignmentExpression: "AssignmentExpression",
        AssignmentPattern: "AssignmentPattern",
        ArrayExpression: "ArrayExpression",
        ArrayPattern: "ArrayPattern",
        ArrowFunctionExpression: "ArrowFunctionExpression",
        AwaitExpression: "AwaitExpression",
        // CAUTION: It's deferred to ES7.
        BlockStatement: "BlockStatement",
        BinaryExpression: "BinaryExpression",
        BreakStatement: "BreakStatement",
        CallExpression: "CallExpression",
        CatchClause: "CatchClause",
        ClassBody: "ClassBody",
        ClassDeclaration: "ClassDeclaration",
        ClassExpression: "ClassExpression",
        ComprehensionBlock: "ComprehensionBlock",
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: "ComprehensionExpression",
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: "ConditionalExpression",
        ContinueStatement: "ContinueStatement",
        DebuggerStatement: "DebuggerStatement",
        DirectiveStatement: "DirectiveStatement",
        DoWhileStatement: "DoWhileStatement",
        EmptyStatement: "EmptyStatement",
        ExportAllDeclaration: "ExportAllDeclaration",
        ExportDefaultDeclaration: "ExportDefaultDeclaration",
        ExportNamedDeclaration: "ExportNamedDeclaration",
        ExportSpecifier: "ExportSpecifier",
        ExpressionStatement: "ExpressionStatement",
        ForStatement: "ForStatement",
        ForInStatement: "ForInStatement",
        ForOfStatement: "ForOfStatement",
        FunctionDeclaration: "FunctionDeclaration",
        FunctionExpression: "FunctionExpression",
        GeneratorExpression: "GeneratorExpression",
        // CAUTION: It's deferred to ES7.
        Identifier: "Identifier",
        IfStatement: "IfStatement",
        ImportExpression: "ImportExpression",
        ImportDeclaration: "ImportDeclaration",
        ImportDefaultSpecifier: "ImportDefaultSpecifier",
        ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
        ImportSpecifier: "ImportSpecifier",
        Literal: "Literal",
        LabeledStatement: "LabeledStatement",
        LogicalExpression: "LogicalExpression",
        MemberExpression: "MemberExpression",
        MetaProperty: "MetaProperty",
        MethodDefinition: "MethodDefinition",
        ModuleSpecifier: "ModuleSpecifier",
        NewExpression: "NewExpression",
        ObjectExpression: "ObjectExpression",
        ObjectPattern: "ObjectPattern",
        Program: "Program",
        Property: "Property",
        RestElement: "RestElement",
        ReturnStatement: "ReturnStatement",
        SequenceExpression: "SequenceExpression",
        SpreadElement: "SpreadElement",
        Super: "Super",
        SwitchStatement: "SwitchStatement",
        SwitchCase: "SwitchCase",
        TaggedTemplateExpression: "TaggedTemplateExpression",
        TemplateElement: "TemplateElement",
        TemplateLiteral: "TemplateLiteral",
        ThisExpression: "ThisExpression",
        ThrowStatement: "ThrowStatement",
        TryStatement: "TryStatement",
        UnaryExpression: "UnaryExpression",
        UpdateExpression: "UpdateExpression",
        VariableDeclaration: "VariableDeclaration",
        VariableDeclarator: "VariableDeclarator",
        WhileStatement: "WhileStatement",
        WithStatement: "WithStatement",
        YieldExpression: "YieldExpression"
      };
      VisitorKeys = {
        AssignmentExpression: ["left", "right"],
        AssignmentPattern: ["left", "right"],
        ArrayExpression: ["elements"],
        ArrayPattern: ["elements"],
        ArrowFunctionExpression: ["params", "body"],
        AwaitExpression: ["argument"],
        // CAUTION: It's deferred to ES7.
        BlockStatement: ["body"],
        BinaryExpression: ["left", "right"],
        BreakStatement: ["label"],
        CallExpression: ["callee", "arguments"],
        CatchClause: ["param", "body"],
        ClassBody: ["body"],
        ClassDeclaration: ["id", "superClass", "body"],
        ClassExpression: ["id", "superClass", "body"],
        ComprehensionBlock: ["left", "right"],
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: ["test", "consequent", "alternate"],
        ContinueStatement: ["label"],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ["body", "test"],
        EmptyStatement: [],
        ExportAllDeclaration: ["source"],
        ExportDefaultDeclaration: ["declaration"],
        ExportNamedDeclaration: ["declaration", "specifiers", "source"],
        ExportSpecifier: ["exported", "local"],
        ExpressionStatement: ["expression"],
        ForStatement: ["init", "test", "update", "body"],
        ForInStatement: ["left", "right", "body"],
        ForOfStatement: ["left", "right", "body"],
        FunctionDeclaration: ["id", "params", "body"],
        FunctionExpression: ["id", "params", "body"],
        GeneratorExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ["test", "consequent", "alternate"],
        ImportExpression: ["source"],
        ImportDeclaration: ["specifiers", "source"],
        ImportDefaultSpecifier: ["local"],
        ImportNamespaceSpecifier: ["local"],
        ImportSpecifier: ["imported", "local"],
        Literal: [],
        LabeledStatement: ["label", "body"],
        LogicalExpression: ["left", "right"],
        MemberExpression: ["object", "property"],
        MetaProperty: ["meta", "property"],
        MethodDefinition: ["key", "value"],
        ModuleSpecifier: [],
        NewExpression: ["callee", "arguments"],
        ObjectExpression: ["properties"],
        ObjectPattern: ["properties"],
        Program: ["body"],
        Property: ["key", "value"],
        RestElement: ["argument"],
        ReturnStatement: ["argument"],
        SequenceExpression: ["expressions"],
        SpreadElement: ["argument"],
        Super: [],
        SwitchStatement: ["discriminant", "cases"],
        SwitchCase: ["test", "consequent"],
        TaggedTemplateExpression: ["tag", "quasi"],
        TemplateElement: [],
        TemplateLiteral: ["quasis", "expressions"],
        ThisExpression: [],
        ThrowStatement: ["argument"],
        TryStatement: ["block", "handler", "finalizer"],
        UnaryExpression: ["argument"],
        UpdateExpression: ["argument"],
        VariableDeclaration: ["declarations"],
        VariableDeclarator: ["id", "init"],
        WhileStatement: ["test", "body"],
        WithStatement: ["object", "body"],
        YieldExpression: ["argument"]
      };
      BREAK = {};
      SKIP = {};
      REMOVE = {};
      VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
      };
      function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
      }
      Reference.prototype.replace = function replace2(node) {
        this.parent[this.key] = node;
      };
      Reference.prototype.remove = function remove() {
        if (Array.isArray(this.parent)) {
          this.parent.splice(this.key, 1);
          return true;
        } else {
          this.replace(null);
          return false;
        }
      };
      function Element(node, path6, wrap, ref) {
        this.node = node;
        this.path = path6;
        this.wrap = wrap;
        this.ref = ref;
      }
      function Controller() {
      }
      Controller.prototype.path = function path6() {
        var i, iz, j, jz, result, element;
        function addToPath(result2, path7) {
          if (Array.isArray(path7)) {
            for (j = 0, jz = path7.length; j < jz; ++j) {
              result2.push(path7[j]);
            }
          } else {
            result2.push(path7);
          }
        }
        if (!this.__current.path) {
          return null;
        }
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
          element = this.__leavelist[i];
          addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
      };
      Controller.prototype.type = function() {
        var node = this.current();
        return node.type || this.__current.wrap;
      };
      Controller.prototype.parents = function parents() {
        var i, iz, result;
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
          result.push(this.__leavelist[i].node);
        }
        return result;
      };
      Controller.prototype.current = function current() {
        return this.__current.node;
      };
      Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;
        result = void 0;
        previous = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
          result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;
        return result;
      };
      Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
      };
      Controller.prototype.skip = function() {
        this.notify(SKIP);
      };
      Controller.prototype["break"] = function() {
        this.notify(BREAK);
      };
      Controller.prototype.remove = function() {
        this.notify(REMOVE);
      };
      Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = null;
        if (visitor.fallback === "iteration") {
          this.__fallback = Object.keys;
        } else if (typeof visitor.fallback === "function") {
          this.__fallback = visitor.fallback;
        }
        this.__keys = VisitorKeys;
        if (visitor.keys) {
          this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
        }
      };
      function isNode(node) {
        if (node == null) {
          return false;
        }
        return typeof node === "object" && typeof node.type === "string";
      }
      function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && "properties" === key;
      }
      Controller.prototype.traverse = function traverse2(root, visitor) {
        var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            ret = this.__execute(visitor.leave, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            continue;
          }
          if (element.node) {
            ret = this.__execute(visitor.enter, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            worklist.push(sentinel);
            leavelist.push(element);
            if (this.__state === SKIP || ret === SKIP) {
              continue;
            }
            node = element.node;
            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
              if (this.__fallback) {
                candidates = this.__fallback(node);
              } else {
                throw new Error("Unknown node type " + nodeType + ".");
              }
            }
            current = candidates.length;
            while ((current -= 1) >= 0) {
              key = candidates[current];
              candidate = node[key];
              if (!candidate) {
                continue;
              }
              if (Array.isArray(candidate)) {
                current2 = candidate.length;
                while ((current2 -= 1) >= 0) {
                  if (!candidate[current2]) {
                    continue;
                  }
                  if (isProperty(nodeType, candidates[current])) {
                    element = new Element(candidate[current2], [key, current2], "Property", null);
                  } else if (isNode(candidate[current2])) {
                    element = new Element(candidate[current2], [key, current2], null, null);
                  } else {
                    continue;
                  }
                  worklist.push(element);
                }
              } else if (isNode(candidate)) {
                worklist.push(new Element(candidate, key, null, null));
              }
            }
          }
        }
      };
      Controller.prototype.replace = function replace2(root, visitor) {
        var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
        function removeElem(element2) {
          var i, key2, nextElem, parent;
          if (element2.ref.remove()) {
            key2 = element2.ref.key;
            parent = element2.ref.parent;
            i = worklist.length;
            while (i--) {
              nextElem = worklist[i];
              if (nextElem.ref && nextElem.ref.parent === parent) {
                if (nextElem.ref.key < key2) {
                  break;
                }
                --nextElem.ref.key;
              }
            }
          }
        }
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        outer = {
          root
        };
        element = new Element(root, null, null, new Reference(outer, "root"));
        worklist.push(element);
        leavelist.push(element);
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            target = this.__execute(visitor.leave, element);
            if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
              element.ref.replace(target);
            }
            if (this.__state === REMOVE || target === REMOVE) {
              removeElem(element);
            }
            if (this.__state === BREAK || target === BREAK) {
              return outer.root;
            }
            continue;
          }
          target = this.__execute(visitor.enter, element);
          if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
            element.ref.replace(target);
            element.node = target;
          }
          if (this.__state === REMOVE || target === REMOVE) {
            removeElem(element);
            element.node = null;
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          node = element.node;
          if (!node) {
            continue;
          }
          worklist.push(sentinel);
          leavelist.push(element);
          if (this.__state === SKIP || target === SKIP) {
            continue;
          }
          nodeType = node.type || element.wrap;
          candidates = this.__keys[nodeType];
          if (!candidates) {
            if (this.__fallback) {
              candidates = this.__fallback(node);
            } else {
              throw new Error("Unknown node type " + nodeType + ".");
            }
          }
          current = candidates.length;
          while ((current -= 1) >= 0) {
            key = candidates[current];
            candidate = node[key];
            if (!candidate) {
              continue;
            }
            if (Array.isArray(candidate)) {
              current2 = candidate.length;
              while ((current2 -= 1) >= 0) {
                if (!candidate[current2]) {
                  continue;
                }
                if (isProperty(nodeType, candidates[current])) {
                  element = new Element(candidate[current2], [key, current2], "Property", new Reference(candidate, current2));
                } else if (isNode(candidate[current2])) {
                  element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                } else {
                  continue;
                }
                worklist.push(element);
              }
            } else if (isNode(candidate)) {
              worklist.push(new Element(candidate, key, null, new Reference(node, key)));
            }
          }
        }
        return outer.root;
      };
      function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
      }
      function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
      }
      function extendCommentRange(comment, tokens) {
        var target;
        target = upperBound(tokens, function search(token) {
          return token.range[0] > comment.range[0];
        });
        comment.extendedRange = [comment.range[0], comment.range[1]];
        if (target !== tokens.length) {
          comment.extendedRange[1] = tokens[target].range[0];
        }
        target -= 1;
        if (target >= 0) {
          comment.extendedRange[0] = tokens[target].range[1];
        }
        return comment;
      }
      function attachComments(tree, providedComments, tokens) {
        var comments = [], comment, len, i, cursor;
        if (!tree.range) {
          throw new Error("attachComments needs range information");
        }
        if (!tokens.length) {
          if (providedComments.length) {
            for (i = 0, len = providedComments.length; i < len; i += 1) {
              comment = deepCopy(providedComments[i]);
              comment.extendedRange = [0, tree.range[0]];
              comments.push(comment);
            }
            tree.leadingComments = comments;
          }
          return tree;
        }
        for (i = 0, len = providedComments.length; i < len; i += 1) {
          comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }
        cursor = 0;
        traverse(tree, {
          enter: function(node) {
            var comment2;
            while (cursor < comments.length) {
              comment2 = comments[cursor];
              if (comment2.extendedRange[1] > node.range[0]) {
                break;
              }
              if (comment2.extendedRange[1] === node.range[0]) {
                if (!node.leadingComments) {
                  node.leadingComments = [];
                }
                node.leadingComments.push(comment2);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        cursor = 0;
        traverse(tree, {
          leave: function(node) {
            var comment2;
            while (cursor < comments.length) {
              comment2 = comments[cursor];
              if (node.range[1] < comment2.extendedRange[0]) {
                break;
              }
              if (node.range[1] === comment2.extendedRange[0]) {
                if (!node.trailingComments) {
                  node.trailingComments = [];
                }
                node.trailingComments.push(comment2);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        return tree;
      }
      exports2.version = require_package2().version;
      exports2.Syntax = Syntax;
      exports2.traverse = traverse;
      exports2.replace = replace;
      exports2.attachComments = attachComments;
      exports2.VisitorKeys = VisitorKeys;
      exports2.VisitorOption = VisitorOption;
      exports2.Controller = Controller;
      exports2.cloneEnvironment = function() {
        return clone({});
      };
      return exports2;
    })(exports);
  }
});

// node_modules/.pnpm/eslint-scope@5.1.1/node_modules/eslint-scope/lib/reference.js
var require_reference = __commonJS({
  "node_modules/.pnpm/eslint-scope@5.1.1/node_modules/eslint-scope/lib/reference.js"(exports, module2) {
    "use strict";
    var READ = 1;
    var WRITE = 2;
    var RW = READ | WRITE;
    var Reference = class {
      constructor(ident, scope, flag, writeExpr, maybeImplicitGlobal, partial, init) {
        this.identifier = ident;
        this.from = scope;
        this.tainted = false;
        this.resolved = null;
        this.flag = flag;
        if (this.isWrite()) {
          this.writeExpr = writeExpr;
          this.partial = partial;
          this.init = init;
        }
        this.__maybeImplicitGlobal = maybeImplicitGlobal;
      }
      /**
       * Whether the reference is static.
       * @method Reference#isStatic
       * @returns {boolean} static
       */
      isStatic() {
        return !this.tainted && this.resolved && this.resolved.scope.isStatic();
      }
      /**
       * Whether the reference is writeable.
       * @method Reference#isWrite
       * @returns {boolean} write
       */
      isWrite() {
        return !!(this.flag & Reference.WRITE);
      }
      /**
       * Whether the reference is readable.
       * @method Reference#isRead
       * @returns {boolean} read
       */
      isRead() {
        return !!(this.flag & Reference.READ);
      }
      /**
       * Whether the reference is read-only.
       * @method Reference#isReadOnly
       * @returns {boolean} read only
       */
      isReadOnly() {
        return this.flag === Reference.READ;
      }
      /**
       * Whether the reference is write-only.
       * @method Reference#isWriteOnly
       * @returns {boolean} write only
       */
      isWriteOnly() {
        return this.flag === Reference.WRITE;
      }
      /**
       * Whether the reference is read-write.
       * @method Reference#isReadWrite
       * @returns {boolean} read write
       */
      isReadWrite() {
        return this.flag === Reference.RW;
      }
    };
    Reference.READ = READ;
    Reference.WRITE = WRITE;
    Reference.RW = RW;
    module2.exports = Reference;
  }
});

// node_modules/.pnpm/eslint-scope@5.1.1/node_modules/eslint-scope/lib/variable.js
var require_variable2 = __commonJS({
  "node_modules/.pnpm/eslint-scope@5.1.1/node_modules/eslint-scope/lib/variable.js"(exports, module2) {
    "use strict";
    var Variable = class {
      constructor(name, scope) {
        this.name = name;
        this.identifiers = [];
        this.references = [];
        this.defs = [];
        this.tainted = false;
        this.stack = true;
        this.scope = scope;
      }
    };
    Variable.CatchClause = "CatchClause";
    Variable.Parameter = "Parameter";
    Variable.FunctionName = "FunctionName";
    Variable.ClassName = "ClassName";
    Variable.Variable = "Variable";
    Variable.ImportBinding = "ImportBinding";
    Variable.ImplicitGlobalVariable = "ImplicitGlobalVariable";
    module2.exports = Variable;
  }
});

// node_modules/.pnpm/eslint-scope@5.1.1/node_modules/eslint-scope/lib/definition.js
var require_definition2 = __commonJS({
  "node_modules/.pnpm/eslint-scope@5.1.1/node_modules/eslint-scope/lib/definition.js"(exports, module2) {
    "use strict";
    var Variable = require_variable2();
    var Definition = class {
      constructor(type, name, node, parent, index, kind) {
        this.type = type;
        this.name = name;
        this.node = node;
        this.parent = parent;
        this.index = index;
        this.kind = kind;
      }
    };
    var ParameterDefinition = class extends Definition {
      constructor(name, node, index, rest) {
        super(Variable.Parameter, name, node, null, index, null);
        this.rest = rest;
      }
    };
    module2.exports = {
      ParameterDefinition,
      Definition
    };
  }
});

// node_modules/.pnpm/eslint-scope@5.1.1/node_modules/eslint-scope/lib/scope.js
var require_scope2 = __commonJS({
  "node_modules/.pnpm/eslint-scope@5.1.1/node_modules/eslint-scope/lib/scope.js"(exports, module2) {
    "use strict";
    var Syntax = require_estraverse().Syntax;
    var Reference = require_reference();
    var Variable = require_variable2();
    var Definition = require_definition2().Definition;
    var assert = require("assert");
    function isStrictScope(scope, block, isMethodDefinition, useDirective) {
      let body;
      if (scope.upper && scope.upper.isStrict) {
        return true;
      }
      if (isMethodDefinition) {
        return true;
      }
      if (scope.type === "class" || scope.type === "module") {
        return true;
      }
      if (scope.type === "block" || scope.type === "switch") {
        return false;
      }
      if (scope.type === "function") {
        if (block.type === Syntax.ArrowFunctionExpression && block.body.type !== Syntax.BlockStatement) {
          return false;
        }
        if (block.type === Syntax.Program) {
          body = block;
        } else {
          body = block.body;
        }
        if (!body) {
          return false;
        }
      } else if (scope.type === "global") {
        body = block;
      } else {
        return false;
      }
      if (useDirective) {
        for (let i = 0, iz = body.body.length; i < iz; ++i) {
          const stmt = body.body[i];
          if (stmt.type !== Syntax.DirectiveStatement) {
            break;
          }
          if (stmt.raw === '"use strict"' || stmt.raw === "'use strict'") {
            return true;
          }
        }
      } else {
        for (let i = 0, iz = body.body.length; i < iz; ++i) {
          const stmt = body.body[i];
          if (stmt.type !== Syntax.ExpressionStatement) {
            break;
          }
          const expr = stmt.expression;
          if (expr.type !== Syntax.Literal || typeof expr.value !== "string") {
            break;
          }
          if (expr.raw !== null && expr.raw !== void 0) {
            if (expr.raw === '"use strict"' || expr.raw === "'use strict'") {
              return true;
            }
          } else {
            if (expr.value === "use strict") {
              return true;
            }
          }
        }
      }
      return false;
    }
    function registerScope(scopeManager, scope) {
      scopeManager.scopes.push(scope);
      const scopes = scopeManager.__nodeToScope.get(scope.block);
      if (scopes) {
        scopes.push(scope);
      } else {
        scopeManager.__nodeToScope.set(scope.block, [scope]);
      }
    }
    function shouldBeStatically(def) {
      return def.type === Variable.ClassName || def.type === Variable.Variable && def.parent.kind !== "var";
    }
    var Scope = class {
      constructor(scopeManager, type, upperScope, block, isMethodDefinition) {
        this.type = type;
        this.set = /* @__PURE__ */ new Map();
        this.taints = /* @__PURE__ */ new Map();
        this.dynamic = this.type === "global" || this.type === "with";
        this.block = block;
        this.through = [];
        this.variables = [];
        this.references = [];
        this.variableScope = this.type === "global" || this.type === "function" || this.type === "module" ? this : upperScope.variableScope;
        this.functionExpressionScope = false;
        this.directCallToEvalScope = false;
        this.thisFound = false;
        this.__left = [];
        this.upper = upperScope;
        this.isStrict = isStrictScope(this, block, isMethodDefinition, scopeManager.__useDirective());
        this.childScopes = [];
        if (this.upper) {
          this.upper.childScopes.push(this);
        }
        this.__declaredVariables = scopeManager.__declaredVariables;
        registerScope(scopeManager, this);
      }
      __shouldStaticallyClose(scopeManager) {
        return !this.dynamic || scopeManager.__isOptimistic();
      }
      __shouldStaticallyCloseForGlobal(ref) {
        const name = ref.identifier.name;
        if (!this.set.has(name)) {
          return false;
        }
        const variable = this.set.get(name);
        const defs = variable.defs;
        return defs.length > 0 && defs.every(shouldBeStatically);
      }
      __staticCloseRef(ref) {
        if (!this.__resolve(ref)) {
          this.__delegateToUpperScope(ref);
        }
      }
      __dynamicCloseRef(ref) {
        let current = this;
        do {
          current.through.push(ref);
          current = current.upper;
        } while (current);
      }
      __globalCloseRef(ref) {
        if (this.__shouldStaticallyCloseForGlobal(ref)) {
          this.__staticCloseRef(ref);
        } else {
          this.__dynamicCloseRef(ref);
        }
      }
      __close(scopeManager) {
        let closeRef;
        if (this.__shouldStaticallyClose(scopeManager)) {
          closeRef = this.__staticCloseRef;
        } else if (this.type !== "global") {
          closeRef = this.__dynamicCloseRef;
        } else {
          closeRef = this.__globalCloseRef;
        }
        for (let i = 0, iz = this.__left.length; i < iz; ++i) {
          const ref = this.__left[i];
          closeRef.call(this, ref);
        }
        this.__left = null;
        return this.upper;
      }
      // To override by function scopes.
      // References in default parameters isn't resolved to variables which are in their function body.
      __isValidResolution(ref, variable) {
        return true;
      }
      __resolve(ref) {
        const name = ref.identifier.name;
        if (!this.set.has(name)) {
          return false;
        }
        const variable = this.set.get(name);
        if (!this.__isValidResolution(ref, variable)) {
          return false;
        }
        variable.references.push(ref);
        variable.stack = variable.stack && ref.from.variableScope === this.variableScope;
        if (ref.tainted) {
          variable.tainted = true;
          this.taints.set(variable.name, true);
        }
        ref.resolved = variable;
        return true;
      }
      __delegateToUpperScope(ref) {
        if (this.upper) {
          this.upper.__left.push(ref);
        }
        this.through.push(ref);
      }
      __addDeclaredVariablesOfNode(variable, node) {
        if (node === null || node === void 0) {
          return;
        }
        let variables = this.__declaredVariables.get(node);
        if (variables === null || variables === void 0) {
          variables = [];
          this.__declaredVariables.set(node, variables);
        }
        if (variables.indexOf(variable) === -1) {
          variables.push(variable);
        }
      }
      __defineGeneric(name, set, variables, node, def) {
        let variable;
        variable = set.get(name);
        if (!variable) {
          variable = new Variable(name, this);
          set.set(name, variable);
          variables.push(variable);
        }
        if (def) {
          variable.defs.push(def);
          this.__addDeclaredVariablesOfNode(variable, def.node);
          this.__addDeclaredVariablesOfNode(variable, def.parent);
        }
        if (node) {
          variable.identifiers.push(node);
        }
      }
      __define(node, def) {
        if (node && node.type === Syntax.Identifier) {
          this.__defineGeneric(
            node.name,
            this.set,
            this.variables,
            node,
            def
          );
        }
      }
      __referencing(node, assign, writeExpr, maybeImplicitGlobal, partial, init) {
        if (!node || node.type !== Syntax.Identifier) {
          return;
        }
        if (node.name === "super") {
          return;
        }
        const ref = new Reference(node, this, assign || Reference.READ, writeExpr, maybeImplicitGlobal, !!partial, !!init);
        this.references.push(ref);
        this.__left.push(ref);
      }
      __detectEval() {
        let current = this;
        this.directCallToEvalScope = true;
        do {
          current.dynamic = true;
          current = current.upper;
        } while (current);
      }
      __detectThis() {
        this.thisFound = true;
      }
      __isClosed() {
        return this.__left === null;
      }
      /**
       * returns resolved {Reference}
       * @method Scope#resolve
       * @param {Espree.Identifier} ident - identifier to be resolved.
       * @returns {Reference} reference
       */
      resolve(ident) {
        let ref, i, iz;
        assert(this.__isClosed(), "Scope should be closed.");
        assert(ident.type === Syntax.Identifier, "Target should be identifier.");
        for (i = 0, iz = this.references.length; i < iz; ++i) {
          ref = this.references[i];
          if (ref.identifier === ident) {
            return ref;
          }
        }
        return null;
      }
      /**
       * returns this scope is static
       * @method Scope#isStatic
       * @returns {boolean} static
       */
      isStatic() {
        return !this.dynamic;
      }
      /**
       * returns this scope has materialized arguments
       * @method Scope#isArgumentsMaterialized
       * @returns {boolean} arguemnts materialized
       */
      isArgumentsMaterialized() {
        return true;
      }
      /**
       * returns this scope has materialized `this` reference
       * @method Scope#isThisMaterialized
       * @returns {boolean} this materialized
       */
      isThisMaterialized() {
        return true;
      }
      isUsedName(name) {
        if (this.set.has(name)) {
          return true;
        }
        for (let i = 0, iz = this.through.length; i < iz; ++i) {
          if (this.through[i].identifier.name === name) {
            return true;
          }
        }
        return false;
      }
    };
    var GlobalScope = class extends Scope {
      constructor(scopeManager, block) {
        super(scopeManager, "global", null, block, false);
        this.implicit = {
          set: /* @__PURE__ */ new Map(),
          variables: [],
          /**
          * List of {@link Reference}s that are left to be resolved (i.e. which
          * need to be linked to the variable they refer to).
          * @member {Reference[]} Scope#implicit#left
          */
          left: []
        };
      }
      __close(scopeManager) {
        const implicit = [];
        for (let i = 0, iz = this.__left.length; i < iz; ++i) {
          const ref = this.__left[i];
          if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {
            implicit.push(ref.__maybeImplicitGlobal);
          }
        }
        for (let i = 0, iz = implicit.length; i < iz; ++i) {
          const info = implicit[i];
          this.__defineImplicit(
            info.pattern,
            new Definition(
              Variable.ImplicitGlobalVariable,
              info.pattern,
              info.node,
              null,
              null,
              null
            )
          );
        }
        this.implicit.left = this.__left;
        return super.__close(scopeManager);
      }
      __defineImplicit(node, def) {
        if (node && node.type === Syntax.Identifier) {
          this.__defineGeneric(
            node.name,
            this.implicit.set,
            this.implicit.variables,
            node,
            def
          );
        }
      }
    };
    var ModuleScope = class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "module", upperScope, block, false);
      }
    };
    var FunctionExpressionNameScope = class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "function-expression-name", upperScope, block, false);
        this.__define(
          block.id,
          new Definition(
            Variable.FunctionName,
            block.id,
            block,
            null,
            null,
            null
          )
        );
        this.functionExpressionScope = true;
      }
    };
    var CatchScope = class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "catch", upperScope, block, false);
      }
    };
    var WithScope = class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "with", upperScope, block, false);
      }
      __close(scopeManager) {
        if (this.__shouldStaticallyClose(scopeManager)) {
          return super.__close(scopeManager);
        }
        for (let i = 0, iz = this.__left.length; i < iz; ++i) {
          const ref = this.__left[i];
          ref.tainted = true;
          this.__delegateToUpperScope(ref);
        }
        this.__left = null;
        return this.upper;
      }
    };
    var BlockScope = class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "block", upperScope, block, false);
      }
    };
    var SwitchScope = class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "switch", upperScope, block, false);
      }
    };
    var FunctionScope = class extends Scope {
      constructor(scopeManager, upperScope, block, isMethodDefinition) {
        super(scopeManager, "function", upperScope, block, isMethodDefinition);
        if (this.block.type !== Syntax.ArrowFunctionExpression) {
          this.__defineArguments();
        }
      }
      isArgumentsMaterialized() {
        if (this.block.type === Syntax.ArrowFunctionExpression) {
          return false;
        }
        if (!this.isStatic()) {
          return true;
        }
        const variable = this.set.get("arguments");
        assert(variable, "Always have arguments variable.");
        return variable.tainted || variable.references.length !== 0;
      }
      isThisMaterialized() {
        if (!this.isStatic()) {
          return true;
        }
        return this.thisFound;
      }
      __defineArguments() {
        this.__defineGeneric(
          "arguments",
          this.set,
          this.variables,
          null,
          null
        );
        this.taints.set("arguments", true);
      }
      // References in default parameters isn't resolved to variables which are in their function body.
      //     const x = 1
      //     function f(a = x) { // This `x` is resolved to the `x` in the outer scope.
      //         const x = 2
      //         console.log(a)
      //     }
      __isValidResolution(ref, variable) {
        if (this.block.type === "Program") {
          return true;
        }
        const bodyStart = this.block.body.range[0];
        return !(variable.scope === this && ref.identifier.range[0] < bodyStart && // the reference is in the parameter part.
        variable.defs.every((d) => d.name.range[0] >= bodyStart));
      }
    };
    var ForScope = class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "for", upperScope, block, false);
      }
    };
    var ClassScope = class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "class", upperScope, block, false);
      }
    };
    module2.exports = {
      Scope,
      GlobalScope,
      ModuleScope,
      FunctionExpressionNameScope,
      CatchScope,
      WithScope,
      BlockScope,
      SwitchScope,
      FunctionScope,
      ForScope,
      ClassScope
    };
  }
});

// node_modules/.pnpm/eslint-scope@5.1.1/node_modules/eslint-scope/lib/scope-manager.js
var require_scope_manager = __commonJS({
  "node_modules/.pnpm/eslint-scope@5.1.1/node_modules/eslint-scope/lib/scope-manager.js"(exports, module2) {
    "use strict";
    var Scope = require_scope2();
    var assert = require("assert");
    var GlobalScope = Scope.GlobalScope;
    var CatchScope = Scope.CatchScope;
    var WithScope = Scope.WithScope;
    var ModuleScope = Scope.ModuleScope;
    var ClassScope = Scope.ClassScope;
    var SwitchScope = Scope.SwitchScope;
    var FunctionScope = Scope.FunctionScope;
    var ForScope = Scope.ForScope;
    var FunctionExpressionNameScope = Scope.FunctionExpressionNameScope;
    var BlockScope = Scope.BlockScope;
    var ScopeManager = class {
      constructor(options) {
        this.scopes = [];
        this.globalScope = null;
        this.__nodeToScope = /* @__PURE__ */ new WeakMap();
        this.__currentScope = null;
        this.__options = options;
        this.__declaredVariables = /* @__PURE__ */ new WeakMap();
      }
      __useDirective() {
        return this.__options.directive;
      }
      __isOptimistic() {
        return this.__options.optimistic;
      }
      __ignoreEval() {
        return this.__options.ignoreEval;
      }
      __isNodejsScope() {
        return this.__options.nodejsScope;
      }
      isModule() {
        return this.__options.sourceType === "module";
      }
      isImpliedStrict() {
        return this.__options.impliedStrict;
      }
      isStrictModeSupported() {
        return this.__options.ecmaVersion >= 5;
      }
      // Returns appropriate scope for this node.
      __get(node) {
        return this.__nodeToScope.get(node);
      }
      /**
       * Get variables that are declared by the node.
       *
       * "are declared by the node" means the node is same as `Variable.defs[].node` or `Variable.defs[].parent`.
       * If the node declares nothing, this method returns an empty array.
       * CAUTION: This API is experimental. See https://github.com/estools/escope/pull/69 for more details.
       *
       * @param {Espree.Node} node - a node to get.
       * @returns {Variable[]} variables that declared by the node.
       */
      getDeclaredVariables(node) {
        return this.__declaredVariables.get(node) || [];
      }
      /**
       * acquire scope from node.
       * @method ScopeManager#acquire
       * @param {Espree.Node} node - node for the acquired scope.
       * @param {boolean=} inner - look up the most inner scope, default value is false.
       * @returns {Scope?} Scope from node
       */
      acquire(node, inner) {
        function predicate(testScope) {
          if (testScope.type === "function" && testScope.functionExpressionScope) {
            return false;
          }
          return true;
        }
        const scopes = this.__get(node);
        if (!scopes || scopes.length === 0) {
          return null;
        }
        if (scopes.length === 1) {
          return scopes[0];
        }
        if (inner) {
          for (let i = scopes.length - 1; i >= 0; --i) {
            const scope = scopes[i];
            if (predicate(scope)) {
              return scope;
            }
          }
        } else {
          for (let i = 0, iz = scopes.length; i < iz; ++i) {
            const scope = scopes[i];
            if (predicate(scope)) {
              return scope;
            }
          }
        }
        return null;
      }
      /**
       * acquire all scopes from node.
       * @method ScopeManager#acquireAll
       * @param {Espree.Node} node - node for the acquired scope.
       * @returns {Scopes?} Scope array
       */
      acquireAll(node) {
        return this.__get(node);
      }
      /**
       * release the node.
       * @method ScopeManager#release
       * @param {Espree.Node} node - releasing node.
       * @param {boolean=} inner - look up the most inner scope, default value is false.
       * @returns {Scope?} upper scope for the node.
       */
      release(node, inner) {
        const scopes = this.__get(node);
        if (scopes && scopes.length) {
          const scope = scopes[0].upper;
          if (!scope) {
            return null;
          }
          return this.acquire(scope.block, inner);
        }
        return null;
      }
      attach() {
      }
      // eslint-disable-line class-methods-use-this
      detach() {
      }
      // eslint-disable-line class-methods-use-this
      __nestScope(scope) {
        if (scope instanceof GlobalScope) {
          assert(this.__currentScope === null);
          this.globalScope = scope;
        }
        this.__currentScope = scope;
        return scope;
      }
      __nestGlobalScope(node) {
        return this.__nestScope(new GlobalScope(this, node));
      }
      __nestBlockScope(node) {
        return this.__nestScope(new BlockScope(this, this.__currentScope, node));
      }
      __nestFunctionScope(node, isMethodDefinition) {
        return this.__nestScope(new FunctionScope(this, this.__currentScope, node, isMethodDefinition));
      }
      __nestForScope(node) {
        return this.__nestScope(new ForScope(this, this.__currentScope, node));
      }
      __nestCatchScope(node) {
        return this.__nestScope(new CatchScope(this, this.__currentScope, node));
      }
      __nestWithScope(node) {
        return this.__nestScope(new WithScope(this, this.__currentScope, node));
      }
      __nestClassScope(node) {
        return this.__nestScope(new ClassScope(this, this.__currentScope, node));
      }
      __nestSwitchScope(node) {
        return this.__nestScope(new SwitchScope(this, this.__currentScope, node));
      }
      __nestModuleScope(node) {
        return this.__nestScope(new ModuleScope(this, this.__currentScope, node));
      }
      __nestFunctionExpressionNameScope(node) {
        return this.__nestScope(new FunctionExpressionNameScope(this, this.__currentScope, node));
      }
      __isES6() {
        return this.__options.ecmaVersion >= 6;
      }
    };
    module2.exports = ScopeManager;
  }
});

// node_modules/.pnpm/estraverse@5.3.0/node_modules/estraverse/estraverse.js
var require_estraverse2 = __commonJS({
  "node_modules/.pnpm/estraverse@5.3.0/node_modules/estraverse/estraverse.js"(exports) {
    (function clone(exports2) {
      "use strict";
      var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;
      function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            val = obj[key];
            if (typeof val === "object" && val !== null) {
              ret[key] = deepCopy(val);
            } else {
              ret[key] = val;
            }
          }
        }
        return ret;
      }
      function upperBound(array, func) {
        var diff, len, i, current;
        len = array.length;
        i = 0;
        while (len) {
          diff = len >>> 1;
          current = i + diff;
          if (func(array[current])) {
            len = diff;
          } else {
            i = current + 1;
            len -= diff + 1;
          }
        }
        return i;
      }
      Syntax = {
        AssignmentExpression: "AssignmentExpression",
        AssignmentPattern: "AssignmentPattern",
        ArrayExpression: "ArrayExpression",
        ArrayPattern: "ArrayPattern",
        ArrowFunctionExpression: "ArrowFunctionExpression",
        AwaitExpression: "AwaitExpression",
        // CAUTION: It's deferred to ES7.
        BlockStatement: "BlockStatement",
        BinaryExpression: "BinaryExpression",
        BreakStatement: "BreakStatement",
        CallExpression: "CallExpression",
        CatchClause: "CatchClause",
        ChainExpression: "ChainExpression",
        ClassBody: "ClassBody",
        ClassDeclaration: "ClassDeclaration",
        ClassExpression: "ClassExpression",
        ComprehensionBlock: "ComprehensionBlock",
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: "ComprehensionExpression",
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: "ConditionalExpression",
        ContinueStatement: "ContinueStatement",
        DebuggerStatement: "DebuggerStatement",
        DirectiveStatement: "DirectiveStatement",
        DoWhileStatement: "DoWhileStatement",
        EmptyStatement: "EmptyStatement",
        ExportAllDeclaration: "ExportAllDeclaration",
        ExportDefaultDeclaration: "ExportDefaultDeclaration",
        ExportNamedDeclaration: "ExportNamedDeclaration",
        ExportSpecifier: "ExportSpecifier",
        ExpressionStatement: "ExpressionStatement",
        ForStatement: "ForStatement",
        ForInStatement: "ForInStatement",
        ForOfStatement: "ForOfStatement",
        FunctionDeclaration: "FunctionDeclaration",
        FunctionExpression: "FunctionExpression",
        GeneratorExpression: "GeneratorExpression",
        // CAUTION: It's deferred to ES7.
        Identifier: "Identifier",
        IfStatement: "IfStatement",
        ImportExpression: "ImportExpression",
        ImportDeclaration: "ImportDeclaration",
        ImportDefaultSpecifier: "ImportDefaultSpecifier",
        ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
        ImportSpecifier: "ImportSpecifier",
        Literal: "Literal",
        LabeledStatement: "LabeledStatement",
        LogicalExpression: "LogicalExpression",
        MemberExpression: "MemberExpression",
        MetaProperty: "MetaProperty",
        MethodDefinition: "MethodDefinition",
        ModuleSpecifier: "ModuleSpecifier",
        NewExpression: "NewExpression",
        ObjectExpression: "ObjectExpression",
        ObjectPattern: "ObjectPattern",
        PrivateIdentifier: "PrivateIdentifier",
        Program: "Program",
        Property: "Property",
        PropertyDefinition: "PropertyDefinition",
        RestElement: "RestElement",
        ReturnStatement: "ReturnStatement",
        SequenceExpression: "SequenceExpression",
        SpreadElement: "SpreadElement",
        Super: "Super",
        SwitchStatement: "SwitchStatement",
        SwitchCase: "SwitchCase",
        TaggedTemplateExpression: "TaggedTemplateExpression",
        TemplateElement: "TemplateElement",
        TemplateLiteral: "TemplateLiteral",
        ThisExpression: "ThisExpression",
        ThrowStatement: "ThrowStatement",
        TryStatement: "TryStatement",
        UnaryExpression: "UnaryExpression",
        UpdateExpression: "UpdateExpression",
        VariableDeclaration: "VariableDeclaration",
        VariableDeclarator: "VariableDeclarator",
        WhileStatement: "WhileStatement",
        WithStatement: "WithStatement",
        YieldExpression: "YieldExpression"
      };
      VisitorKeys = {
        AssignmentExpression: ["left", "right"],
        AssignmentPattern: ["left", "right"],
        ArrayExpression: ["elements"],
        ArrayPattern: ["elements"],
        ArrowFunctionExpression: ["params", "body"],
        AwaitExpression: ["argument"],
        // CAUTION: It's deferred to ES7.
        BlockStatement: ["body"],
        BinaryExpression: ["left", "right"],
        BreakStatement: ["label"],
        CallExpression: ["callee", "arguments"],
        CatchClause: ["param", "body"],
        ChainExpression: ["expression"],
        ClassBody: ["body"],
        ClassDeclaration: ["id", "superClass", "body"],
        ClassExpression: ["id", "superClass", "body"],
        ComprehensionBlock: ["left", "right"],
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: ["test", "consequent", "alternate"],
        ContinueStatement: ["label"],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ["body", "test"],
        EmptyStatement: [],
        ExportAllDeclaration: ["source"],
        ExportDefaultDeclaration: ["declaration"],
        ExportNamedDeclaration: ["declaration", "specifiers", "source"],
        ExportSpecifier: ["exported", "local"],
        ExpressionStatement: ["expression"],
        ForStatement: ["init", "test", "update", "body"],
        ForInStatement: ["left", "right", "body"],
        ForOfStatement: ["left", "right", "body"],
        FunctionDeclaration: ["id", "params", "body"],
        FunctionExpression: ["id", "params", "body"],
        GeneratorExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ["test", "consequent", "alternate"],
        ImportExpression: ["source"],
        ImportDeclaration: ["specifiers", "source"],
        ImportDefaultSpecifier: ["local"],
        ImportNamespaceSpecifier: ["local"],
        ImportSpecifier: ["imported", "local"],
        Literal: [],
        LabeledStatement: ["label", "body"],
        LogicalExpression: ["left", "right"],
        MemberExpression: ["object", "property"],
        MetaProperty: ["meta", "property"],
        MethodDefinition: ["key", "value"],
        ModuleSpecifier: [],
        NewExpression: ["callee", "arguments"],
        ObjectExpression: ["properties"],
        ObjectPattern: ["properties"],
        PrivateIdentifier: [],
        Program: ["body"],
        Property: ["key", "value"],
        PropertyDefinition: ["key", "value"],
        RestElement: ["argument"],
        ReturnStatement: ["argument"],
        SequenceExpression: ["expressions"],
        SpreadElement: ["argument"],
        Super: [],
        SwitchStatement: ["discriminant", "cases"],
        SwitchCase: ["test", "consequent"],
        TaggedTemplateExpression: ["tag", "quasi"],
        TemplateElement: [],
        TemplateLiteral: ["quasis", "expressions"],
        ThisExpression: [],
        ThrowStatement: ["argument"],
        TryStatement: ["block", "handler", "finalizer"],
        UnaryExpression: ["argument"],
        UpdateExpression: ["argument"],
        VariableDeclaration: ["declarations"],
        VariableDeclarator: ["id", "init"],
        WhileStatement: ["test", "body"],
        WithStatement: ["object", "body"],
        YieldExpression: ["argument"]
      };
      BREAK = {};
      SKIP = {};
      REMOVE = {};
      VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
      };
      function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
      }
      Reference.prototype.replace = function replace2(node) {
        this.parent[this.key] = node;
      };
      Reference.prototype.remove = function remove() {
        if (Array.isArray(this.parent)) {
          this.parent.splice(this.key, 1);
          return true;
        } else {
          this.replace(null);
          return false;
        }
      };
      function Element(node, path6, wrap, ref) {
        this.node = node;
        this.path = path6;
        this.wrap = wrap;
        this.ref = ref;
      }
      function Controller() {
      }
      Controller.prototype.path = function path6() {
        var i, iz, j, jz, result, element;
        function addToPath(result2, path7) {
          if (Array.isArray(path7)) {
            for (j = 0, jz = path7.length; j < jz; ++j) {
              result2.push(path7[j]);
            }
          } else {
            result2.push(path7);
          }
        }
        if (!this.__current.path) {
          return null;
        }
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
          element = this.__leavelist[i];
          addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
      };
      Controller.prototype.type = function() {
        var node = this.current();
        return node.type || this.__current.wrap;
      };
      Controller.prototype.parents = function parents() {
        var i, iz, result;
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
          result.push(this.__leavelist[i].node);
        }
        return result;
      };
      Controller.prototype.current = function current() {
        return this.__current.node;
      };
      Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;
        result = void 0;
        previous = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
          result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;
        return result;
      };
      Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
      };
      Controller.prototype.skip = function() {
        this.notify(SKIP);
      };
      Controller.prototype["break"] = function() {
        this.notify(BREAK);
      };
      Controller.prototype.remove = function() {
        this.notify(REMOVE);
      };
      Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = null;
        if (visitor.fallback === "iteration") {
          this.__fallback = Object.keys;
        } else if (typeof visitor.fallback === "function") {
          this.__fallback = visitor.fallback;
        }
        this.__keys = VisitorKeys;
        if (visitor.keys) {
          this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
        }
      };
      function isNode(node) {
        if (node == null) {
          return false;
        }
        return typeof node === "object" && typeof node.type === "string";
      }
      function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && "properties" === key;
      }
      function candidateExistsInLeaveList(leavelist, candidate) {
        for (var i = leavelist.length - 1; i >= 0; --i) {
          if (leavelist[i].node === candidate) {
            return true;
          }
        }
        return false;
      }
      Controller.prototype.traverse = function traverse2(root, visitor) {
        var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            ret = this.__execute(visitor.leave, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            continue;
          }
          if (element.node) {
            ret = this.__execute(visitor.enter, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            worklist.push(sentinel);
            leavelist.push(element);
            if (this.__state === SKIP || ret === SKIP) {
              continue;
            }
            node = element.node;
            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
              if (this.__fallback) {
                candidates = this.__fallback(node);
              } else {
                throw new Error("Unknown node type " + nodeType + ".");
              }
            }
            current = candidates.length;
            while ((current -= 1) >= 0) {
              key = candidates[current];
              candidate = node[key];
              if (!candidate) {
                continue;
              }
              if (Array.isArray(candidate)) {
                current2 = candidate.length;
                while ((current2 -= 1) >= 0) {
                  if (!candidate[current2]) {
                    continue;
                  }
                  if (candidateExistsInLeaveList(leavelist, candidate[current2])) {
                    continue;
                  }
                  if (isProperty(nodeType, candidates[current])) {
                    element = new Element(candidate[current2], [key, current2], "Property", null);
                  } else if (isNode(candidate[current2])) {
                    element = new Element(candidate[current2], [key, current2], null, null);
                  } else {
                    continue;
                  }
                  worklist.push(element);
                }
              } else if (isNode(candidate)) {
                if (candidateExistsInLeaveList(leavelist, candidate)) {
                  continue;
                }
                worklist.push(new Element(candidate, key, null, null));
              }
            }
          }
        }
      };
      Controller.prototype.replace = function replace2(root, visitor) {
        var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
        function removeElem(element2) {
          var i, key2, nextElem, parent;
          if (element2.ref.remove()) {
            key2 = element2.ref.key;
            parent = element2.ref.parent;
            i = worklist.length;
            while (i--) {
              nextElem = worklist[i];
              if (nextElem.ref && nextElem.ref.parent === parent) {
                if (nextElem.ref.key < key2) {
                  break;
                }
                --nextElem.ref.key;
              }
            }
          }
        }
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        outer = {
          root
        };
        element = new Element(root, null, null, new Reference(outer, "root"));
        worklist.push(element);
        leavelist.push(element);
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            target = this.__execute(visitor.leave, element);
            if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
              element.ref.replace(target);
            }
            if (this.__state === REMOVE || target === REMOVE) {
              removeElem(element);
            }
            if (this.__state === BREAK || target === BREAK) {
              return outer.root;
            }
            continue;
          }
          target = this.__execute(visitor.enter, element);
          if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
            element.ref.replace(target);
            element.node = target;
          }
          if (this.__state === REMOVE || target === REMOVE) {
            removeElem(element);
            element.node = null;
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          node = element.node;
          if (!node) {
            continue;
          }
          worklist.push(sentinel);
          leavelist.push(element);
          if (this.__state === SKIP || target === SKIP) {
            continue;
          }
          nodeType = node.type || element.wrap;
          candidates = this.__keys[nodeType];
          if (!candidates) {
            if (this.__fallback) {
              candidates = this.__fallback(node);
            } else {
              throw new Error("Unknown node type " + nodeType + ".");
            }
          }
          current = candidates.length;
          while ((current -= 1) >= 0) {
            key = candidates[current];
            candidate = node[key];
            if (!candidate) {
              continue;
            }
            if (Array.isArray(candidate)) {
              current2 = candidate.length;
              while ((current2 -= 1) >= 0) {
                if (!candidate[current2]) {
                  continue;
                }
                if (isProperty(nodeType, candidates[current])) {
                  element = new Element(candidate[current2], [key, current2], "Property", new Reference(candidate, current2));
                } else if (isNode(candidate[current2])) {
                  element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                } else {
                  continue;
                }
                worklist.push(element);
              }
            } else if (isNode(candidate)) {
              worklist.push(new Element(candidate, key, null, new Reference(node, key)));
            }
          }
        }
        return outer.root;
      };
      function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
      }
      function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
      }
      function extendCommentRange(comment, tokens) {
        var target;
        target = upperBound(tokens, function search(token) {
          return token.range[0] > comment.range[0];
        });
        comment.extendedRange = [comment.range[0], comment.range[1]];
        if (target !== tokens.length) {
          comment.extendedRange[1] = tokens[target].range[0];
        }
        target -= 1;
        if (target >= 0) {
          comment.extendedRange[0] = tokens[target].range[1];
        }
        return comment;
      }
      function attachComments(tree, providedComments, tokens) {
        var comments = [], comment, len, i, cursor;
        if (!tree.range) {
          throw new Error("attachComments needs range information");
        }
        if (!tokens.length) {
          if (providedComments.length) {
            for (i = 0, len = providedComments.length; i < len; i += 1) {
              comment = deepCopy(providedComments[i]);
              comment.extendedRange = [0, tree.range[0]];
              comments.push(comment);
            }
            tree.leadingComments = comments;
          }
          return tree;
        }
        for (i = 0, len = providedComments.length; i < len; i += 1) {
          comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }
        cursor = 0;
        traverse(tree, {
          enter: function(node) {
            var comment2;
            while (cursor < comments.length) {
              comment2 = comments[cursor];
              if (comment2.extendedRange[1] > node.range[0]) {
                break;
              }
              if (comment2.extendedRange[1] === node.range[0]) {
                if (!node.leadingComments) {
                  node.leadingComments = [];
                }
                node.leadingComments.push(comment2);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        cursor = 0;
        traverse(tree, {
          leave: function(node) {
            var comment2;
            while (cursor < comments.length) {
              comment2 = comments[cursor];
              if (node.range[1] < comment2.extendedRange[0]) {
                break;
              }
              if (node.range[1] === comment2.extendedRange[0]) {
                if (!node.trailingComments) {
                  node.trailingComments = [];
                }
                node.trailingComments.push(comment2);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        return tree;
      }
      exports2.Syntax = Syntax;
      exports2.traverse = traverse;
      exports2.replace = replace;
      exports2.attachComments = attachComments;
      exports2.VisitorKeys = VisitorKeys;
      exports2.VisitorOption = VisitorOption;
      exports2.Controller = Controller;
      exports2.cloneEnvironment = function() {
        return clone({});
      };
      return exports2;
    })(exports);
  }
});

// node_modules/.pnpm/esrecurse@4.3.0/node_modules/esrecurse/package.json
var require_package3 = __commonJS({
  "node_modules/.pnpm/esrecurse@4.3.0/node_modules/esrecurse/package.json"(exports, module2) {
    module2.exports = {
      name: "esrecurse",
      description: "ECMAScript AST recursive visitor",
      homepage: "https://github.com/estools/esrecurse",
      main: "esrecurse.js",
      version: "4.3.0",
      engines: {
        node: ">=4.0"
      },
      maintainers: [
        {
          name: "Yusuke Suzuki",
          email: "utatane.tea@gmail.com",
          web: "https://github.com/Constellation"
        }
      ],
      repository: {
        type: "git",
        url: "https://github.com/estools/esrecurse.git"
      },
      dependencies: {
        estraverse: "^5.2.0"
      },
      devDependencies: {
        "babel-cli": "^6.24.1",
        "babel-eslint": "^7.2.3",
        "babel-preset-es2015": "^6.24.1",
        "babel-register": "^6.24.1",
        chai: "^4.0.2",
        esprima: "^4.0.0",
        gulp: "^3.9.0",
        "gulp-bump": "^2.7.0",
        "gulp-eslint": "^4.0.0",
        "gulp-filter": "^5.0.0",
        "gulp-git": "^2.4.1",
        "gulp-mocha": "^4.3.1",
        "gulp-tag-version": "^1.2.1",
        jsdoc: "^3.3.0-alpha10",
        minimist: "^1.1.0"
      },
      license: "BSD-2-Clause",
      scripts: {
        test: "gulp travis",
        "unit-test": "gulp test",
        lint: "gulp lint"
      },
      babel: {
        presets: [
          "es2015"
        ]
      }
    };
  }
});

// node_modules/.pnpm/esrecurse@4.3.0/node_modules/esrecurse/esrecurse.js
var require_esrecurse = __commonJS({
  "node_modules/.pnpm/esrecurse@4.3.0/node_modules/esrecurse/esrecurse.js"(exports) {
    (function() {
      "use strict";
      var estraverse = require_estraverse2();
      function isNode(node) {
        if (node == null) {
          return false;
        }
        return typeof node === "object" && typeof node.type === "string";
      }
      function isProperty(nodeType, key) {
        return (nodeType === estraverse.Syntax.ObjectExpression || nodeType === estraverse.Syntax.ObjectPattern) && key === "properties";
      }
      function Visitor(visitor, options) {
        options = options || {};
        this.__visitor = visitor || this;
        this.__childVisitorKeys = options.childVisitorKeys ? Object.assign({}, estraverse.VisitorKeys, options.childVisitorKeys) : estraverse.VisitorKeys;
        if (options.fallback === "iteration") {
          this.__fallback = Object.keys;
        } else if (typeof options.fallback === "function") {
          this.__fallback = options.fallback;
        }
      }
      Visitor.prototype.visitChildren = function(node) {
        var type, children, i, iz, j, jz, child;
        if (node == null) {
          return;
        }
        type = node.type || estraverse.Syntax.Property;
        children = this.__childVisitorKeys[type];
        if (!children) {
          if (this.__fallback) {
            children = this.__fallback(node);
          } else {
            throw new Error("Unknown node type " + type + ".");
          }
        }
        for (i = 0, iz = children.length; i < iz; ++i) {
          child = node[children[i]];
          if (child) {
            if (Array.isArray(child)) {
              for (j = 0, jz = child.length; j < jz; ++j) {
                if (child[j]) {
                  if (isNode(child[j]) || isProperty(type, children[i])) {
                    this.visit(child[j]);
                  }
                }
              }
            } else if (isNode(child)) {
              this.visit(child);
            }
          }
        }
      };
      Visitor.prototype.visit = function(node) {
        var type;
        if (node == null) {
          return;
        }
        type = node.type || estraverse.Syntax.Property;
        if (this.__visitor[type]) {
          this.__visitor[type].call(this, node);
          return;
        }
        this.visitChildren(node);
      };
      exports.version = require_package3().version;
      exports.Visitor = Visitor;
      exports.visit = function(node, visitor, options) {
        var v = new Visitor(visitor, options);
        v.visit(node);
      };
    })();
  }
});

// node_modules/.pnpm/eslint-scope@5.1.1/node_modules/eslint-scope/lib/pattern-visitor.js
var require_pattern_visitor = __commonJS({
  "node_modules/.pnpm/eslint-scope@5.1.1/node_modules/eslint-scope/lib/pattern-visitor.js"(exports, module2) {
    "use strict";
    var Syntax = require_estraverse().Syntax;
    var esrecurse = require_esrecurse();
    function getLast(xs) {
      return xs[xs.length - 1] || null;
    }
    var PatternVisitor = class extends esrecurse.Visitor {
      static isPattern(node) {
        const nodeType = node.type;
        return nodeType === Syntax.Identifier || nodeType === Syntax.ObjectPattern || nodeType === Syntax.ArrayPattern || nodeType === Syntax.SpreadElement || nodeType === Syntax.RestElement || nodeType === Syntax.AssignmentPattern;
      }
      constructor(options, rootPattern, callback) {
        super(null, options);
        this.rootPattern = rootPattern;
        this.callback = callback;
        this.assignments = [];
        this.rightHandNodes = [];
        this.restElements = [];
      }
      Identifier(pattern) {
        const lastRestElement = getLast(this.restElements);
        this.callback(pattern, {
          topLevel: pattern === this.rootPattern,
          rest: lastRestElement !== null && lastRestElement !== void 0 && lastRestElement.argument === pattern,
          assignments: this.assignments
        });
      }
      Property(property) {
        if (property.computed) {
          this.rightHandNodes.push(property.key);
        }
        this.visit(property.value);
      }
      ArrayPattern(pattern) {
        for (let i = 0, iz = pattern.elements.length; i < iz; ++i) {
          const element = pattern.elements[i];
          this.visit(element);
        }
      }
      AssignmentPattern(pattern) {
        this.assignments.push(pattern);
        this.visit(pattern.left);
        this.rightHandNodes.push(pattern.right);
        this.assignments.pop();
      }
      RestElement(pattern) {
        this.restElements.push(pattern);
        this.visit(pattern.argument);
        this.restElements.pop();
      }
      MemberExpression(node) {
        if (node.computed) {
          this.rightHandNodes.push(node.property);
        }
        this.rightHandNodes.push(node.object);
      }
      //
      // ForInStatement.left and AssignmentExpression.left are LeftHandSideExpression.
      // By spec, LeftHandSideExpression is Pattern or MemberExpression.
      //   (see also: https://github.com/estree/estree/pull/20#issuecomment-74584758)
      // But espree 2.0 parses to ArrayExpression, ObjectExpression, etc...
      //
      SpreadElement(node) {
        this.visit(node.argument);
      }
      ArrayExpression(node) {
        node.elements.forEach(this.visit, this);
      }
      AssignmentExpression(node) {
        this.assignments.push(node);
        this.visit(node.left);
        this.rightHandNodes.push(node.right);
        this.assignments.pop();
      }
      CallExpression(node) {
        node.arguments.forEach((a) => {
          this.rightHandNodes.push(a);
        });
        this.visit(node.callee);
      }
    };
    module2.exports = PatternVisitor;
  }
});

// node_modules/.pnpm/eslint-scope@5.1.1/node_modules/eslint-scope/lib/referencer.js
var require_referencer2 = __commonJS({
  "node_modules/.pnpm/eslint-scope@5.1.1/node_modules/eslint-scope/lib/referencer.js"(exports, module2) {
    "use strict";
    var Syntax = require_estraverse().Syntax;
    var esrecurse = require_esrecurse();
    var Reference = require_reference();
    var Variable = require_variable2();
    var PatternVisitor = require_pattern_visitor();
    var definition = require_definition2();
    var assert = require("assert");
    var ParameterDefinition = definition.ParameterDefinition;
    var Definition = definition.Definition;
    function traverseIdentifierInPattern(options, rootPattern, referencer, callback) {
      const visitor = new PatternVisitor(options, rootPattern, callback);
      visitor.visit(rootPattern);
      if (referencer !== null && referencer !== void 0) {
        visitor.rightHandNodes.forEach(referencer.visit, referencer);
      }
    }
    var Importer = class extends esrecurse.Visitor {
      constructor(declaration, referencer) {
        super(null, referencer.options);
        this.declaration = declaration;
        this.referencer = referencer;
      }
      visitImport(id, specifier) {
        this.referencer.visitPattern(id, (pattern) => {
          this.referencer.currentScope().__define(
            pattern,
            new Definition(
              Variable.ImportBinding,
              pattern,
              specifier,
              this.declaration,
              null,
              null
            )
          );
        });
      }
      ImportNamespaceSpecifier(node) {
        const local = node.local || node.id;
        if (local) {
          this.visitImport(local, node);
        }
      }
      ImportDefaultSpecifier(node) {
        const local = node.local || node.id;
        this.visitImport(local, node);
      }
      ImportSpecifier(node) {
        const local = node.local || node.id;
        if (node.name) {
          this.visitImport(node.name, node);
        } else {
          this.visitImport(local, node);
        }
      }
    };
    var Referencer = class extends esrecurse.Visitor {
      constructor(options, scopeManager) {
        super(null, options);
        this.options = options;
        this.scopeManager = scopeManager;
        this.parent = null;
        this.isInnerMethodDefinition = false;
      }
      currentScope() {
        return this.scopeManager.__currentScope;
      }
      close(node) {
        while (this.currentScope() && node === this.currentScope().block) {
          this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);
        }
      }
      pushInnerMethodDefinition(isInnerMethodDefinition) {
        const previous = this.isInnerMethodDefinition;
        this.isInnerMethodDefinition = isInnerMethodDefinition;
        return previous;
      }
      popInnerMethodDefinition(isInnerMethodDefinition) {
        this.isInnerMethodDefinition = isInnerMethodDefinition;
      }
      referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {
        const scope = this.currentScope();
        assignments.forEach((assignment) => {
          scope.__referencing(
            pattern,
            Reference.WRITE,
            assignment.right,
            maybeImplicitGlobal,
            pattern !== assignment.left,
            init
          );
        });
      }
      visitPattern(node, options, callback) {
        let visitPatternOptions = options;
        let visitPatternCallback = callback;
        if (typeof options === "function") {
          visitPatternCallback = options;
          visitPatternOptions = { processRightHandNodes: false };
        }
        traverseIdentifierInPattern(
          this.options,
          node,
          visitPatternOptions.processRightHandNodes ? this : null,
          visitPatternCallback
        );
      }
      visitFunction(node) {
        let i, iz;
        if (node.type === Syntax.FunctionDeclaration) {
          this.currentScope().__define(
            node.id,
            new Definition(
              Variable.FunctionName,
              node.id,
              node,
              null,
              null,
              null
            )
          );
        }
        if (node.type === Syntax.FunctionExpression && node.id) {
          this.scopeManager.__nestFunctionExpressionNameScope(node);
        }
        this.scopeManager.__nestFunctionScope(node, this.isInnerMethodDefinition);
        const that = this;
        function visitPatternCallback(pattern, info) {
          that.currentScope().__define(
            pattern,
            new ParameterDefinition(
              pattern,
              node,
              i,
              info.rest
            )
          );
          that.referencingDefaultValue(pattern, info.assignments, null, true);
        }
        for (i = 0, iz = node.params.length; i < iz; ++i) {
          this.visitPattern(node.params[i], { processRightHandNodes: true }, visitPatternCallback);
        }
        if (node.rest) {
          this.visitPattern({
            type: "RestElement",
            argument: node.rest
          }, (pattern) => {
            this.currentScope().__define(
              pattern,
              new ParameterDefinition(
                pattern,
                node,
                node.params.length,
                true
              )
            );
          });
        }
        if (node.body) {
          if (node.body.type === Syntax.BlockStatement) {
            this.visitChildren(node.body);
          } else {
            this.visit(node.body);
          }
        }
        this.close(node);
      }
      visitClass(node) {
        if (node.type === Syntax.ClassDeclaration) {
          this.currentScope().__define(
            node.id,
            new Definition(
              Variable.ClassName,
              node.id,
              node,
              null,
              null,
              null
            )
          );
        }
        this.visit(node.superClass);
        this.scopeManager.__nestClassScope(node);
        if (node.id) {
          this.currentScope().__define(
            node.id,
            new Definition(
              Variable.ClassName,
              node.id,
              node
            )
          );
        }
        this.visit(node.body);
        this.close(node);
      }
      visitProperty(node) {
        let previous;
        if (node.computed) {
          this.visit(node.key);
        }
        const isMethodDefinition = node.type === Syntax.MethodDefinition;
        if (isMethodDefinition) {
          previous = this.pushInnerMethodDefinition(true);
        }
        this.visit(node.value);
        if (isMethodDefinition) {
          this.popInnerMethodDefinition(previous);
        }
      }
      visitForIn(node) {
        if (node.left.type === Syntax.VariableDeclaration && node.left.kind !== "var") {
          this.scopeManager.__nestForScope(node);
        }
        if (node.left.type === Syntax.VariableDeclaration) {
          this.visit(node.left);
          this.visitPattern(node.left.declarations[0].id, (pattern) => {
            this.currentScope().__referencing(pattern, Reference.WRITE, node.right, null, true, true);
          });
        } else {
          this.visitPattern(node.left, { processRightHandNodes: true }, (pattern, info) => {
            let maybeImplicitGlobal = null;
            if (!this.currentScope().isStrict) {
              maybeImplicitGlobal = {
                pattern,
                node
              };
            }
            this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
            this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, true, false);
          });
        }
        this.visit(node.right);
        this.visit(node.body);
        this.close(node);
      }
      visitVariableDeclaration(variableTargetScope, type, node, index) {
        const decl = node.declarations[index];
        const init = decl.init;
        this.visitPattern(decl.id, { processRightHandNodes: true }, (pattern, info) => {
          variableTargetScope.__define(
            pattern,
            new Definition(
              type,
              pattern,
              decl,
              node,
              index,
              node.kind
            )
          );
          this.referencingDefaultValue(pattern, info.assignments, null, true);
          if (init) {
            this.currentScope().__referencing(pattern, Reference.WRITE, init, null, !info.topLevel, true);
          }
        });
      }
      AssignmentExpression(node) {
        if (PatternVisitor.isPattern(node.left)) {
          if (node.operator === "=") {
            this.visitPattern(node.left, { processRightHandNodes: true }, (pattern, info) => {
              let maybeImplicitGlobal = null;
              if (!this.currentScope().isStrict) {
                maybeImplicitGlobal = {
                  pattern,
                  node
                };
              }
              this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
              this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, !info.topLevel, false);
            });
          } else {
            this.currentScope().__referencing(node.left, Reference.RW, node.right);
          }
        } else {
          this.visit(node.left);
        }
        this.visit(node.right);
      }
      CatchClause(node) {
        this.scopeManager.__nestCatchScope(node);
        this.visitPattern(node.param, { processRightHandNodes: true }, (pattern, info) => {
          this.currentScope().__define(
            pattern,
            new Definition(
              Variable.CatchClause,
              node.param,
              node,
              null,
              null,
              null
            )
          );
          this.referencingDefaultValue(pattern, info.assignments, null, true);
        });
        this.visit(node.body);
        this.close(node);
      }
      Program(node) {
        this.scopeManager.__nestGlobalScope(node);
        if (this.scopeManager.__isNodejsScope()) {
          this.currentScope().isStrict = false;
          this.scopeManager.__nestFunctionScope(node, false);
        }
        if (this.scopeManager.__isES6() && this.scopeManager.isModule()) {
          this.scopeManager.__nestModuleScope(node);
        }
        if (this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict()) {
          this.currentScope().isStrict = true;
        }
        this.visitChildren(node);
        this.close(node);
      }
      Identifier(node) {
        this.currentScope().__referencing(node);
      }
      UpdateExpression(node) {
        if (PatternVisitor.isPattern(node.argument)) {
          this.currentScope().__referencing(node.argument, Reference.RW, null);
        } else {
          this.visitChildren(node);
        }
      }
      MemberExpression(node) {
        this.visit(node.object);
        if (node.computed) {
          this.visit(node.property);
        }
      }
      Property(node) {
        this.visitProperty(node);
      }
      MethodDefinition(node) {
        this.visitProperty(node);
      }
      BreakStatement() {
      }
      // eslint-disable-line class-methods-use-this
      ContinueStatement() {
      }
      // eslint-disable-line class-methods-use-this
      LabeledStatement(node) {
        this.visit(node.body);
      }
      ForStatement(node) {
        if (node.init && node.init.type === Syntax.VariableDeclaration && node.init.kind !== "var") {
          this.scopeManager.__nestForScope(node);
        }
        this.visitChildren(node);
        this.close(node);
      }
      ClassExpression(node) {
        this.visitClass(node);
      }
      ClassDeclaration(node) {
        this.visitClass(node);
      }
      CallExpression(node) {
        if (!this.scopeManager.__ignoreEval() && node.callee.type === Syntax.Identifier && node.callee.name === "eval") {
          this.currentScope().variableScope.__detectEval();
        }
        this.visitChildren(node);
      }
      BlockStatement(node) {
        if (this.scopeManager.__isES6()) {
          this.scopeManager.__nestBlockScope(node);
        }
        this.visitChildren(node);
        this.close(node);
      }
      ThisExpression() {
        this.currentScope().variableScope.__detectThis();
      }
      WithStatement(node) {
        this.visit(node.object);
        this.scopeManager.__nestWithScope(node);
        this.visit(node.body);
        this.close(node);
      }
      VariableDeclaration(node) {
        const variableTargetScope = node.kind === "var" ? this.currentScope().variableScope : this.currentScope();
        for (let i = 0, iz = node.declarations.length; i < iz; ++i) {
          const decl = node.declarations[i];
          this.visitVariableDeclaration(variableTargetScope, Variable.Variable, node, i);
          if (decl.init) {
            this.visit(decl.init);
          }
        }
      }
      // sec 13.11.8
      SwitchStatement(node) {
        this.visit(node.discriminant);
        if (this.scopeManager.__isES6()) {
          this.scopeManager.__nestSwitchScope(node);
        }
        for (let i = 0, iz = node.cases.length; i < iz; ++i) {
          this.visit(node.cases[i]);
        }
        this.close(node);
      }
      FunctionDeclaration(node) {
        this.visitFunction(node);
      }
      FunctionExpression(node) {
        this.visitFunction(node);
      }
      ForOfStatement(node) {
        this.visitForIn(node);
      }
      ForInStatement(node) {
        this.visitForIn(node);
      }
      ArrowFunctionExpression(node) {
        this.visitFunction(node);
      }
      ImportDeclaration(node) {
        assert(this.scopeManager.__isES6() && this.scopeManager.isModule(), "ImportDeclaration should appear when the mode is ES6 and in the module context.");
        const importer = new Importer(node, this);
        importer.visit(node);
      }
      visitExportDeclaration(node) {
        if (node.source) {
          return;
        }
        if (node.declaration) {
          this.visit(node.declaration);
          return;
        }
        this.visitChildren(node);
      }
      // TODO: ExportDeclaration doesn't exist. for bc?
      ExportDeclaration(node) {
        this.visitExportDeclaration(node);
      }
      ExportAllDeclaration(node) {
        this.visitExportDeclaration(node);
      }
      ExportDefaultDeclaration(node) {
        this.visitExportDeclaration(node);
      }
      ExportNamedDeclaration(node) {
        this.visitExportDeclaration(node);
      }
      ExportSpecifier(node) {
        const local = node.id || node.local;
        this.visit(local);
      }
      MetaProperty() {
      }
    };
    module2.exports = Referencer;
  }
});

// node_modules/.pnpm/eslint-scope@5.1.1/node_modules/eslint-scope/package.json
var require_package4 = __commonJS({
  "node_modules/.pnpm/eslint-scope@5.1.1/node_modules/eslint-scope/package.json"(exports, module2) {
    module2.exports = {
      name: "eslint-scope",
      description: "ECMAScript scope analyzer for ESLint",
      homepage: "http://github.com/eslint/eslint-scope",
      main: "lib/index.js",
      version: "5.1.1",
      engines: {
        node: ">=8.0.0"
      },
      repository: "eslint/eslint-scope",
      bugs: {
        url: "https://github.com/eslint/eslint-scope/issues"
      },
      license: "BSD-2-Clause",
      scripts: {
        test: "node Makefile.js test",
        lint: "node Makefile.js lint",
        "generate-release": "eslint-generate-release",
        "generate-alpharelease": "eslint-generate-prerelease alpha",
        "generate-betarelease": "eslint-generate-prerelease beta",
        "generate-rcrelease": "eslint-generate-prerelease rc",
        "publish-release": "eslint-publish-release"
      },
      files: [
        "LICENSE",
        "README.md",
        "lib"
      ],
      dependencies: {
        esrecurse: "^4.3.0",
        estraverse: "^4.1.1"
      },
      devDependencies: {
        "@typescript-eslint/parser": "^1.11.0",
        chai: "^4.2.0",
        eslint: "^6.0.1",
        "eslint-config-eslint": "^5.0.1",
        "eslint-plugin-node": "^9.1.0",
        "eslint-release": "^1.0.0",
        "eslint-visitor-keys": "^1.2.0",
        espree: "^7.1.0",
        istanbul: "^0.4.5",
        mocha: "^6.1.4",
        "npm-license": "^0.3.3",
        shelljs: "^0.8.3",
        typescript: "^3.5.2"
      }
    };
  }
});

// node_modules/.pnpm/eslint-scope@5.1.1/node_modules/eslint-scope/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/.pnpm/eslint-scope@5.1.1/node_modules/eslint-scope/lib/index.js"(exports, module2) {
    "use strict";
    var assert = require("assert");
    var ScopeManager = require_scope_manager();
    var Referencer = require_referencer2();
    var Reference = require_reference();
    var Variable = require_variable2();
    var Scope = require_scope2().Scope;
    var version = require_package4().version;
    function defaultOptions() {
      return {
        optimistic: false,
        directive: false,
        nodejsScope: false,
        impliedStrict: false,
        sourceType: "script",
        // one of ['script', 'module']
        ecmaVersion: 5,
        childVisitorKeys: null,
        fallback: "iteration"
      };
    }
    function updateDeeply(target, override) {
      function isHashObject(value) {
        return typeof value === "object" && value instanceof Object && !(value instanceof Array) && !(value instanceof RegExp);
      }
      for (const key in override) {
        if (Object.prototype.hasOwnProperty.call(override, key)) {
          const val = override[key];
          if (isHashObject(val)) {
            if (isHashObject(target[key])) {
              updateDeeply(target[key], val);
            } else {
              target[key] = updateDeeply({}, val);
            }
          } else {
            target[key] = val;
          }
        }
      }
      return target;
    }
    function analyze(tree, providedOptions) {
      const options = updateDeeply(defaultOptions(), providedOptions);
      const scopeManager = new ScopeManager(options);
      const referencer = new Referencer(options, scopeManager);
      referencer.visit(tree);
      assert(scopeManager.__currentScope === null, "currentScope should be null.");
      return scopeManager;
    }
    module2.exports = {
      /** @name module:escope.version */
      version,
      /** @name module:escope.Reference */
      Reference,
      /** @name module:escope.Variable */
      Variable,
      /** @name module:escope.Scope */
      Scope,
      /** @name module:escope.ScopeManager */
      ScopeManager,
      analyze
    };
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint-scope/analyze.js
var require_analyze2 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint-scope/analyze.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.analyze = void 0;
    var eslint_scope_1 = require_lib4();
    var analyze = eslint_scope_1.analyze;
    exports.analyze = analyze;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint-scope/Definition.js
var require_Definition2 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint-scope/Definition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParameterDefinition = exports.Definition = void 0;
    var definition_1 = require_definition2();
    var Definition = definition_1.Definition;
    exports.Definition = Definition;
    var ParameterDefinition = definition_1.ParameterDefinition;
    exports.ParameterDefinition = ParameterDefinition;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint-scope/Options.js
var require_Options = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint-scope/Options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint-scope/PatternVisitor.js
var require_PatternVisitor2 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint-scope/PatternVisitor.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PatternVisitor = void 0;
    var pattern_visitor_1 = __importDefault2(require_pattern_visitor());
    var PatternVisitor = pattern_visitor_1.default;
    exports.PatternVisitor = PatternVisitor;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint-scope/Reference.js
var require_Reference2 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint-scope/Reference.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Reference = void 0;
    var reference_1 = __importDefault2(require_reference());
    var Reference = reference_1.default;
    exports.Reference = Reference;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint-scope/Referencer.js
var require_Referencer2 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint-scope/Referencer.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Referencer = void 0;
    var referencer_1 = __importDefault2(require_referencer2());
    var Referencer = referencer_1.default;
    exports.Referencer = Referencer;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint-scope/Scope.js
var require_Scope3 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint-scope/Scope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClassScope = exports.ForScope = exports.FunctionScope = exports.SwitchScope = exports.BlockScope = exports.WithScope = exports.CatchScope = exports.FunctionExpressionNameScope = exports.ModuleScope = exports.GlobalScope = exports.Scope = void 0;
    var scope_1 = require_scope2();
    var Scope = scope_1.Scope;
    exports.Scope = Scope;
    var GlobalScope = scope_1.GlobalScope;
    exports.GlobalScope = GlobalScope;
    var ModuleScope = scope_1.ModuleScope;
    exports.ModuleScope = ModuleScope;
    var FunctionExpressionNameScope = scope_1.FunctionExpressionNameScope;
    exports.FunctionExpressionNameScope = FunctionExpressionNameScope;
    var CatchScope = scope_1.CatchScope;
    exports.CatchScope = CatchScope;
    var WithScope = scope_1.WithScope;
    exports.WithScope = WithScope;
    var BlockScope = scope_1.BlockScope;
    exports.BlockScope = BlockScope;
    var SwitchScope = scope_1.SwitchScope;
    exports.SwitchScope = SwitchScope;
    var FunctionScope = scope_1.FunctionScope;
    exports.FunctionScope = FunctionScope;
    var ForScope = scope_1.ForScope;
    exports.ForScope = ForScope;
    var ClassScope = scope_1.ClassScope;
    exports.ClassScope = ClassScope;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint-scope/ScopeManager.js
var require_ScopeManager2 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint-scope/ScopeManager.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScopeManager = void 0;
    var scope_manager_1 = __importDefault2(require_scope_manager());
    var ScopeManager = scope_manager_1.default;
    exports.ScopeManager = ScopeManager;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint-scope/Variable.js
var require_Variable2 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint-scope/Variable.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Variable = void 0;
    var variable_1 = __importDefault2(require_variable2());
    var Variable = variable_1.default;
    exports.Variable = Variable;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint-scope/index.js
var require_ts_eslint_scope = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/ts-eslint-scope/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding2(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    var eslint_scope_1 = require_lib4();
    __exportStar2(require_analyze2(), exports);
    __exportStar2(require_Definition2(), exports);
    __exportStar2(require_Options(), exports);
    __exportStar2(require_PatternVisitor2(), exports);
    __exportStar2(require_Reference2(), exports);
    __exportStar2(require_Referencer2(), exports);
    __exportStar2(require_Scope3(), exports);
    __exportStar2(require_ScopeManager2(), exports);
    __exportStar2(require_Variable2(), exports);
    exports.version = eslint_scope_1.version;
  }
});

// node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/.pnpm/@typescript-eslint+utils@5.59.2_eslint@8.40.0_typescript@4.9.4/node_modules/@typescript-eslint/utils/dist/index.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar2 = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding2(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TSESLintScope = exports.TSESLint = exports.JSONSchema = exports.ESLintUtils = exports.ASTUtils = void 0;
    var ASTUtils = __importStar2(require_ast_utils());
    exports.ASTUtils = ASTUtils;
    var ESLintUtils2 = __importStar2(require_eslint_utils3());
    exports.ESLintUtils = ESLintUtils2;
    var JSONSchema = __importStar2(require_json_schema());
    exports.JSONSchema = JSONSchema;
    var TSESLint = __importStar2(require_ts_eslint());
    exports.TSESLint = TSESLint;
    var TSESLintScope = __importStar2(require_ts_eslint_scope());
    exports.TSESLintScope = TSESLintScope;
    __exportStar2(require_ts_estree3(), exports);
  }
});

// eslint-local-rules/index.ts
var eslint_local_rules_exports = {};
__export(eslint_local_rules_exports, {
  default: () => eslint_local_rules_default
});
module.exports = __toCommonJS(eslint_local_rules_exports);

// eslint-local-rules/rules/sql-check.rule.ts
var import_typescript_estree = __toESM(require_dist3());
var E5 = __toESM(require("fp-ts/Either"));
var import_function4 = require("fp-ts/function");
var import_path2 = __toESM(require("path"));
var import_register2 = require("source-map-support/register");

// node_modules/.pnpm/synckit@0.8.5/node_modules/synckit/lib/index.js
var import_node_fs2 = __toESM(require("fs"), 1);
var import_node_module2 = require("module");
var import_node_path2 = __toESM(require("path"), 1);
var import_node_url = require("url");
var import_node_worker_threads = require("worker_threads");

// node_modules/.pnpm/@pkgr+utils@2.4.0/node_modules/@pkgr/utils/lib/constants.js
var import_node_module = require("module");
var import_meta = {};
var _a;
var DEV = "development";
var NODE_ENV = (_a = process.env.NODE_ENV) !== null && _a !== void 0 ? _a : DEV;
var CWD = process.cwd();
var cjsRequire = typeof require === "undefined" ? (0, import_node_module.createRequire)(import_meta.url) : require;
var EXTENSIONS = [".ts", ".tsx", ...Object.keys(cjsRequire.extensions)];

// node_modules/.pnpm/@pkgr+utils@2.4.0/node_modules/@pkgr/utils/lib/helpers.js
var import_node_fs = __toESM(require("fs"), 1);
var import_node_path = __toESM(require("path"), 1);
var import_is_glob = __toESM(require_is_glob(), 1);
var tryPkg = (pkg) => {
  try {
    return cjsRequire.resolve(pkg);
  } catch (_a2) {
  }
};
var isPkgAvailable = (pkg) => !!tryPkg(pkg);
var isTsAvailable = isPkgAvailable("typescript");
var isAngularAvailable = isPkgAvailable("@angular/core/package.json");
var isMdxAvailable = isPkgAvailable("@mdx-js/mdx/package.json") || isPkgAvailable("@mdx-js/react/package.json");
var isReactAvailable = isPkgAvailable("react");
var isSvelteAvailable = isPkgAvailable("svelte");
var isVueAvailable = isPkgAvailable("vue");
var tryFile = (filePath, includeDir = false) => {
  if (typeof filePath === "string") {
    return import_node_fs.default.existsSync(filePath) && (includeDir || import_node_fs.default.statSync(filePath).isFile()) ? filePath : "";
  }
  for (const file of filePath !== null && filePath !== void 0 ? filePath : []) {
    if (tryFile(file, includeDir)) {
      return file;
    }
  }
  return "";
};
var tryExtensions = (filepath, extensions = EXTENSIONS) => {
  const ext = [...extensions, ""].find((ext2) => tryFile(filepath + ext2));
  return ext == null ? "" : filepath + ext;
};
var findUp = (searchEntry, searchFile = "package.json") => {
  console.assert(import_node_path.default.isAbsolute(searchEntry));
  if (!tryFile(searchEntry, true) || searchEntry !== CWD && !searchEntry.startsWith(CWD + import_node_path.default.sep)) {
    return "";
  }
  searchEntry = import_node_path.default.resolve(import_node_fs.default.statSync(searchEntry).isDirectory() ? searchEntry : import_node_path.default.resolve(searchEntry, ".."));
  do {
    const searched = tryFile(import_node_path.default.resolve(searchEntry, searchFile));
    if (searched) {
      return searched;
    }
    searchEntry = import_node_path.default.resolve(searchEntry, "..");
  } while (searchEntry === CWD || searchEntry.startsWith(CWD + import_node_path.default.sep));
  return "";
};

// node_modules/.pnpm/synckit@0.8.5/node_modules/synckit/lib/index.js
var import_meta2 = {};
var TsRunner = {
  TsNode: "ts-node",
  EsbuildRegister: "esbuild-register",
  EsbuildRunner: "esbuild-runner",
  SWC: "swc",
  TSX: "tsx"
};
var { SYNCKIT_BUFFER_SIZE, SYNCKIT_TIMEOUT, SYNCKIT_EXEC_ARGV, SYNCKIT_TS_RUNNER, NODE_OPTIONS } = process.env;
var DEFAULT_BUFFER_SIZE = SYNCKIT_BUFFER_SIZE ? +SYNCKIT_BUFFER_SIZE : void 0;
var DEFAULT_TIMEOUT = SYNCKIT_TIMEOUT ? +SYNCKIT_TIMEOUT : void 0;
var DEFAULT_WORKER_BUFFER_SIZE = DEFAULT_BUFFER_SIZE || 1024;
var DEFAULT_EXEC_ARGV = (SYNCKIT_EXEC_ARGV === null || SYNCKIT_EXEC_ARGV === void 0 ? void 0 : SYNCKIT_EXEC_ARGV.split(",")) || [];
var DEFAULT_TS_RUNNER = SYNCKIT_TS_RUNNER || TsRunner.TsNode;
var MTS_SUPPORTED_NODE_VERSION = 16;
var syncFnCache = /* @__PURE__ */ new Map();
function createSyncFn(workerPath2, bufferSizeOrOptions, timeout) {
  if (!import_node_path2.default.isAbsolute(workerPath2)) {
    throw new Error("`workerPath` must be absolute");
  }
  const cachedSyncFn = syncFnCache.get(workerPath2);
  if (cachedSyncFn) {
    return cachedSyncFn;
  }
  const syncFn = startWorkerThread(workerPath2, typeof bufferSizeOrOptions === "number" ? { bufferSize: bufferSizeOrOptions, timeout } : bufferSizeOrOptions);
  syncFnCache.set(workerPath2, syncFn);
  return syncFn;
}
var cjsRequire2 = typeof require === "undefined" ? (0, import_node_module2.createRequire)(import_meta2.url) : require;
var dataUrl = (code) => new URL(`data:text/javascript,${encodeURIComponent(code)}`);
var isFile = (path6) => {
  try {
    return import_node_fs2.default.statSync(path6).isFile();
  } catch (_a2) {
    return false;
  }
};
var setupTsRunner = (workerPath2, { execArgv, tsRunner }) => {
  let ext = import_node_path2.default.extname(workerPath2);
  if (!/[/\\]node_modules[/\\]/.test(workerPath2) && (!ext || /^\.[cm]?js$/.test(ext))) {
    const workPathWithoutExt = ext ? workerPath2.slice(0, -ext.length) : workerPath2;
    let extensions;
    switch (ext) {
      case ".cjs":
        extensions = [".cts", ".cjs"];
        break;
      case ".mjs":
        extensions = [".mts", ".mjs"];
        break;
      default:
        extensions = [".ts", ".js"];
        break;
    }
    const found = tryExtensions(workPathWithoutExt, extensions);
    let differentExt;
    if (found && (!ext || (differentExt = found !== workPathWithoutExt))) {
      workerPath2 = found;
      if (differentExt) {
        ext = import_node_path2.default.extname(workerPath2);
      }
    }
  }
  const isTs = /\.[cm]?ts$/.test(workerPath2);
  let tsUseEsm = workerPath2.endsWith(".mts");
  if (isTs) {
    if (!tsUseEsm) {
      const pkg = findUp(workerPath2);
      if (pkg) {
        tsUseEsm = cjsRequire2(pkg).type === "module";
      }
    }
    switch (tsRunner) {
      case TsRunner.TsNode: {
        if (tsUseEsm) {
          if (!execArgv.includes("--loader")) {
            execArgv = ["--loader", `${TsRunner.TsNode}/esm`, ...execArgv];
          }
        } else if (!execArgv.includes("-r")) {
          execArgv = ["-r", `${TsRunner.TsNode}/register`, ...execArgv];
        }
        break;
      }
      case TsRunner.EsbuildRegister: {
        if (!execArgv.includes("-r")) {
          execArgv = ["-r", TsRunner.EsbuildRegister, ...execArgv];
        }
        break;
      }
      case TsRunner.EsbuildRunner: {
        if (!execArgv.includes("-r")) {
          execArgv = ["-r", `${TsRunner.EsbuildRunner}/register`, ...execArgv];
        }
        break;
      }
      case TsRunner.SWC: {
        if (!execArgv.includes("-r")) {
          execArgv = ["-r", `@${TsRunner.SWC}-node/register`, ...execArgv];
        }
        break;
      }
      case TsRunner.TSX: {
        if (!execArgv.includes("--loader")) {
          execArgv = ["--loader", TsRunner.TSX, ...execArgv];
        }
        break;
      }
      default: {
        throw new Error(`Unknown ts runner: ${String(tsRunner)}`);
      }
    }
  }
  if (process.versions.pnp) {
    const nodeOptions = NODE_OPTIONS === null || NODE_OPTIONS === void 0 ? void 0 : NODE_OPTIONS.split(/\s+/);
    let pnpApiPath;
    try {
      pnpApiPath = cjsRequire2.resolve("pnpapi");
    } catch (_a2) {
    }
    if (pnpApiPath && !(nodeOptions === null || nodeOptions === void 0 ? void 0 : nodeOptions.some((option, index) => ["-r", "--require"].includes(option) && pnpApiPath === cjsRequire2.resolve(nodeOptions[index + 1]))) && !execArgv.includes(pnpApiPath)) {
      execArgv = ["-r", pnpApiPath, ...execArgv];
      const pnpLoaderPath = import_node_path2.default.resolve(pnpApiPath, "../.pnp.loader.mjs");
      if (isFile(pnpLoaderPath)) {
        const experimentalLoader = (0, import_node_url.pathToFileURL)(pnpLoaderPath).toString();
        execArgv = ["--experimental-loader", experimentalLoader, ...execArgv];
      }
    }
  }
  return {
    ext,
    isTs,
    tsUseEsm,
    workerPath: workerPath2,
    execArgv
  };
};
function startWorkerThread(workerPath2, { bufferSize = DEFAULT_WORKER_BUFFER_SIZE, timeout = DEFAULT_TIMEOUT, execArgv = DEFAULT_EXEC_ARGV, tsRunner = DEFAULT_TS_RUNNER } = {}) {
  const { port1: mainPort, port2: workerPort } = new import_node_worker_threads.MessageChannel();
  const { isTs, ext, tsUseEsm, workerPath: finalWorkerPath, execArgv: finalExecArgv } = setupTsRunner(workerPath2, { execArgv, tsRunner });
  const workerPathUrl = (0, import_node_url.pathToFileURL)(finalWorkerPath);
  if (/\.[cm]ts$/.test(finalWorkerPath)) {
    const isTsxSupported = !tsUseEsm || Number.parseFloat(process.versions.node) >= MTS_SUPPORTED_NODE_VERSION;
    if ([
      TsRunner.EsbuildRegister,
      TsRunner.EsbuildRunner,
      TsRunner.SWC,
      ...isTsxSupported ? [] : [TsRunner.TSX]
    ].includes(tsRunner)) {
      throw new Error(`${tsRunner} is not supported for ${ext} files yet` + (isTsxSupported ? ", you can try [tsx](https://github.com/esbuild-kit/tsx) instead" : ""));
    }
  }
  const useEval = isTs && !tsUseEsm;
  const worker = new import_node_worker_threads.Worker(tsUseEsm && tsRunner === TsRunner.TsNode ? dataUrl(`import '${String(workerPathUrl)}'`) : useEval ? `require('${finalWorkerPath.replace(/\\/g, "\\\\")}')` : workerPathUrl, {
    eval: useEval,
    workerData: { workerPort },
    transferList: [workerPort],
    execArgv: finalExecArgv
  });
  let nextID = 0;
  const syncFn = (...args) => {
    const id = nextID++;
    const sharedBuffer = new SharedArrayBuffer(bufferSize);
    const sharedBufferView = new Int32Array(sharedBuffer);
    const msg = { sharedBuffer, id, args };
    worker.postMessage(msg);
    const status = Atomics.wait(sharedBufferView, 0, 0, timeout);
    if (!["ok", "not-equal"].includes(status)) {
      throw new Error("Internal error: Atomics.wait() failed: " + status);
    }
    const { id: id2, result, error, properties } = (0, import_node_worker_threads.receiveMessageOnPort)(mainPort).message;
    if (id !== id2) {
      throw new Error(`Internal error: Expected id ${id} but got id ${id2}`);
    }
    if (error) {
      throw Object.assign(error, properties);
    }
    return result;
  };
  worker.unref();
  return syncFn;
}

// eslint-local-rules/rules/sql-check.rule.ts
var import_tiny_invariant2 = __toESM(require("tiny-invariant"));

// mfsqlchecker/ConfigFile.ts
var import_ajv = __toESM(require("ajv"));
var import_assert_never3 = require("assert-never");
var import_fs = __toESM(require("fs"));

// mfsqlchecker/queries.ts
var import_assert_never2 = require("assert-never");
var import_chalk2 = __toESM(require("chalk"));
var ts4 = __toESM(require("typescript"));

// mfsqlchecker/ErrorDiagnostic.ts
var import_chalk = __toESM(require("chalk"));
var ts = __toESM(require("typescript"));
function fileLineCol(fileContents, position) {
  let line = 1;
  let col = 1;
  for (let i = 0; i < position; ++i) {
    if (fileContents.codePointAt(i) === 10) {
      line++;
      col = 0;
    }
    col++;
  }
  return {
    type: "LineAndCol",
    line,
    col
  };
}
function toSrcSpan(fileContents, position) {
  return fileLineCol(fileContents, position - 1);
}
function postgresqlErrorDiagnostic(fileName, fileContents, err, span, message) {
  return {
    fileName,
    fileContents,
    span,
    messages: (message !== null ? [message] : []).concat([
      import_chalk.default.bold(err.message),
      import_chalk.default.bold("code:") + " " + err.code
    ]).concat(err.detail !== null && err.detail !== err.message ? import_chalk.default.bold("detail:") + " " + err.detail : []),
    epilogue: err.hint !== null ? import_chalk.default.bold("hint:") + " " + err.hint : null,
    quickFix: null
  };
}
function nodeErrorDiagnostic(node, message) {
  const sourceFile = node.getSourceFile();
  return {
    fileName: sourceFile.fileName,
    fileContents: sourceFile.text,
    span: nodeSourceSpan(node),
    messages: [import_chalk.default.bold(message)],
    epilogue: null,
    quickFix: null
  };
}
function nodeSourceSpan(node) {
  const sourceFile = node.getSourceFile();
  const pos = ts.getLineAndCharacterOfPosition(sourceFile, node.pos);
  const end = ts.getLineAndCharacterOfPosition(sourceFile, node.end);
  return {
    type: "LineAndColRange",
    startLine: pos.line + 1,
    startCol: pos.character + 1,
    endLine: end.line + 1,
    endCol: end.character + 1
  };
}

// mfsqlchecker/pg_extra.ts
var import_postgres = __toESM(require("postgres"));
function escapeIdentifier(str) {
  return '"' + str.replace(/"/g, '""') + '"';
}

// mfsqlchecker/views.ts
var import_assert_never = require("assert-never");
var path3 = __toESM(require("path"));
var ts3 = __toESM(require("typescript"));

// mfsqlchecker/ts_extra.ts
var ts2 = __toESM(require("typescript"));
var ModuleId = class {
  static wrap(moduleId) {
    return moduleId;
  }
  static unwrap(val) {
    return val;
  }
  _dummy;
};
function identifierImportedFrom(sourceFile, ident) {
  let moduleSpecifierText = null;
  let foundMultiple = false;
  ts2.forEachChild(sourceFile, (node) => {
    if (ts2.isImportDeclaration(node)) {
      if (node.importClause !== void 0 && node.importClause.namedBindings !== void 0) {
        if (ts2.isNamedImports(node.importClause.namedBindings)) {
          for (const elem of node.importClause.namedBindings.elements) {
            if (elem.name.text === ident.text) {
              if (moduleSpecifierText !== null) {
                foundMultiple = true;
              }
              moduleSpecifierText = node.moduleSpecifier.text;
            }
          }
        }
      }
    }
  });
  if (foundMultiple) {
    return null;
  } else {
    return moduleSpecifierText;
  }
}

// mfsqlchecker/view_names.ts
var crypto = __toESM(require("crypto"));
var POSTGRES_IDENT_MAX_LEN = 63;
function calcViewName(varName, query) {
  const hash = crypto.createHash("sha1").update(query).digest("hex");
  const prefix = "$$mfv_";
  if (varName === null) {
    return prefix + hash.slice(0, 12);
  }
  const overflow = prefix.length + varName.length + 1 + 12 - POSTGRES_IDENT_MAX_LEN;
  const varName2 = overflow > 0 ? varName.substr(0, varName.length - overflow) : varName;
  return prefix + varName2 + "_" + hash.slice(0, 12);
}

// mfsqlchecker/views.ts
var E = __toESM(require("fp-ts/Either"));
var import_function = require("fp-ts/function");
function viewNameLength(varName) {
  return escapeIdentifier(calcViewName(varName, "")).length;
}
function resolveViewIdentifier(projectDir, sourceFile, ident) {
  const importedFromModule = identifierImportedFrom(sourceFile, ident);
  if (importedFromModule !== null) {
    return QualifiedSqlViewName.create(importedModuleName(projectDir, sourceFile, importedFromModule), ident.text);
  } else {
    return QualifiedSqlViewName.create(sourceFileModuleName(projectDir, sourceFile), ident.text);
  }
}
var SqlViewDefinition = class {
  static parseFromTemplateExpression(projectDir, sourceFile, checker, varName, node) {
    if (ts3.isNoSubstitutionTemplateLiteral(node)) {
      const sourceMap = [[node.end - node.text.length, 0, node.text.length]];
      return {
        type: "Right",
        value: new SqlViewDefinition(sourceFile.fileName, sourceFile.text, varName, [{ type: "StringFragment", text: node.text }], sourceMap)
      };
    } else if (ts3.isTemplateExpression(node)) {
      const sourceMap = [];
      const fragments = [];
      fragments.push({ type: "StringFragment", text: node.head.text });
      let c = 0;
      sourceMap.push([node.head.end - node.head.text.length - 1, c, c + node.head.text.length]);
      c += node.head.text.length;
      for (let i = 0; i < node.templateSpans.length; ++i) {
        const span = node.templateSpans[i];
        const type = checker.getTypeAtLocation(span.expression);
        const maybeSqlFrag = tryTypeSqlFrag(type);
        switch (maybeSqlFrag.type) {
          case "Left":
            return {
              type: "Left",
              value: nodeErrorDiagnostic(span, maybeSqlFrag.value)
            };
          case "Right":
            if (maybeSqlFrag.value !== null) {
              fragments.push({ type: "StringFragment", text: maybeSqlFrag.value });
              c += maybeSqlFrag.value.length;
            } else {
              if (!ts3.isIdentifier(span.expression)) {
                return {
                  type: "Left",
                  value: nodeErrorDiagnostic(span, "defineSqlView template spans can only be identifiers (no other expressions allowed)")
                };
              }
              const qualifiedSqlViewName = resolveViewIdentifier(projectDir, sourceFile, span.expression);
              fragments.push({ type: "ViewReference", qualifiedSqlViewName });
              c += viewNameLength(span.expression.text);
            }
            break;
          default:
            (0, import_assert_never.assertNever)(maybeSqlFrag);
        }
        fragments.push({ type: "StringFragment", text: span.literal.text });
        sourceMap.push([
          span.literal.end - span.literal.text.length - (i < node.templateSpans.length - 1 ? 1 : 0),
          c,
          c + span.literal.text.length
        ]);
        c += span.literal.text.length;
      }
      return {
        type: "Right",
        value: new SqlViewDefinition(sourceFile.fileName, sourceFile.text, varName, fragments, sourceMap)
      };
    } else {
      return (0, import_assert_never.assertNever)(node);
    }
  }
  isFullyResolved() {
    for (const frag of this.fragments) {
      if (frag.type === "ViewReference") {
        return false;
      }
    }
    return true;
  }
  /**
   * Only call this if `isFullyResolved` returns true
   */
  fullyResolvedQuery() {
    let result = "";
    for (const frag of this.fragments) {
      if (frag.type === "ViewReference") {
        throw new Error(`SqlViewDefinition "${frag.qualifiedSqlViewName}" is not fully resolved`);
      }
      result += frag.text;
    }
    return result;
  }
  getDependencies() {
    return this.dependencies;
  }
  inject(dependency, viewName) {
    for (let i = 0; i < this.fragments.length; ++i) {
      const frag = this.fragments[i];
      if (frag.type === "ViewReference" && frag.qualifiedSqlViewName === dependency) {
        this.fragments[i] = { type: "StringFragment", text: escapeIdentifier(viewName) };
      }
    }
  }
  /**
   * Only call this if `isFullyResolved` returns true
   */
  getName() {
    if (this.viewName === null) {
      this.viewName = calcViewName(this.varName, this.fullyResolvedQuery());
    }
    return this.viewName;
  }
  getFileName() {
    return this.fileName;
  }
  getFileContents() {
    return this.fileContents;
  }
  getSourceMap() {
    return this.sourceMap;
  }
  /**
   * Call this if any of the dependencies have changed
   */
  resetToInitialFragments() {
    this.viewName = null;
    this.fragments = [...this.initialFragments];
  }
  isEqual(other) {
    if (this.initialFragments.length !== other.initialFragments.length) {
      return false;
    }
    for (let i = 0; i < this.initialFragments.length; ++i) {
      if (!SqlViewDefinition.fragmentsEqual(this.initialFragments[i], other.initialFragments[i])) {
        return false;
      }
    }
    return true;
  }
  debugDump() {
    return `${this.varName} ${JSON.stringify(this.dependencies)} ${JSON.stringify(this.fragments)}`;
  }
  constructor(fileName, fileContents, varName, fragments, sourceMap) {
    this.fileName = fileName;
    this.fileContents = fileContents;
    this.sourceMap = sourceMap;
    this.varName = varName;
    this.initialFragments = fragments;
    this.fragments = [...fragments];
    this.dependencies = [];
    for (let i = 0; i < fragments.length; ++i) {
      const frag = this.fragments[i];
      if (frag.type === "ViewReference") {
        this.dependencies.push(frag.qualifiedSqlViewName);
      }
    }
  }
  fileName;
  fileContents;
  sourceMap;
  varName;
  initialFragments;
  dependencies;
  // Mutable
  fragments;
  viewName = null;
  static fragmentsEqual(lhs, rhs) {
    switch (lhs.type) {
      case "StringFragment":
        return rhs.type === "StringFragment" && lhs.text === rhs.text;
      case "ViewReference":
        return rhs.type === "ViewReference" && lhs.qualifiedSqlViewName === rhs.qualifiedSqlViewName;
      default:
        return (0, import_assert_never.assertNever)(lhs);
    }
  }
};
function fullyResolveSqlViewDefinition(v, myName, library) {
  if (v.isFullyResolved()) {
    return [];
  }
  for (const depName of v.getDependencies()) {
    if (depName === myName) {
      return [{
        fileName: v.getFileName(),
        fileContents: v.getFileContents(),
        span: fileLineCol(v.getFileContents(), v.getSourceMap()[0][0]),
        messages: [`View depends on itself: "${QualifiedSqlViewName.viewName(myName)}"`],
        epilogue: null,
        quickFix: null
      }];
    }
    const dep = library.get(depName);
    if (dep === void 0) {
      return [{
        fileName: v.getFileName(),
        fileContents: v.getFileContents(),
        span: fileLineCol(v.getFileContents(), v.getSourceMap()[0][0]),
        messages: [`Missing dependency in view "${QualifiedSqlViewName.viewName(myName)}": "${QualifiedSqlViewName.viewName(depName)}" (from module "${QualifiedSqlViewName.moduleId(depName)}"`],
        epilogue: null,
        quickFix: null
      }];
    }
    if (!dep.isFullyResolved()) {
      fullyResolveSqlViewDefinition(dep, depName, library);
    }
    v.inject(depName, dep.getName());
  }
  return [];
}
function resolveAllViewDefinitions(library) {
  let errorDiagnostics = [];
  library.forEach((value, key) => {
    const errors = fullyResolveSqlViewDefinition(value, key, library);
    errorDiagnostics = errorDiagnostics.concat(errors);
  });
  const result = [];
  const added = /* @__PURE__ */ new Set();
  function addView(name, view) {
    if (added.has(name)) {
      return;
    }
    for (const depName of view.getDependencies()) {
      const dep = library.get(depName);
      if (dep === void 0) {
        throw new Error(`The Impossible happened: Missing dependency in view ${name}: ${depName}`);
      }
      addView(depName, dep);
    }
    result.push({
      qualifiedViewname: name,
      viewName: view.getName(),
      createQuery: view.fullyResolvedQuery(),
      fileName: view.getFileName(),
      fileContents: view.getFileContents(),
      sourceMap: view.getSourceMap()
    });
    added.add(name);
  }
  library.forEach((value, key) => {
    if (value.isFullyResolved()) {
      addView(key, value);
    }
  });
  return [result, errorDiagnostics];
}
var QualifiedSqlViewName = class {
  static create(moduleId, viewName) {
    return moduleId + " " + viewName;
  }
  static moduleId(val) {
    return val.split(" ")[0];
  }
  static viewName(val) {
    return val.split(" ")[1];
  }
  _dummy;
};
function sourceFileModuleName(projectDir, sourceFile) {
  const relFile = path3.relative(projectDir, sourceFile.fileName);
  const modName = relFile.slice(0, -3);
  return ModuleId.wrap(modName);
}
function importedModuleName(projectDir, sourceFile, importedModule) {
  return ModuleId.wrap(path3.join(path3.dirname(ModuleId.unwrap(sourceFileModuleName(projectDir, sourceFile))), importedModule));
}
function tryTypeSqlFrag(type) {
  const symbol = type.symbol;
  if (symbol === void 0) {
    return {
      type: "Right",
      value: null
    };
  }
  if (symbol.name === "SqlFrag") {
    const typeArguments = type.typeArguments;
    if (Array.isArray(typeArguments)) {
      if (typeArguments.length === 1) {
        if (typeArguments[0].flags === ts3.TypeFlags.String) {
          return {
            type: "Left",
            value: "Invalid call to `sqlFrag`: argument must be a String Literal (not a dynamic string)"
          };
        } else if (typeArguments[0].flags === ts3.TypeFlags.StringLiteral) {
          if (typeof typeArguments[0].value === "string") {
            return {
              type: "Right",
              value: typeArguments[0].value
            };
          }
        }
      }
    }
  }
  if (symbol.name === "SqlFragAuth") {
    const typeArguments = type.typeArguments;
    if (Array.isArray(typeArguments)) {
      if (typeArguments.length === 2) {
        if (typeArguments[0].flags === ts3.TypeFlags.String) {
          return {
            type: "Left",
            value: "Invalid call to `sqlFragAuth`: argument must be a String Literal (not a dynamic string)"
          };
        } else if (typeArguments[0].flags === ts3.TypeFlags.StringLiteral) {
          if (typeof typeArguments[0].value === "string") {
            return {
              type: "Right",
              value: typeArguments[0].value
            };
          }
        }
      }
    }
  }
  return {
    type: "Right",
    value: null
  };
}
function isSqlViewDefinition(checker, decl) {
  const name = checker.getTypeAtLocation(decl).symbol.name;
  return name === "SqlView";
}
function getSqlDefinitionE(params) {
  const { projectDir, sf, checker, node } = params;
  if (!ts3.isVariableStatement(node)) {
    return;
  }
  for (const decl of node.declarationList.declarations) {
    if (decl.initializer === void 0 || !ts3.isTaggedTemplateExpression(decl.initializer)) {
      return;
    }
    if (!ts3.isIdentifier(decl.initializer.tag) || !isSqlViewDefinition(checker, decl) || !ts3.isIdentifier(decl.name)) {
      return;
    }
    if ((node.declarationList.flags & ts3.NodeFlags.Const) === 0) {
      return E.left(nodeErrorDiagnostic(decl.name, "defineSqlView assigned to a non-const variable"));
    }
    const viewName = decl.name.text;
    const qualifiedSqlViewName = QualifiedSqlViewName.create(sourceFileModuleName(projectDir, sf), viewName);
    const sqlViewDefinition = SqlViewDefinition.parseFromTemplateExpression(projectDir, sf, checker, viewName, decl.initializer.template);
    switch (sqlViewDefinition.type) {
      case "Left":
        return E.left(sqlViewDefinition.value);
      case "Right":
        return E.right({
          viewName,
          qualifiedSqlViewName,
          sqlViewDefinition: sqlViewDefinition.value
        });
      default:
        (0, import_assert_never.assertNever)(sqlViewDefinition);
    }
  }
  return;
}
function sqlViewsLibraryAddFromSourceFile(projectDir, checker, sourceFile) {
  const viewLibrary = /* @__PURE__ */ new Map();
  const errorDiagnostics = [];
  function visit(sf, node) {
    const sqlDefinitionE = getSqlDefinitionE({ projectDir, sf, checker, node });
    if (sqlDefinitionE !== void 0) {
      (0, import_function.pipe)(
        sqlDefinitionE,
        E.match(
          (diagnostic) => {
            errorDiagnostics.push(diagnostic);
          },
          ({ sqlViewDefinition, qualifiedSqlViewName }) => {
            viewLibrary.set(qualifiedSqlViewName, sqlViewDefinition);
          }
        )
      );
    }
  }
  ts3.forEachChild(sourceFile, (node) => visit(sourceFile, node));
  return [viewLibrary, errorDiagnostics];
}
function sqlViewLibraryResetToInitialFragmentsIncludingDeps(viewName, viewLibrary) {
  const view = viewLibrary.get(viewName);
  if (view !== void 0) {
    view.resetToInitialFragments();
    viewLibrary.forEach((value, key) => {
      if (value.getDependencies().indexOf(viewName) >= 0) {
        if (key !== viewName) {
          sqlViewLibraryResetToInitialFragmentsIncludingDeps(key, viewLibrary);
        }
      }
    });
  }
}

// mfsqlchecker/queries.ts
function buildQueryFragments(sqlExp) {
  if (!ts4.isTaggedTemplateExpression(sqlExp)) {
    return {
      type: "Left",
      value: [
        nodeErrorDiagnostic(sqlExp, "Argument must be a Tagged Template Expression")
      ]
    };
  }
  if (ts4.isNoSubstitutionTemplateLiteral(sqlExp.template)) {
    return {
      type: "Right",
      value: [{
        type: "StringFragment",
        text: sqlExp.template.text,
        sourcePosStart: sqlExp.template.end - sqlExp.template.text.length
      }]
    };
  } else if (ts4.isTemplateExpression(sqlExp.template)) {
    const fragments = [];
    fragments.push({
      type: "StringFragment",
      text: sqlExp.template.head.text,
      sourcePosStart: sqlExp.template.head.end - sqlExp.template.head.text.length - 1
    });
    for (let i = 0; i < sqlExp.template.templateSpans.length; ++i) {
      const span = sqlExp.template.templateSpans[i];
      fragments.push({ type: "Expression", exp: span.expression });
      fragments.push({
        type: "StringFragment",
        text: span.literal.text,
        sourcePosStart: span.literal.end - span.literal.text.length - (i < sqlExp.template.templateSpans.length - 1 ? 1 : 0)
        // The end of the last template span is different from the others
      });
    }
    return {
      type: "Right",
      value: fragments
    };
  } else {
    return (0, import_assert_never2.assertNever)(sqlExp.template);
  }
}
function nodeLineAndColSpan(sourceFile, node) {
  const start = sourceFile.getLineAndCharacterOfPosition(node.pos);
  const end = sourceFile.getLineAndCharacterOfPosition(node.end);
  return {
    type: "LineAndColRange",
    startLine: start.line + 1,
    startCol: start.character + 1,
    endLine: end.line + 1,
    endCol: end.character + 1
  };
}
function buildTypeArgumentData(sourceFile, node) {
  if (node.typeArguments === void 0 || node.typeArguments.length === 0) {
    return [null, nodeLineAndColSpan(sourceFile, node.expression.name)];
  } else {
    const start = sourceFile.getLineAndCharacterOfPosition(node.expression.end);
    const end = sourceFile.getLineAndCharacterOfPosition(node.arguments.pos - 1);
    const span = {
      type: "LineAndColRange",
      startLine: start.line + 1,
      startCol: start.character + 1,
      endLine: end.line + 1,
      endCol: end.character + 1
    };
    return [node.typeArguments[0], span];
  }
}
function getIndentLevel(sourceFile, node) {
  const sourceFileText = sourceFile.getFullText();
  const nlPos = sourceFileText.lastIndexOf("\n", node.pos);
  const lineText = sourceFileText.substring(nlPos + 1, node.pos);
  const indentLevel = lineText.search(/\S/);
  if (indentLevel === -1) {
    const pos = node.end - node.getText().length;
    const nlPos2 = sourceFileText.lastIndexOf("\n", pos);
    const lineText2 = sourceFileText.substring(nlPos2 + 1, pos);
    return lineText2.length;
  }
  return indentLevel;
}
function buildQueryCallExpression(methodName, node) {
  if (node.arguments.length < 1) {
    return {
      type: "Left",
      value: []
    };
  }
  const sourceFile = node.getSourceFile();
  const [typeArgument, typeArgumentSpan] = buildTypeArgumentData(sourceFile, node);
  const sqlExp = node.arguments[0];
  const queryFragments = buildQueryFragments(sqlExp);
  switch (queryFragments.type) {
    case "Left":
      return {
        type: "Left",
        value: queryFragments.value
      };
    case "Right":
      return {
        type: "Right",
        value: {
          fileName: sourceFile.fileName,
          fileContents: sourceFile.text,
          queryMethodName: typeArgument === null ? methodName : null,
          typeArgument,
          typeArgumentSpan,
          indentLevel: getIndentLevel(sourceFile, node),
          queryFragments: queryFragments.value
        }
      };
    default:
      return (0, import_assert_never2.assertNever)(queryFragments);
  }
}
function isTypeSqlView(type) {
  const symbol = type.symbol;
  if (symbol === void 0) {
    return false;
  }
  return symbol.name === "SqlView";
}
function nonNullType(type) {
  if (!type.isUnion()) {
    return type;
  }
  if (type.types.length !== 2) {
    return type;
  }
  if (type.types[0].flags === ts4.TypeFlags.Null) {
    return type.types[1];
  } else if (type.types[1].flags === ts4.TypeFlags.Null) {
    return type.types[0];
  } else {
    return type;
  }
}
var TypeScriptType = class {
  static wrap(val) {
    return val;
  }
  static unwrap(val) {
    return val;
  }
  _dummy;
};
var SqlType = class {
  static wrap(val) {
    return val;
  }
  static unwrap(val) {
    return val;
  }
  _dummy;
};
function getArrayType(type) {
  if (type.symbol.name === "Array") {
    if (type.typeArguments !== void 0) {
      const typeArguments = type.typeArguments;
      if (typeArguments.length === 1) {
        return typeArguments[0];
      }
    }
  }
  return null;
}
function isUnionOfStringLiterals(type) {
  if ((type.flags & ts4.TypeFlags.Union) === 0) {
    return false;
  }
  const types = type.types;
  for (const unionType of types) {
    if (!((unionType.flags & ts4.TypeFlags.String) !== 0 || // tslint:disable-line:no-bitwise
    (unionType.flags & ts4.TypeFlags.StringLiteral) !== 0 || // tslint:disable-line:no-bitwise
    (unionType.flags & ts4.TypeFlags.Null) !== 0)) {
      return false;
    }
  }
  return true;
}
function isUnionOfBooleanLiterals(type) {
  if ((type.flags & ts4.TypeFlags.Union) === 0) {
    return false;
  }
  const types = type.types;
  for (const unionType of types) {
    if (!((unionType.flags & ts4.TypeFlags.Boolean) !== 0 || // tslint:disable-line:no-bitwise
    (unionType.flags & ts4.TypeFlags.BooleanLiteral) !== 0 || // tslint:disable-line:no-bitwise
    (unionType.flags & ts4.TypeFlags.Null) !== 0)) {
      return false;
    }
  }
  return true;
}
function typescriptTypeToSqlType(typeScriptUniqueColumnTypes, type) {
  if (type.flags === ts4.TypeFlags.Any) {
    return SqlType.wrap("ts_any");
  } else if (type.flags === ts4.TypeFlags.Null) {
    return SqlType.wrap("");
  } else if ((type.flags & ts4.TypeFlags.Never) !== 0) {
    return null;
  } else if ((type.flags & ts4.TypeFlags.Boolean) !== 0 || (type.flags & ts4.TypeFlags.BooleanLiteral) !== 0) {
    return SqlType.wrap("bool");
  } else if (isUnionOfBooleanLiterals(type)) {
    return SqlType.wrap("bool");
  } else if ((type.flags & ts4.TypeFlags.Number) !== 0 || (type.flags & ts4.TypeFlags.NumberLiteral) !== 0) {
    return SqlType.wrap("int4");
  } else if ((type.flags & ts4.TypeFlags.String) !== 0 || (type.flags & ts4.TypeFlags.StringLiteral) !== 0) {
    return SqlType.wrap("text");
  } else if (isUnionOfStringLiterals(type)) {
    return SqlType.wrap("text");
  }
  if ((type.flags & ts4.TypeFlags.Union) !== 0) {
    return null;
  }
  if (type.symbol === void 0) {
    throw new Error("TODO figure out when this happens");
  }
  const arrayType = getArrayType(type);
  if (arrayType !== null) {
    const name = typescriptTypeToSqlType(typeScriptUniqueColumnTypes, arrayType);
    if (name === null) {
      return null;
    }
    return SqlType.wrap(SqlType.unwrap(name) + "[]");
  }
  const sqlType = typeScriptUniqueColumnTypes.get(TypeScriptType.wrap(type.symbol.name));
  if (sqlType !== void 0) {
    return sqlType;
  }
  if (type.symbol.name === "DbJson") {
    return SqlType.wrap("jsonb");
  } else if (type.symbol.name === "Instant") {
    return SqlType.wrap("timestamptz");
  } else if (type.symbol.name === "LocalDateTime") {
    return SqlType.wrap("timestamp");
  } else if (type.symbol.name === "LocalDate") {
    return SqlType.wrap("date");
  } else if (type.symbol.name === "LocalTime") {
    return SqlType.wrap("time");
  } else if (type.symbol.name === "UUID") {
    return SqlType.wrap("uuid");
  }
  return null;
}
function readTypeScriptType(checker, type) {
  if ((type.flags & ts4.TypeFlags.Any) !== 0) {
    return TypeScriptType.wrap("any");
  } else if ((type.flags & ts4.TypeFlags.Null) !== 0) {
    return TypeScriptType.wrap("null");
  } else if ((type.flags & ts4.TypeFlags.Boolean) !== 0 || (type.flags & ts4.TypeFlags.BooleanLiteral) !== 0) {
    return TypeScriptType.wrap("boolean");
  } else if ((type.flags & ts4.TypeFlags.Number) !== 0 || (type.flags & ts4.TypeFlags.NumberLiteral) !== 0) {
    return TypeScriptType.wrap("number");
  } else if ((type.flags & ts4.TypeFlags.String) !== 0 || (type.flags & ts4.TypeFlags.StringLiteral) !== 0) {
    return TypeScriptType.wrap("string");
  }
  return TypeScriptType.wrap(checker.typeToString(type));
}
function getColNullability(memberType) {
  const name = memberType.typeName.getText();
  if (name === "Req") {
    return 0 /* REQ */;
  } else if (name === "Opt") {
    return 1 /* OPT */;
  } else {
    return null;
  }
}
function typescriptRowTypeToColTypes(checker, typeNode, errorReporter) {
  if (ts4.isTypeLiteralNode(typeNode)) {
    return typeLiteralNodeToColTypes(checker, typeNode, errorReporter);
  } else {
    const typ = checker.getTypeAtLocation(typeNode);
    if (typ.flags === ts4.TypeFlags.Any) {
      return null;
    } else {
      if (typ.symbol !== void 0 && typ.symbol.members !== void 0) {
        return typeSymbolMembersToColTypes(checker, typeNode, typ.symbol.members, errorReporter);
      } else {
        errorReporter(nodeErrorDiagnostic(typeNode, "Invalid type argument (must be a Type Literal or interface type)"));
        return /* @__PURE__ */ new Map();
      }
    }
  }
}
function typeLiteralNodeToColTypes(checker, typeLiteral, errorReporter) {
  const results = /* @__PURE__ */ new Map();
  for (const member of typeLiteral.members) {
    if (!ts4.isPropertySignature(member)) {
      errorReporter(nodeErrorDiagnostic(member, "Type argument member must be a property"));
    } else {
      if (member.type === void 0) {
        errorReporter(nodeErrorDiagnostic(member, "Property must have a type"));
      } else {
        if (!ts4.isTypeReferenceNode(member.type)) {
          errorReporter(nodeErrorDiagnostic(member, "Property type is not a TypeReferenceNode"));
        } else if (!ts4.isIdentifier(member.name)) {
          errorReporter(nodeErrorDiagnostic(member, "Property name is not an identifier"));
        } else {
          const colTypes = getTypeMemberColTypes(checker, member, member.name.text, member.type);
          switch (colTypes.type) {
            case "Left":
              errorReporter(colTypes.value);
              break;
            case "Right":
              results.set(member.name.text, colTypes.value);
              break;
            default:
              (0, import_assert_never2.assertNever)(colTypes);
          }
        }
      }
    }
  }
  return results;
}
function typeSymbolMembersToColTypes(checker, node, members, errorReporter) {
  const results = /* @__PURE__ */ new Map();
  members.forEach((value, key) => {
    if (value.valueDeclaration === void 0) {
      errorReporter(nodeErrorDiagnostic(node, `Symbol "${key}" has no valueDeclaration`));
    } else if (!ts4.isPropertySignature(value.valueDeclaration)) {
      errorReporter(nodeErrorDiagnostic(node, "valueDeclaration is not a PropertySignature"));
    } else if (value.valueDeclaration.type === void 0) {
      errorReporter(nodeErrorDiagnostic(node, "valueDeclaration is missing type"));
    } else if (!ts4.isTypeReferenceNode(value.valueDeclaration.type)) {
      errorReporter(nodeErrorDiagnostic(node, "valueDeclaration type is not a TypeReferenceNode"));
    } else {
      const colTypes = getTypeMemberColTypes(checker, node, key, value.valueDeclaration.type);
      switch (colTypes.type) {
        case "Left":
          errorReporter(colTypes.value);
          break;
        case "Right":
          results.set(key, colTypes.value);
          break;
        default:
          (0, import_assert_never2.assertNever)(colTypes);
      }
    }
  });
  return results;
}
function getTypeMemberColTypes(checker, node, propName, memberType) {
  const colNullability = getColNullability(memberType);
  if (colNullability === null) {
    return {
      type: "Left",
      value: nodeErrorDiagnostic(node, `Invalid type for property "${propName}", it must be \`Req<T>\` or \`Opt<T>\``)
    };
  } else {
    if (memberType.typeArguments === void 0 || memberType.typeArguments.length < 1) {
      return {
        type: "Left",
        value: nodeErrorDiagnostic(node, `Invalid type for property "${propName}", it must be \`Req<T>\` or \`Opt<T>\``)
      };
    } else {
      const typeArgument = memberType.typeArguments[0];
      const typeArgumentType = checker.getTypeFromTypeNode(typeArgument);
      const type = readTypeScriptType(checker, typeArgumentType);
      if (type === null) {
        return {
          type: "Left",
          value: nodeErrorDiagnostic(node, `Invalid type for property "${propName}": ${checker.typeToString(typeArgumentType)}`)
        };
      } else {
        return {
          type: "Right",
          value: [colNullability, type]
        };
      }
    }
  }
}
function resolveQueryFragment(typeScriptUniqueColumnTypes, projectDir, checker, query, lookupViewName) {
  const errors = [];
  let text = "";
  const sourceMap = [];
  let numParams = 0;
  for (const frag of query.queryFragments) {
    switch (frag.type) {
      case "StringFragment":
        sourceMap.push([frag.sourcePosStart, text.length, text.length + frag.text.length]);
        text += frag.text;
        break;
      case "Expression":
        const type = checker.getTypeAtLocation(frag.exp);
        const maybeSqlFrag = tryTypeSqlFrag(type);
        switch (maybeSqlFrag.type) {
          case "Left":
            errors.push(nodeErrorDiagnostic(frag.exp, maybeSqlFrag.value));
            break;
          case "Right":
            if (maybeSqlFrag.value !== null) {
              text += maybeSqlFrag.value;
            } else if (isTypeSqlView(type)) {
              if (!ts4.isIdentifier(frag.exp)) {
                errors.push(nodeErrorDiagnostic(frag.exp, "SQL View Reference must be an identifier (not an expression)"));
              } else {
                const qualifiedSqlViewName = resolveViewIdentifier(projectDir, frag.exp.getSourceFile(), frag.exp);
                const viewName = lookupViewName(qualifiedSqlViewName);
                if (viewName === void 0) {
                  errors.push(nodeErrorDiagnostic(frag.exp, 'SQL View Reference not found or has errors: "' + import_chalk2.default.bold(QualifiedSqlViewName.viewName(qualifiedSqlViewName)) + '"'));
                } else {
                  text += '"' + viewName + '"';
                }
              }
            } else {
              const sqlType = typescriptTypeToSqlType(typeScriptUniqueColumnTypes, nonNullType(type));
              if (sqlType === null) {
                const typeStr = checker.typeToString(type, frag.exp);
                errors.push(nodeErrorDiagnostic(frag.exp, `Invalid type for SQL parameter: ${typeStr}`));
              } else {
                numParams++;
                const sqlTypeStr = SqlType.unwrap(sqlType);
                const escapedSqlTypeStr = sqlTypeStr.endsWith("[]") ? escapeIdentifier(sqlTypeStr.substring(0, sqlTypeStr.length - 2)) + "[]" : escapeIdentifier(sqlTypeStr);
                text += "($" + numParams + (sqlTypeStr !== "" ? "::" + escapedSqlTypeStr : "") + ")";
              }
            }
            break;
          default:
            (0, import_assert_never2.assertNever)(maybeSqlFrag);
        }
        break;
      default:
        (0, import_assert_never2.assertNever)(frag);
    }
  }
  if (errors.length === 0) {
    let colTypes;
    if (query.typeArgument === null) {
      colTypes = /* @__PURE__ */ new Map();
    } else {
      colTypes = typescriptRowTypeToColTypes(checker, query.typeArgument, (e) => errors.push(e));
    }
    return {
      type: "Right",
      value: {
        fileName: query.fileName,
        fileContents: query.fileContents,
        text,
        sourceMap,
        colTypes,
        queryMethodName: query.queryMethodName,
        colTypeSpan: query.typeArgumentSpan,
        indentLevel: query.indentLevel,
        errors
      }
    };
  } else {
    return {
      type: "Left",
      value: errors
    };
  }
}

// mfsqlchecker/ConfigFile.ts
var defaultColTypesFormat = {
  includeRegionMarker: false,
  delimiter: ","
};
function normalizeConfigFile(configFile) {
  return {
    migrationsDir: configFile.migrationsDir !== void 0 ? configFile.migrationsDir : null,
    postgresVersion: configFile.postgresVersion !== void 0 ? configFile.postgresVersion : null,
    colTypesFormat: configFile.colTypesFormat !== void 0 ? toColTypesFormat(configFile.colTypesFormat) : defaultColTypesFormat,
    strictDateTimeChecking: configFile.strictDateTimeChecking === true,
    customSqlTypeMappings: configFile.customSqlTypeMappings !== void 0 ? configFile.customSqlTypeMappings.map(toCustomSqlTypeMapping) : [],
    uniqueTableColumnTypes: configFile.uniqueTableColumnTypes !== void 0 ? configFile.uniqueTableColumnTypes.map(toUniqueTableColumnType) : []
  };
}
function toColTypesFormat(v) {
  return {
    includeRegionMarker: v.includeRegionMarker !== void 0 ? v.includeRegionMarker : defaultColTypesFormat.includeRegionMarker,
    delimiter: v.delimiter !== void 0 ? v.delimiter : defaultColTypesFormat.delimiter
  };
}
function toCustomSqlTypeMapping(v) {
  return {
    sqlTypeName: SqlType.wrap(v.sqlTypeName),
    typeScriptTypeName: TypeScriptType.wrap(v.typeScriptTypeName)
  };
}
function toUniqueTableColumnType(v) {
  return {
    typeScriptTypeName: TypeScriptType.wrap(v.typeScriptTypeName),
    tableName: v.tableName,
    columnName: v.columnName
  };
}
function sqlUniqueTypeName(tableName, columnName) {
  return tableName + "(" + columnName + ")";
}
function loadConfigFile(fileName) {
  let fileContents;
  try {
    fileContents = import_fs.default.readFileSync(fileName, { encoding: "utf8" });
  } catch (err) {
    return {
      type: "Left",
      value: {
        fileName,
        fileContents: "",
        span: {
          type: "File"
        },
        messages: [`Error opening file ${fileName}`, err.message],
        epilogue: null,
        quickFix: null
      }
    };
  }
  const mbConfigFile = parseConfigFile(fileName, fileContents);
  switch (mbConfigFile.type) {
    case "Left":
      return mbConfigFile;
    case "Right":
      return {
        type: "Right",
        value: normalizeConfigFile(mbConfigFile.value)
      };
    default:
      return (0, import_assert_never3.assertNever)(mbConfigFile);
  }
}
var ajv = new import_ajv.default();
ajv.addMetaSchema(require("ajv/lib/refs/json-schema-draft-06.json"));
function parseConfigFile(fileName, fileContents) {
  function error(messages2) {
    return {
      type: "Left",
      value: {
        fileContents,
        fileName,
        span: {
          type: "File"
        },
        messages: messages2,
        epilogue: null,
        quickFix: null
      }
    };
  }
  let json;
  try {
    json = JSON.parse(fileContents);
  } catch (err) {
    return error(["JSON Parser Error", err.message]);
  }
  const valid = ajv.validate(configFileSchema, json);
  if (!valid) {
    if (ajv.errors === null || ajv.errors === void 0) {
      throw new Error("The Impossible Happened");
    }
    return error(ajv.errors.map((e) => JSON.stringify(e, null, 2)));
  }
  return {
    type: "Right",
    value: json
  };
}
var configFileSchema = {
  "$schema": "http://json-schema.org/draft-06/schema#",
  "definitions": {
    "ConfigFile": {
      "type": "object",
      "properties": {
        "migrationsDir": {
          "type": "string"
        },
        "postgresVersion": {
          "type": "string"
        },
        "colTypesFormat": {
          "type": "object",
          "properties": {
            "includeRegionMarker": {
              "type": "boolean"
            },
            "delimiter": {
              "type": "string",
              "enum": [
                ",",
                ";"
              ]
            }
          },
          "additionalProperties": false
        },
        "strictDateTimeChecking": {
          "type": "boolean"
        },
        "customSqlTypeMappings": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "typeScriptTypeName": {
                "type": "string"
              },
              "sqlTypeName": {
                "type": "string"
              }
            },
            "required": [
              "typeScriptTypeName",
              "sqlTypeName"
            ],
            "additionalProperties": false
          }
        },
        "uniqueTableColumnTypes": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "typeScriptTypeName": {
                "type": "string"
              },
              "tableName": {
                "type": "string"
              },
              "columnName": {
                "type": "string"
              }
            },
            "required": [
              "typeScriptTypeName",
              "tableName",
              "columnName"
            ],
            "additionalProperties": false
          }
        }
      },
      "additionalProperties": false
    }
  },
  "$ref": "#/definitions/ConfigFile"
};

// mfsqlchecker/formatters/jsonFormatter.ts
var import_assert_never4 = require("assert-never");
function formatJsonDiagnostic(errorDiagnostic) {
  let location;
  switch (errorDiagnostic.span.type) {
    case "LineAndColRange":
      location = {
        startLine: errorDiagnostic.span.startLine - 1,
        startCharacter: errorDiagnostic.span.startCol - 1,
        endLine: errorDiagnostic.span.endLine - 1,
        endCharacter: errorDiagnostic.span.endCol - 1
      };
      break;
    case "LineAndCol":
      location = {
        startLine: errorDiagnostic.span.line - 1,
        startCharacter: errorDiagnostic.span.col - 1,
        endLine: errorDiagnostic.span.line - 1,
        endCharacter: errorDiagnostic.span.col - 1
      };
      break;
    case "File":
      location = {
        startLine: 0,
        startCharacter: 0,
        endLine: 0,
        endCharacter: 0
      };
      break;
    default:
      return (0, import_assert_never4.assertNever)(errorDiagnostic.span);
  }
  let message = "";
  for (const msg of errorDiagnostic.messages) {
    message += "* " + msg + "\n";
  }
  if (errorDiagnostic.epilogue !== null) {
    message += "* " + errorDiagnostic.epilogue;
  }
  return {
    fileName: errorDiagnostic.fileName,
    location,
    message,
    quickFix: errorDiagnostic.quickFix
  };
}

// mfsqlchecker/sqlchecker_engine.ts
var import_register = require("source-map-support/register");
var import_assert_never5 = require("assert-never");
var ts5 = __toESM(require("typescript"));
var E2 = __toESM(require("fp-ts/Either"));
function getSqlViews(params) {
  const { projectDir, program, checker, sourceFiles } = params;
  const viewLibrary = /* @__PURE__ */ new Map();
  const progSourceFiles = program.getSourceFiles().filter((s) => !s.isDeclarationFile);
  let errorDiagnostics = [];
  for (const sourceFile of sourceFiles) {
    const sf = progSourceFiles.find((s) => s.fileName === sourceFile);
    if (sf === void 0) {
      throw new Error("SourceFile not found: " + sourceFile);
    }
    const [views, errs] = sqlViewsLibraryAddFromSourceFile(projectDir, checker, sf);
    errorDiagnostics = errorDiagnostics.concat(errs);
    for (const key of viewLibrary.keys()) {
      if (QualifiedSqlViewName.moduleId(key) === sourceFileModuleName(projectDir, sf)) {
        const newView = views.get(key);
        if (newView === void 0) {
          viewLibrary.delete(key);
        } else {
          const oldView = viewLibrary.get(key);
          if (oldView === void 0) {
            throw new Error("The Impossible Happened");
          }
          if (!oldView.isEqual(newView)) {
            viewLibrary.set(key, newView);
            sqlViewLibraryResetToInitialFragmentsIncludingDeps(key, viewLibrary);
          }
        }
      }
    }
    views.forEach((value, key) => {
      if (!viewLibrary.has(key)) {
        viewLibrary.set(key, value);
      }
    });
  }
  const [sqlViews, viewErrors] = resolveAllViewDefinitions(viewLibrary);
  errorDiagnostics = errorDiagnostics.concat(viewErrors);
  if (errorDiagnostics.length > 0) {
    return E2.left(errorDiagnostics);
  }
  return E2.right({ viewLibrary, sqlViews });
}

// eslint-local-rules/utils.ts
var import_utils2 = __toESM(require_dist5());
var createRule = import_utils2.ESLintUtils.RuleCreator((name) => `https://github.com/MedFlyt/mfsqlchecker#${name}`);

// eslint-local-rules/utils/memoize.ts
var memoized = /* @__PURE__ */ new Map();
function memoize(params) {
  const { key, value } = params;
  if (memoized.has(key)) {
    return memoized.get(key);
  }
  const result = value();
  memoized.set(key, result);
  return result;
}

// eslint-local-rules/rules/DbConnector.ts
var import_assert_never7 = require("assert-never");
var import_chalk4 = __toESM(require("chalk"));
var import_cli_progress = require("cli-progress");
var import_tiny_invariant = __toESM(require("tiny-invariant"));
var TE = __toESM(require("fp-ts/TaskEither"));
var E3 = __toESM(require("fp-ts/Either"));
var import_function2 = require("fp-ts/function");

// mfsqlchecker/pg_test_db.ts
var import_pg_connection_string = require("pg-connection-string");

// mfsqlchecker/source_maps.ts
function resolveFromSourceMap(fileContents, position, sourceMap) {
  if (sourceMap.length === 0) {
    throw new Error("Empty sourceMap");
  }
  let i = 0;
  while (true) {
    if (position >= sourceMap[i][1] && position < sourceMap[i][2]) {
      return toSrcSpan(fileContents, sourceMap[i][0] + (position - sourceMap[i][1]));
    }
    if (position < sourceMap[i][1]) {
      if (i > 0) {
        const start = toSrcSpan(fileContents, sourceMap[i - 1][0] + sourceMap[i - 1][2] - sourceMap[i - 1][1]);
        const end = toSrcSpan(fileContents, sourceMap[i][0]);
        return {
          type: "LineAndColRange",
          startLine: start.line,
          startCol: start.col,
          endLine: end.line,
          endCol: end.col
        };
      } else {
        return toSrcSpan(fileContents, sourceMap[0][0]);
      }
    }
    if (i === sourceMap.length - 1) {
      return toSrcSpan(fileContents, sourceMap[i][0] + sourceMap[i][2] - sourceMap[i][1] - 1);
    }
    i++;
  }
}

// mfsqlchecker/formatters/codeFrameFormatter.ts
var import_assert_never6 = require("assert-never");
var import_chalk3 = __toESM(require("chalk"));
function codeFrameFormatter(errorDiagnostic) {
  let result = "\n";
  result += renderFileLocation(errorDiagnostic);
  result += renderMessages(errorDiagnostic);
  result += renderCodeFrame(errorDiagnostic);
  result += renderEpilogue(errorDiagnostic);
  return result;
}
function renderFileLocation(errorDiagnostic) {
  let result = "";
  result += import_chalk3.default.cyanBright(errorDiagnostic.fileName);
  switch (errorDiagnostic.span.type) {
    case "LineAndColRange":
      result += ":" + import_chalk3.default.yellowBright(`${errorDiagnostic.span.startLine}`) + ":" + import_chalk3.default.yellowBright(`${errorDiagnostic.span.startCol}`) + ":";
      break;
    case "LineAndCol":
      result += ":" + import_chalk3.default.yellowBright(`${errorDiagnostic.span.line}`) + ":" + import_chalk3.default.yellowBright(`${errorDiagnostic.span.col}`) + ":";
      break;
    case "File":
      result += ":";
      break;
    default:
      (0, import_assert_never6.assertNever)(errorDiagnostic.span);
  }
  result += " " + import_chalk3.default.redBright.bold("error:");
  result += "\n";
  return result;
}
function renderMessages(errorDiagnostic) {
  let result = "";
  for (const message of errorDiagnostic.messages) {
    const msg = message.replace(/\n/g, "\n      ");
    result += "    * " + msg + "\n";
  }
  return result;
}
function renderCodeFrame(errorDiagnostic) {
  let result = "";
  let startLine;
  let endLine;
  switch (errorDiagnostic.span.type) {
    case "LineAndCol":
      startLine = errorDiagnostic.span.line - 1;
      endLine = errorDiagnostic.span.line - 1;
      break;
    case "LineAndColRange":
      startLine = errorDiagnostic.span.startLine - 1;
      endLine = errorDiagnostic.span.endLine - 1;
      break;
    case "File":
      return result;
    default:
      return (0, import_assert_never6.assertNever)(errorDiagnostic.span);
  }
  result += "\n";
  const lines = errorDiagnostic.fileContents.split("\n");
  const LINES_MARGIN = 6;
  const minLine = Math.max(0, startLine - LINES_MARGIN);
  const maxLine = Math.min(lines.length - 1, endLine + LINES_MARGIN);
  const padding = `${maxLine + 1}`.length;
  for (let l = minLine; l <= maxLine; ++l) {
    switch (errorDiagnostic.span.type) {
      case "LineAndCol":
        if (l === errorDiagnostic.span.line - 1) {
          const prefix = lines[l].substr(0, errorDiagnostic.span.col - 1);
          const target = lines[l].substr(errorDiagnostic.span.col - 1, 1);
          const suffix = lines[l].substr(errorDiagnostic.span.col);
          result += import_chalk3.default.blueBright(` ${pad(`${l + 1}`, padding, " ")} |`) + " " + prefix + import_chalk3.default.redBright.bold(target) + suffix + "\n";
        } else {
          result += import_chalk3.default.blueBright(` ${pad(`${l + 1}`, padding, " ")} |`) + " " + lines[l] + "\n";
        }
        if (l === errorDiagnostic.span.line - 1) {
          result += import_chalk3.default.blueBright(` ${pad("", padding, " ")} |`) + " ".repeat(errorDiagnostic.span.col) + import_chalk3.default.redBright.bold("^") + "\n";
        }
        break;
      case "LineAndColRange":
        if (l > errorDiagnostic.span.startLine - 1 && l < errorDiagnostic.span.endLine - 1) {
          result += import_chalk3.default.blueBright(` ${pad(`${l + 1}`, padding, " ")} |`) + " " + import_chalk3.default.redBright.bold(lines[l]) + "\n";
          const spaces = lines[l].search(/(\S|$)/);
          result += import_chalk3.default.blueBright(` ${pad("", padding, " ")} |`) + " ".repeat(spaces + 1) + import_chalk3.default.redBright.bold("~".repeat(lines[l].length - spaces)) + "\n";
        } else if (l === errorDiagnostic.span.startLine - 1 && l !== errorDiagnostic.span.endLine - 1) {
          const prefix = lines[l].substr(0, errorDiagnostic.span.startCol - 1);
          const suffix = lines[l].substr(errorDiagnostic.span.startCol - 1);
          const spaces = prefix.length;
          result += import_chalk3.default.blueBright(` ${pad(`${l + 1}`, padding, " ")} |`) + " " + prefix + import_chalk3.default.redBright.bold(suffix) + "\n";
          if (lines[l].length > spaces) {
            result += import_chalk3.default.blueBright(` ${pad("", padding, " ")} |`) + " ".repeat(spaces + 1) + import_chalk3.default.redBright.bold("~".repeat(lines[l].length - spaces)) + "\n";
          }
        } else if (l === errorDiagnostic.span.endLine - 1 && l !== errorDiagnostic.span.startLine - 1) {
          const prefix = lines[l].substr(0, errorDiagnostic.span.endCol - 1);
          const suffix = lines[l].substr(errorDiagnostic.span.endCol - 1);
          const spaces = lines[l].search(/(\S|$)/);
          result += import_chalk3.default.blueBright(` ${pad(`${l + 1}`, padding, " ")} |`) + " " + import_chalk3.default.redBright.bold(prefix) + suffix + "\n";
          result += import_chalk3.default.blueBright(` ${pad("", padding, " ")} |`) + " ".repeat(spaces + 1) + import_chalk3.default.redBright.bold("~".repeat(prefix.length - spaces)) + "\n";
        } else if (l === errorDiagnostic.span.endLine - 1 && l === errorDiagnostic.span.startLine - 1) {
          const prefix = lines[l].substr(0, errorDiagnostic.span.startCol - 1);
          const target = lines[l].substring(errorDiagnostic.span.startCol - 1, errorDiagnostic.span.endCol - 1);
          const suffix = lines[l].substr(errorDiagnostic.span.endCol - 1);
          result += import_chalk3.default.blueBright(` ${pad(`${l + 1}`, padding, " ")} |`) + " " + prefix + import_chalk3.default.redBright.bold(target) + suffix + "\n";
          result += import_chalk3.default.blueBright(` ${pad("", padding, " ")} |`) + " ".repeat(prefix.length + 1) + import_chalk3.default.redBright.bold("~".repeat(lines[l].length - suffix.length - prefix.length)) + "\n";
        } else {
          result += import_chalk3.default.blueBright(` ${pad(`${l + 1}`, padding, " ")} |`) + " " + lines[l] + "\n";
        }
        break;
      default:
        (0, import_assert_never6.assertNever)(errorDiagnostic.span);
    }
  }
  result += "\n";
  return result;
}
function renderEpilogue(errorDiagnostic) {
  let result = "";
  if (errorDiagnostic.epilogue === null) {
    return result;
  }
  const msg = errorDiagnostic.epilogue.replace(/\n/g, "\n      ");
  result += "    * " + msg + "\n";
  return result;
}
function pad(str, width, z) {
  return str.length >= width ? str : new Array(width - str.length + 1).join(z) + str;
}

// eslint-local-rules/rules/sql-check.errors.ts
var InvalidQueryError = class extends Error {
  _tag = "InvalidQueryError";
  constructor(diagnostics) {
    super(diagnostics.map(codeFrameFormatter).join("\n"));
    this.name = "InvalidQueryError";
  }
  static to(error) {
    return error instanceof InvalidQueryError ? error : new Error(`${error}`);
  }
  toJSON() {
    return { _tag: this._tag, message: this.message };
  }
};

// eslint-local-rules/rules/DbConnector.ts
var SELECT_STAR_REGEX = new RegExp("(select|\\.|\\,)\\s*\\*", "i");
function querySourceStart(fileContents, sourceMap) {
  return toSrcSpan(
    fileContents,
    fileContents.slice(sourceMap[0][0] + 1).search(/\S/) + sourceMap[0][0] + 2
  );
}
function queryAnswerToErrorDiagnostics(query, queryAnswer, colTypesFormat) {
  switch (queryAnswer.type) {
    case "NoErrors":
      return [];
    case "DescribeError":
      if (queryAnswer.perr.position !== null) {
        const srcSpan = resolveFromSourceMap(
          query.fileContents,
          queryAnswer.perr.position - 1,
          query.sourceMap
        );
        return [
          postgresqlErrorDiagnostic(
            query.fileName,
            query.fileContents,
            queryAnswer.perr,
            srcSpan,
            null
          )
        ];
      } else {
        return [
          postgresqlErrorDiagnostic(
            query.fileName,
            query.fileContents,
            queryAnswer.perr,
            querySourceStart(query.fileContents, query.sourceMap),
            null
          )
        ];
      }
    case "DuplicateColNamesError":
      return [
        {
          fileName: query.fileName,
          fileContents: query.fileContents,
          span: querySourceStart(query.fileContents, query.sourceMap),
          messages: [
            `Query return row contains duplicate column names:
${JSON.stringify(
              queryAnswer.duplicateResultColumns,
              null,
              2
            )}`
          ],
          epilogue: import_chalk4.default.bold("hint") + ': Specify a different name for the column using the Sql "AS" keyword',
          quickFix: null
        }
      ];
    case "WrongColumnTypes":
      let replacementText;
      let colTypes = queryAnswer.renderedColTypes.split("\n");
      if (colTypes.length <= 2) {
        replacementText = "<{}>";
      } else if (colTypes.length === 3) {
        colTypes = colTypes.map((c) => c.trimLeft());
        colTypes[1] = " ".repeat(query.indentLevel + 4) + colTypes[1];
        colTypes[2] = " ".repeat(query.indentLevel) + colTypes[2];
        replacementText = "<" + colTypes.join("\n") + ">";
      } else if (colTypes.length > 3) {
        colTypes = colTypes.map((c) => c.trimLeft());
        for (let i = 1; i < colTypes.length - 1; ++i) {
          colTypes[i] = " ".repeat(query.indentLevel + 4) + colTypes[i];
        }
        colTypes[colTypes.length - 1] = " ".repeat(query.indentLevel) + colTypes[colTypes.length - 1];
        if (colTypesFormat.includeRegionMarker) {
          colTypes.splice(1, 0, " ".repeat(query.indentLevel + 4) + "//#region ColTypes");
          colTypes.splice(
            colTypes.length - 1,
            0,
            " ".repeat(query.indentLevel + 4) + "//#endregion"
          );
        }
        replacementText = "<" + colTypes.join("\n") + ">";
      } else {
        throw new Error(`Invalid colTypes.length: ${queryAnswer.renderedColTypes}`);
      }
      if (query.queryMethodName !== null) {
        replacementText = query.queryMethodName + replacementText;
      }
      return [
        {
          fileName: query.fileName,
          fileContents: query.fileContents,
          span: query.colTypeSpan,
          messages: ["Wrong Column Types"],
          epilogue: import_chalk4.default.bold("Fix it to:") + "\n" + queryAnswer.renderedColTypes,
          quickFix: {
            name: "Fix Column Types",
            replacementText
          }
        }
      ];
    default:
      return (0, import_assert_never7.assertNever)(queryAnswer);
  }
}

// eslint-local-rules/rules/sql-check.utils.ts
var import_assert_never8 = __toESM(require("assert-never"));
var E4 = __toESM(require("fp-ts/Either"));
var TE2 = __toESM(require("fp-ts/TaskEither"));
var import_function3 = require("fp-ts/function");
var import_fs2 = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var import_embedded_postgres = __toESM(require("embedded-postgres"));
var QUERY_METHOD_NAMES = /* @__PURE__ */ new Set(["query", "queryOne", "queryOneOrNone"]);
var INSERT_METHOD_NAMES = /* @__PURE__ */ new Set(["insert", "insertMaybe"]);
var VALID_METHOD_NAMES = /* @__PURE__ */ new Set([...QUERY_METHOD_NAMES, ...INSERT_METHOD_NAMES]);
function locateNearestPackageJsonDir(filePath) {
  const dir = import_path.default.dirname(filePath);
  const packageJsonFile = import_path.default.join(dir, "package.json");
  if (import_fs2.default.existsSync(packageJsonFile)) {
    return dir;
  }
  return locateNearestPackageJsonDir(dir);
}

// eslint-local-rules/rules/sql-check.rule.ts
var messages = {
  missing: "Missing: {{value}}",
  invalid: "Invalid: {{value}}",
  internal: "Internal error: {{value}}"
};
var sqlCheck = createRule({
  name: "sql-check",
  meta: {
    docs: {
      description: "Statically validate correctness of all your SQL queries. TypeScript, PostgreSQL",
      recommended: "error"
    },
    messages,
    type: "suggestion",
    schema: []
  },
  defaultOptions: [],
  create(context) {
    const projectDir = memoize({
      key: context.getFilename(),
      value: () => locateNearestPackageJsonDir(context.getFilename())
    });
    return {
      CallExpression: (node) => checkCallExpression({ node, context, projectDir })
    };
  }
});
var workerPath = require.resolve("./sql-check.worker");
var runWorker = createSyncFn(workerPath, {
  tsRunner: TsRunner.TSX,
  // timeout: 9000
  timeout: 1e3 * 60 * 5
});
var cache = {
  isInitial: true,
  viewLibrary: /* @__PURE__ */ new Map()
};
function checkCallExpression(params) {
  const { node, context, projectDir } = params;
  const callExpressionValidityE = getCallExpressionValidity(node);
  if (E5.isLeft(callExpressionValidityE) || context.parserServices === void 0) {
    return;
  }
  const parser = context.parserServices;
  const sourceCode = context.getSourceCode();
  const { callee, calleeProperty } = callExpressionValidityE.right;
  const tsCallExpression = parser.esTreeNodeToTSNodeMap.get(node);
  const checker = parser.program.getTypeChecker();
  const tsObject = parser.esTreeNodeToTSNodeMap.get(callee.object);
  const tsObjectType = checker.getTypeAtLocation(tsObject);
  if (tsObjectType.getProperty("MfConnectionTypeTag") === void 0) {
    return;
  }
  if (cache.isInitial) {
    const configE = toFpTsEither(
      loadConfigFile(import_path2.default.join(projectDir, "demo/mfsqlchecker.json"))
    );
    if (E5.isLeft(configE)) {
      return context.report({
        node,
        messageId: "internal",
        data: { value: JSON.stringify(configE.left) }
      });
    }
    const config2 = configE.right;
    const uniqueTableColumnTypes = getTSUniqueColumnTypes(config2.uniqueTableColumnTypes);
    const program = context.parserServices.program;
    const sourceFiles = program.getSourceFiles().filter((s) => !s.isDeclarationFile);
    const initE = (0, import_function4.pipe)(
      E5.Do,
      E5.chain(() => {
        return getSqlViews({
          projectDir,
          checker,
          program,
          sourceFiles: sourceFiles.map((x) => x.fileName)
        });
      }),
      E5.mapLeft(InvalidQueryError.to),
      E5.chainFirst(() => {
        return runWorker({
          action: "INITIALIZE",
          projectDir,
          strictDateTimeChecking: true,
          uniqueTableColumnTypes: config2.uniqueTableColumnTypes,
          viewLibrary: []
        });
      })
    );
    if (E5.isLeft(initE)) {
      return context.report({
        node,
        messageId: "internal",
        data: { value: initE.left.message }
      });
    }
    cache.isInitial = false;
    cache.config = config2;
    cache.tsUniqueTableColumnTypes = uniqueTableColumnTypes;
    cache.viewLibrary = initE.right.viewLibrary;
  }
  (0, import_tiny_invariant2.default)(cache.config !== void 0, "config is undefined");
  (0, import_tiny_invariant2.default)(
    cache.tsUniqueTableColumnTypes !== void 0,
    "tsUniqueTableColumnTypes is undefined"
  );
  (0, import_tiny_invariant2.default)(cache.viewLibrary !== void 0, "viewLibrary is undefined");
  const { config, tsUniqueTableColumnTypes, viewLibrary } = cache;
  const resolvedStmtE = (0, import_function4.pipe)(
    E5.Do,
    E5.chain(() => buildQueryCallExpressionE(calleeProperty.name, tsCallExpression)),
    E5.chainW((query) => {
      return resolveQueryFragmentE(
        tsUniqueTableColumnTypes,
        params.projectDir,
        checker,
        query,
        (name) => viewLibrary.get(name)?.getName()
      );
    })
  );
  if (E5.isLeft(resolvedStmtE)) {
    return context.report({
      node,
      messageId: "internal",
      data: { value: resolvedStmtE.left.message }
    });
  }
  const resolvedStmt = resolvedStmtE.right;
  (0, import_function4.pipe)(
    E5.Do,
    E5.chain(() => runWorker({ action: "CHECK", query: resolvedStmt })),
    E5.chainW((r) => r.type === "NoErrors" ? E5.right(r) : E5.left(r)),
    E5.mapLeft((error) => {
      if (error instanceof Error) {
        return context.report({
          node,
          messageId: "internal",
          data: { value: error.message }
        });
      }
      const diagnostics = queryAnswerToErrorDiagnostics(
        resolvedStmt,
        error,
        defaultColTypesFormat
      );
      for (const diagnostic of diagnostics) {
        const formatted = formatJsonDiagnostic(diagnostic);
        context.report({
          node,
          messageId: "internal",
          loc: {
            start: {
              line: formatted.location.startLine + 1,
              column: formatted.location.startCharacter + 1
            },
            end: {
              line: formatted.location.endLine + 1,
              column: formatted.location.endCharacter + 1
            }
          },
          data: { value: diagnostic.messages.join("\n") }
        });
      }
    })
  );
}
var resolveQueryFragmentE = (0, import_function4.flow)(
  resolveQueryFragment,
  toFpTsEither,
  E5.mapLeft((diagnostics) => new InvalidQueryError(diagnostics))
);
var buildQueryCallExpressionE = (0, import_function4.flow)(
  buildQueryCallExpression,
  toFpTsEither,
  E5.mapLeft((diagnostics) => new InvalidQueryError(diagnostics))
);
function getTSUniqueColumnTypes(uniqueTableColumnTypes) {
  const tsUniqueColumnTypes = /* @__PURE__ */ new Map();
  for (const uniqueTableColumnType of uniqueTableColumnTypes) {
    tsUniqueColumnTypes.set(
      uniqueTableColumnType.typeScriptTypeName,
      SqlType.wrap(
        sqlUniqueTypeName(uniqueTableColumnType.tableName, uniqueTableColumnType.columnName)
      )
    );
  }
  return tsUniqueColumnTypes;
}
function toFpTsEither(either) {
  return either.type === "Left" ? E5.left(either.value) : E5.right(either.value);
}
function getCallExpressionValidity(node) {
  if (node.callee.type !== import_typescript_estree.TSESTree.AST_NODE_TYPES.MemberExpression) {
    return E5.left("CALLEE_NOT_MEMBER_EXPRESSION");
  }
  if (node.callee.property.type !== import_typescript_estree.TSESTree.AST_NODE_TYPES.Identifier) {
    return E5.left("CALLEE_PROPERTY_NOT_IDENTIFIER");
  }
  if (!VALID_METHOD_NAMES.has(node.callee.property.name)) {
    return E5.left("CALLEE_PROPERTY_NOT_VALID");
  }
  const argument = node.arguments[0];
  if (argument === void 0) {
    return E5.left("NO_ARGUMENT");
  }
  if (argument.type !== import_typescript_estree.TSESTree.AST_NODE_TYPES.TaggedTemplateExpression) {
    return E5.left("ARGUMENT_NOT_TAGGED_TEMPLATE_EXPRESSION");
  }
  return E5.right({
    callee: node.callee,
    calleeProperty: node.callee.property,
    argument
  });
}

// eslint-local-rules/index.ts
var eslint_local_rules_default = {
  "sql-check": sqlCheck
};
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

is-extglob/index.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

is-glob/index.js:
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

queue-microtask/index.js:
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

run-parallel/index.js:
  (*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=eslint-local-rules.js.map