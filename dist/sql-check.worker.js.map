{"version":3,"sources":["../eslint-local-rules/rules/sql-check.worker.ts","../node_modules/.pnpm/tslib@2.5.0/node_modules/tslib/tslib.es6.js","../node_modules/.pnpm/synckit@0.8.5/node_modules/synckit/src/index.ts","../mfsqlchecker/formatters/codeFrameFormatter.ts","../eslint-local-rules/utils/errors.ts","../eslint-local-rules/rules/sql-check.utils.ts","../mfsqlchecker/ConfigFile.ts","../mfsqlchecker/queries.ts","../mfsqlchecker/ErrorDiagnostic.ts","../mfsqlchecker/pg_extra.ts","../mfsqlchecker/views.ts","../mfsqlchecker/ts_extra.ts","../mfsqlchecker/pg_test_db.ts","../eslint-local-rules/utils/query-runner.ts","../mfsqlchecker/source_maps.ts","../eslint-local-rules/utils/log.ts"],"sourcesContent":["import type EmbeddedPostgres from \"embedded-postgres\";\nimport * as E from \"fp-ts/Either\";\nimport { pipe } from \"fp-ts/function\";\nimport * as TE from \"fp-ts/TaskEither\";\nimport * as J from \"fp-ts/Json\";\nimport \"source-map-support/register\";\nimport { runAsWorker } from \"synckit\";\nimport { UniqueTableColumnType } from \"../../mfsqlchecker/ConfigFile\";\nimport { ErrorDiagnostic } from \"../../mfsqlchecker/ErrorDiagnostic\";\nimport { ResolvedInsert, ResolvedSelect } from \"../../mfsqlchecker/queries\";\nimport { SqlCreateView } from \"../../mfsqlchecker/views\";\nimport { QueryRunner } from \"../utils/query-runner\";\nimport { InvalidQueryError, RunnerError } from \"../utils/errors\";\nimport { initializeTE, Options, PostgresOptions } from \"./sql-check.utils\";\nimport { customLog } from \"../utils/log\";\n\nexport type WorkerParams =\n    | InitializeParams\n    | CheckQueryParams\n    | CheckInsertParams\n    | UpdateViewsParams\n    | EndParams;\n\ntype TaskEitherToEither<T> = T extends TE.TaskEither<infer E, infer A> ? E.Either<E, A> : never;\n\nexport type WorkerResult<Action extends WorkerParams[\"action\"]> = TaskEitherToEither<\n    {\n        INITIALIZE: ReturnType<typeof runInitialize>;\n        CHECK_QUERY: ReturnType<typeof runCheckQuery>;\n        CHECK_INSERT: ReturnType<typeof runCheckInsert>;\n        UPDATE_VIEWS: ReturnType<typeof runUpdateViews>;\n        END: ReturnType<typeof runEnd>;\n    }[Action]\n>;\n\nlet cache: {\n    readonly options: Options;\n    readonly server: {\n        pg: EmbeddedPostgres;\n        options: Pick<PostgresOptions, \"port\" | \"user\" | \"password\">;\n        adminUrl: string;\n        dbName: string;\n    };\n    readonly runner: QueryRunner;\n} | null = null;\n\nlet initializePromiseInstance: Promise<WorkerResult<\"INITIALIZE\">> | null = null;\n\nasync function handler(params: WorkerParams) {\n    switch (params.action) {\n        case \"INITIALIZE\": {\n            if (initializePromiseInstance === null || params.force) {\n                initializePromiseInstance = runInitialize(params)();\n            }\n            return await initializePromiseInstance;\n        }\n        case \"CHECK_QUERY\":\n            return await runCheckQuery(params)();\n        case \"CHECK_INSERT\":\n            return await runCheckInsert(params)();\n        case \"UPDATE_VIEWS\":\n            return await runUpdateViews(params)();\n        case \"END\":\n            return await runEnd(params)();\n    }\n}\n\ntype InitializeParams = {\n    action: \"INITIALIZE\";\n    projectDir: string;\n    uniqueTableColumnTypes: UniqueTableColumnType[];\n    strictDateTimeChecking: boolean;\n    sqlViews: SqlCreateView[];\n    configFile: string;\n    migrationsDir: string;\n    force: boolean;\n};\n\nfunction runInitialize(params: InitializeParams): TE.TaskEither<RunnerError, void> {\n    customLog.success(\"initialize\")\n    return pipe(\n        initializeTE({\n            projectDir: params.projectDir,\n            configFile: params.configFile,\n            migrationsDir: params.migrationsDir,\n            uniqueTableColumnTypes: params.uniqueTableColumnTypes,\n            strictDateTimeChecking: params.strictDateTimeChecking,\n            sqlViews: params.sqlViews\n        }),\n        TE.map((result) => {\n            cache = result;\n        })\n    );\n}\n\ntype CheckQueryParams = { action: \"CHECK_QUERY\"; resolved: ResolvedSelect };\n\nfunction mapDiagnosticsToError(diagnostics: ErrorDiagnostic[]) {\n    return diagnostics.length === 0\n        ? E.right(undefined)\n        : E.left(new InvalidQueryError(diagnostics));\n}\n\nfunction runCheckQuery(\n    params: CheckQueryParams\n): TE.TaskEither<InvalidQueryError | RunnerError | Error, undefined> {\n    if (cache?.runner === undefined) {\n        return TE.left(new Error(\"runner is not initialized\"));\n    }\n\n    const runner = cache.runner;\n\n    return pipe(\n        TE.Do,\n        TE.chain(() => TE.tryCatch(() => runner.runQuery(params), RunnerError.to)),\n        TE.chainEitherKW(mapDiagnosticsToError)\n    );\n}\n\ntype CheckInsertParams = { action: \"CHECK_INSERT\"; resolved: ResolvedInsert };\n\nfunction runCheckInsert(\n    params: CheckInsertParams\n): TE.TaskEither<InvalidQueryError | RunnerError | Error, undefined> {\n    if (cache?.runner === undefined) {\n        return TE.left(new Error(\"runner is not initialized\"));\n    }\n\n    const runner = cache.runner;\n\n    return pipe(\n        TE.Do,\n        TE.chain(() => TE.tryCatch(() => runner.runInsert(params), RunnerError.to)),\n        TE.chainEitherKW(mapDiagnosticsToError)\n    );\n}\n\ntype UpdateViewsParams = {\n    action: \"UPDATE_VIEWS\";\n    strictDateTimeChecking: boolean;\n    sqlViews: SqlCreateView[];\n};\n\nfunction runUpdateViews(\n    params: UpdateViewsParams\n): TE.TaskEither<Error | RunnerError | InvalidQueryError, undefined> {\n    customLog.success(\"update views\", params.sqlViews.length)\n\n    if (cache?.runner === undefined) {\n        return TE.left(new Error(\"runner is not initialized\"));\n    }\n\n    const runner = cache.runner;\n\n    return pipe(\n        TE.tryCatch(\n            () =>\n                runner.updateViews({\n                    strictDateTimeChecking: params.strictDateTimeChecking,\n                    sqlViews: params.sqlViews\n                }),\n            RunnerError.to\n        ),\n        TE.chainW((diagnostics) => {\n            return diagnostics.length === 0\n                ? TE.right(undefined)\n                : TE.left(new InvalidQueryError(diagnostics));\n        })\n    );\n}\n\ntype EndParams = { action: \"END\" };\n\nfunction runEnd(params: Extract<WorkerParams, { action: \"END\" }>) {\n    return pipe(\n        TE.Do,\n        TE.chain(() => TE.tryCatch(() => cache?.runner.end() ?? Promise.resolve(), E.toError)),\n        TE.chain(() =>\n            TE.tryCatch(() => {\n                return cache?.server.pg.stop() ?? Promise.resolve();\n            }, E.toError)\n        )\n    );\n}\n\nrunAsWorker(async (params: WorkerParams) => {\n    const result = await handler(params);\n    return J.stringify(result);\n});\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.push(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.push(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n",null,"import { assertNever } from \"assert-never\";\nimport chalk from \"chalk\";\nimport { ErrorDiagnostic } from \"../ErrorDiagnostic\";\n\nexport function codeFrameFormatter(errorDiagnostic: ErrorDiagnostic): string {\n    let result = \"\\n\";\n\n    result += renderFileLocation(errorDiagnostic);\n    result += renderMessages(errorDiagnostic);\n    result += renderCodeFrame(errorDiagnostic);\n    result += renderEpilogue(errorDiagnostic);\n\n    return result;\n}\n\nfunction renderFileLocation(errorDiagnostic: ErrorDiagnostic): string {\n    let result = \"\";\n    result += chalk.cyanBright(errorDiagnostic.fileName);\n    switch (errorDiagnostic.span.type) {\n        case \"LineAndColRange\":\n            result += \":\" + chalk.yellowBright(`${errorDiagnostic.span.startLine}`) + \":\" + chalk.yellowBright(`${errorDiagnostic.span.startCol}`) + \":\";\n            break;\n        case \"LineAndCol\":\n            result += \":\" + chalk.yellowBright(`${errorDiagnostic.span.line}`) + \":\" + chalk.yellowBright(`${errorDiagnostic.span.col}`) + \":\";\n            break;\n        case \"File\":\n            result += \":\";\n            break;\n        default:\n            assertNever(errorDiagnostic.span);\n    }\n\n    result += \" \" + chalk.redBright.bold(\"error:\");\n    result += \"\\n\";\n    return result;\n}\n\nfunction renderMessages(errorDiagnostic: ErrorDiagnostic): string {\n    let result = \"\";\n    for (const message of errorDiagnostic.messages) {\n        const msg = message.replace(/\\n/g, \"\\n      \");\n        result += \"    * \" + msg + \"\\n\";\n    }\n    return result;\n}\n\nfunction renderCodeFrame(errorDiagnostic: ErrorDiagnostic): string {\n    let result = \"\";\n\n    let startLine: number;\n    let endLine: number;\n    switch (errorDiagnostic.span.type) {\n        case \"LineAndCol\":\n            startLine = errorDiagnostic.span.line - 1;\n            endLine = errorDiagnostic.span.line - 1;\n            break;\n        case \"LineAndColRange\":\n            startLine = errorDiagnostic.span.startLine - 1;\n            endLine = errorDiagnostic.span.endLine - 1;\n            break;\n        case \"File\":\n            return result;\n        default:\n            return assertNever(errorDiagnostic.span);\n    }\n\n    result += \"\\n\";\n\n    const lines = errorDiagnostic.fileContents.split(\"\\n\");\n\n    const LINES_MARGIN = 6;\n\n    const minLine = Math.max(0, startLine - LINES_MARGIN);\n    const maxLine = Math.min(lines.length - 1, endLine + LINES_MARGIN);\n    const padding = `${maxLine + 1}`.length;\n    for (let l = minLine; l <= maxLine; ++l) {\n        switch (errorDiagnostic.span.type) {\n            case \"LineAndCol\":\n                if (l === errorDiagnostic.span.line - 1) {\n                    const prefix = lines[l].substr(0, errorDiagnostic.span.col - 1);\n                    const target = lines[l].substr(errorDiagnostic.span.col - 1, 1);\n                    const suffix = lines[l].substr(errorDiagnostic.span.col);\n                    result += chalk.blueBright(` ${pad(`${l + 1}`, padding, \" \")} |`) + \" \" + prefix + chalk.redBright.bold(target) + suffix + \"\\n\";\n                } else {\n                    result += chalk.blueBright(` ${pad(`${l + 1}`, padding, \" \")} |`) + \" \" + lines[l] + \"\\n\";\n                }\n\n                if (l === errorDiagnostic.span.line - 1) {\n                    result += chalk.blueBright(` ${pad(\"\", padding, \" \")} |`) + \" \".repeat(errorDiagnostic.span.col) + chalk.redBright.bold(\"^\") + \"\\n\";\n                }\n                break;\n            case \"LineAndColRange\":\n                if (l > errorDiagnostic.span.startLine - 1 && l < errorDiagnostic.span.endLine - 1) {\n                    result += chalk.blueBright(` ${pad(`${l + 1}`, padding, \" \")} |`) + \" \" + chalk.redBright.bold(lines[l]) + \"\\n\";\n                    const spaces = lines[l].search(/(\\S|$)/);\n                    result += chalk.blueBright(` ${pad(\"\", padding, \" \")} |`) + \" \".repeat(spaces + 1) + chalk.redBright.bold(\"~\".repeat(lines[l].length - spaces)) + \"\\n\";\n                } else if (l === errorDiagnostic.span.startLine - 1 && l !== errorDiagnostic.span.endLine - 1) {\n                    const prefix = lines[l].substr(0, errorDiagnostic.span.startCol - 1);\n                    const suffix = lines[l].substr(errorDiagnostic.span.startCol - 1);\n                    const spaces = prefix.length;\n                    result += chalk.blueBright(` ${pad(`${l + 1}`, padding, \" \")} |`) + \" \" + prefix + chalk.redBright.bold(suffix) + \"\\n\";\n                    if (lines[l].length > spaces) {\n                        result += chalk.blueBright(` ${pad(\"\", padding, \" \")} |`) + \" \".repeat(spaces + 1) + chalk.redBright.bold(\"~\".repeat(lines[l].length - spaces)) + \"\\n\";\n                    }\n                } else if (l === errorDiagnostic.span.endLine - 1 && l !== errorDiagnostic.span.startLine - 1) {\n                    const prefix = lines[l].substr(0, errorDiagnostic.span.endCol - 1);\n                    const suffix = lines[l].substr(errorDiagnostic.span.endCol - 1);\n                    const spaces = lines[l].search(/(\\S|$)/);\n                    result += chalk.blueBright(` ${pad(`${l + 1}`, padding, \" \")} |`) + \" \" + chalk.redBright.bold(prefix) + suffix + \"\\n\";\n                    result += chalk.blueBright(` ${pad(\"\", padding, \" \")} |`) + \" \".repeat(spaces + 1) + chalk.redBright.bold(\"~\".repeat(prefix.length - spaces)) + \"\\n\";\n                } else if (l === errorDiagnostic.span.endLine - 1 && l === errorDiagnostic.span.startLine - 1) {\n                    const prefix = lines[l].substr(0, errorDiagnostic.span.startCol - 1);\n                    const target = lines[l].substring(errorDiagnostic.span.startCol - 1, errorDiagnostic.span.endCol - 1);\n                    const suffix = lines[l].substr(errorDiagnostic.span.endCol - 1);\n                    result += chalk.blueBright(` ${pad(`${l + 1}`, padding, \" \")} |`) + \" \" + prefix + chalk.redBright.bold(target) + suffix + \"\\n\";\n                    result += chalk.blueBright(` ${pad(\"\", padding, \" \")} |`) + \" \".repeat(prefix.length + 1) + chalk.redBright.bold(\"~\".repeat(lines[l].length - suffix.length - prefix.length)) + \"\\n\";\n                } else {\n                    result += chalk.blueBright(` ${pad(`${l + 1}`, padding, \" \")} |`) + \" \" + lines[l] + \"\\n\";\n                }\n                break;\n            default:\n                assertNever(errorDiagnostic.span);\n        }\n    }\n\n    result += \"\\n\";\n\n    return result;\n}\n\nfunction renderEpilogue(errorDiagnostic: ErrorDiagnostic): string {\n    let result = \"\";\n    if (errorDiagnostic.epilogue === null) {\n        return result;\n    }\n\n    const msg = errorDiagnostic.epilogue.replace(/\\n/g, \"\\n      \");\n    result += \"    * \" + msg + \"\\n\";\n\n    return result;\n}\n\nfunction pad(str: string, width: number, z: string) {\n    return str.length >= width ? str : new Array(width - str.length + 1).join(z) + str;\n}\n","import { ErrorDiagnostic } from \"../../mfsqlchecker/ErrorDiagnostic\";\nimport { codeFrameFormatter } from \"../../mfsqlchecker/formatters/codeFrameFormatter\";\n\nexport class RunnerError extends Error {\n    _tag = \"RunnerError\" as const;\n\n    constructor(message: string) {\n        super(message);\n        this.name = \"RunnerError\";\n    }\n\n    static to(error: unknown) {\n        return error instanceof RunnerError ? error : new RunnerError(`${error}`);\n    }\n\n    toJSON() {\n        return { _tag: this._tag, message: this.message };\n    }\n}\n\nexport class InvalidQueryError extends Error {\n    _tag = \"InvalidQueryError\" as const;\n    diagnostics: ErrorDiagnostic[];\n\n    constructor(diagnostics: ErrorDiagnostic[]) {\n        super(diagnostics.map(codeFrameFormatter).join(\"\\n\"));\n        this.name = \"InvalidQueryError\";\n        this.diagnostics = diagnostics;\n    }\n\n    static to(error: unknown): InvalidQueryError | Error {\n        return error instanceof InvalidQueryError ? error : new Error(`${error}`);\n    }\n\n    toJSON() {\n        return { _tag: this._tag, message: this.message, diagnostics: this.diagnostics };\n    }\n}\n","import assertNever from \"assert-never\";\nimport EmbeddedPostgres from \"embedded-postgres\";\nimport * as E from \"fp-ts/Either\";\nimport { pipe } from \"fp-ts/function\";\nimport * as TE from \"fp-ts/TaskEither\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport { Sql } from \"postgres\";\nimport { loadConfigFile, UniqueTableColumnType } from \"../../mfsqlchecker/ConfigFile\";\nimport { connectPg } from \"../../mfsqlchecker/pg_extra\";\nimport { isTestDatabaseCluster } from \"../../mfsqlchecker/pg_test_db\";\nimport { SqlCreateView } from \"../../mfsqlchecker/views\";\nimport { QueryRunner } from \"../utils/query-runner\";\nimport { RunnerError } from \"../utils/errors\";\nimport { customLog } from \"../utils/log\";\n\nexport interface PostgresConnection {\n    readonly url: string;\n    readonly databaseName: string | undefined;\n}\n\nexport interface Options {\n    readonly projectDir: string;\n    readonly migrationsDir: string | null;\n    readonly configFile: string | null;\n    readonly postgresConnection: PostgresConnection | null;\n}\n\nexport function initializeTE(params: {\n    projectDir: string;\n    configFile: string;\n    migrationsDir: string;\n    uniqueTableColumnTypes: UniqueTableColumnType[];\n    strictDateTimeChecking: boolean;\n    sqlViews: SqlCreateView[];\n}) {\n    return pipe(\n        TE.Do,\n        TE.bindW(\"options\", () => {\n            customLog.success(\"loading config file\");\n            return TE.fromEither(\n                initOptionsE({\n                    projectDir: params.projectDir,\n                    configFile: params.configFile,\n                    migrationsDir: params.migrationsDir,\n                    postgresConnection: null\n                })\n            );\n        }),\n        TE.bindW(\"server\", ({ options }) => {\n            customLog.success(\"initializing pg server\");\n            return initPgServerTE(options);\n        }),\n        TE.bindW(\"runner\", ({ server, options }) => {\n            customLog.success(\"connecting to database\");\n            return QueryRunner.ConnectTE({\n                sql: server.sql,\n                adminUrl: server.adminUrl,\n                name: server.dbName,\n                migrationsDir: options.migrationsDir\n            });\n        }),\n        TE.chainFirstW(({ runner }) => {\n            customLog.success(\"initializing database\");\n            return runner.initializeTE({\n                strictDateTimeChecking: params.strictDateTimeChecking,\n                uniqueTableColumnTypes: params.uniqueTableColumnTypes,\n                sqlViews: params.sqlViews\n            });\n        }),\n        TE.mapLeft((x) => {\n            return x instanceof Error ? new RunnerError(x.message) : x;\n        })\n    );\n}\n\nexport function initOptionsE(options: Options) {\n    if (\n        options.postgresConnection !== null &&\n        !isTestDatabaseCluster(options.postgresConnection.url)\n    ) {\n        return E.left(\n            new Error(\n                \"Database Cluster url is not a local connection or is invalid:\\n\" +\n                    options.postgresConnection.url\n            )\n        );\n    }\n\n    if (\n        options.postgresConnection !== null &&\n        !isTestDatabaseCluster(options.postgresConnection.url)\n    ) {\n        return E.left(\n            new Error(\n                \"Database Cluster url is not a local connection or is invalid:\\n\" +\n                    options.postgresConnection.url\n            )\n        );\n    }\n\n    let migrationsDir: string | null = null;\n\n    if (options.configFile !== null) {\n        const absoluteConfigFile = path.join(options.projectDir, options.configFile);\n        const config = loadConfigFile(absoluteConfigFile);\n        switch (config.type) {\n            case \"Left\": {\n                const errors = [\n                    `Error Loading config file: ${absoluteConfigFile}`,\n                    ...config.value.messages\n                ];\n                return E.left(new Error(errors.join(\"\\n\")));\n            }\n            case \"Right\":\n                if (config.value.migrationsDir !== null) {\n                    if (path.isAbsolute(config.value.migrationsDir)) {\n                        migrationsDir = config.value.migrationsDir;\n                    } else {\n                        migrationsDir = path.join(\n                            path.dirname(options.configFile),\n                            config.value.migrationsDir\n                        );\n                    }\n                }\n                break;\n            default:\n                return assertNever(config);\n        }\n    }\n    if (options.migrationsDir !== null) {\n        migrationsDir = options.migrationsDir;\n    }\n\n    if (migrationsDir === null) {\n        return E.left(\n            new Error(\"migrations-dir is missing. Must be set in config file or command line\")\n        );\n    }\n\n    return E.right({ ...options, migrationsDir });\n}\n\nexport interface PostgresOptions {\n    /** The location where the data should be persisted to. Defaults to: `./data/db` */\n    database_dir: string;\n    /** The port where the Postgres database should be listening. Defaults to:\n     *  `5432` */\n    port: number;\n    /** The username for logging into the Postgres database. Defaults to `postgres` */\n    user: string;\n    /** The password for logging into the Postgres database. Defaults to `password` */\n    password: string;\n    /** The authentication method to use when authenticating against Postgres.\n     * Defaults to `password`  */\n    auth_method: \"scram-sha-256\" | \"password\" | \"md5\";\n    /** Whether all data should be left in place when the database is shut down.\n     * Defaults to true. */\n    persistent: boolean;\n}\n\n// See: <https://en.wikipedia.org/wiki/Ephemeral_port>\nconst MIN_PORT = 49152;\nconst MAX_PORT = 65534;\n\nfunction randomPort(): number {\n    return MIN_PORT + Math.floor(Math.random() * (MAX_PORT - MIN_PORT));\n}\n\nfunction createEmbeddedPostgresTE(options: { projectDir: string }) {\n    const databaseDir = path.join(options.projectDir, \"embedded-pg\");\n    const postgresOptions: Pick<PostgresOptions, \"user\" | \"port\" | \"password\"> = {\n        user: \"postgres\",\n        password: \"password\",\n        port: randomPort()\n    };\n\n    const pg = new EmbeddedPostgres({\n        ...postgresOptions,\n        database_dir: databaseDir,\n        persistent: false\n    });\n\n    const adminUrl = `postgres://${postgresOptions.user}:${postgresOptions.password}@localhost:${postgresOptions.port}/postgres`;\n    const testDbName = \"shadow_database\";\n    const shouldInitialize = !fs.existsSync(databaseDir);\n\n    const conditionalInitializeAndStartTE = shouldInitialize\n        ? TE.tryCatch(() => pg.initialise(), E.toError)\n        : TE.right(undefined);\n\n    const recreateDatabaseTE = (sql: Sql) =>\n        pipe(\n            TE.Do,\n            TE.bind(\"dbName\", () => TE.right(sql(testDbName))),\n            TE.chainFirst(({ dbName }) => {\n                return TE.tryCatch(\n                    () => sql`DROP DATABASE IF EXISTS ${dbName} WITH (FORCE)`,\n                    E.toError\n                );\n            }),\n            TE.chainFirst(({ dbName }) =>\n                TE.tryCatch(() => sql`CREATE DATABASE ${dbName}`, E.toError)\n            )\n        );\n\n    return pipe(\n        TE.Do,\n        TE.chain(() => conditionalInitializeAndStartTE),\n        TE.chainFirstEitherKW(() => tryTerminatePostmaster(databaseDir)),\n        TE.chainFirst(() => TE.tryCatch(() => pg.start(), E.toError)),\n        TE.chainFirst(() => {\n            const x = isPostmasterAlive(databaseDir)\n                ? TE.right(undefined)\n                : TE.tryCatch(() => pg.start(), E.toError);\n\n            return x;\n        }),\n        TE.bind(\"sql\", () => TE.right(connectPg(adminUrl))),\n        TE.chainFirst(({ sql }) => {\n            return recreateDatabaseTE(sql);\n        }),\n        TE.map(({ sql }) => ({ pg, options: postgresOptions, adminUrl, dbName: testDbName, sql }))\n    );\n}\n\nfunction isPostmasterAlive(path: string) {\n    const pid = getPostmasterPid(path);\n\n    if (pid === undefined) {\n        return false;\n    }\n\n    try {\n        process.kill(pid, 0);\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction tryTerminatePostmaster(path: string) {\n    const pid = getPostmasterPid(path);\n\n    if (pid !== undefined) {\n        customLog.info(\"terminating postmaster\", pid);\n        process.kill(pid, \"SIGQUIT\");\n    }\n\n    return E.right(undefined);\n}\n\nexport function initPgServerTE(options: Options) {\n    return pipe(\n        createEmbeddedPostgresTE(options),\n        TE.map((result) => {\n            process.on(\"exit\", () => {\n                result.sql.end();\n                result.pg.stop();\n            });\n\n            return result;\n        })\n    );\n}\n\nexport function locateNearestPackageJsonDir(filePath: string): string {\n    const dir = path.dirname(filePath);\n    const packageJsonFile = path.join(dir, \"package.json\");\n    if (fs.existsSync(packageJsonFile)) {\n        return dir;\n    }\n    return locateNearestPackageJsonDir(dir);\n}\n\nfunction getPostmasterPid(filePath: string): number | undefined {\n    const pidFile = path.join(filePath, \"postmaster.pid\");\n\n    if (!fs.existsSync(pidFile)) {\n        return;\n    }\n\n    const fileContents = fs.readFileSync(pidFile, \"utf8\");\n    const lines = fileContents.split(\"\\n\");\n    const pid = parseInt(lines[0]);\n\n    if (isNaN(pid)) {\n        return;\n    }\n\n    return pid;\n}\n","import Ajv from \"ajv\";\nimport { assertNever } from \"assert-never\";\nimport fs from \"fs\";\nimport { Either } from \"./either\";\nimport { ErrorDiagnostic } from \"./ErrorDiagnostic\";\nimport { SqlType, TypeScriptType } from \"./queries\";\n\nexport interface Config {\n    migrationsDir: string | null;\n    postgresVersion: string | null;\n    colTypesFormat: ColTypesFormat;\n    strictDateTimeChecking: boolean;\n    customSqlTypeMappings: CustomSqlTypeMapping[];\n    uniqueTableColumnTypes: UniqueTableColumnType[];\n}\n\nexport interface ColTypesFormat {\n    includeRegionMarker: boolean;\n    delimiter: \",\" | \";\";\n}\n\nexport const defaultColTypesFormat: ColTypesFormat = {\n    includeRegionMarker: false,\n    delimiter: \",\"\n};\n\nexport interface CustomSqlTypeMapping {\n    typeScriptTypeName: TypeScriptType;\n    sqlTypeName: SqlType;\n}\n\nexport interface UniqueTableColumnType {\n    typeScriptTypeName: TypeScriptType;\n    tableName: string;\n    columnName: string;\n}\n\nfunction normalizeConfigFile(configFile: ConfigFile): Config {\n    return {\n        migrationsDir: configFile.migrationsDir !== undefined ? configFile.migrationsDir : null,\n        postgresVersion: configFile.postgresVersion !== undefined ? configFile.postgresVersion : null,\n        colTypesFormat: configFile.colTypesFormat !== undefined ? toColTypesFormat(configFile.colTypesFormat) : defaultColTypesFormat,\n        strictDateTimeChecking: configFile.strictDateTimeChecking === true,\n        customSqlTypeMappings: configFile.customSqlTypeMappings !== undefined ? configFile.customSqlTypeMappings.map(toCustomSqlTypeMapping) : [],\n        uniqueTableColumnTypes: configFile.uniqueTableColumnTypes !== undefined ? configFile.uniqueTableColumnTypes.map(toUniqueTableColumnType) : []\n    };\n}\n\n// Important: If you change the \"ConfigFile\" interface then update the\n// `configFileSchema` below\ninterface ConfigFile {\n    migrationsDir?: string;\n    postgresVersion?: string;\n    colTypesFormat?: ConfigColTypesFormat;\n    strictDateTimeChecking?: boolean;\n    customSqlTypeMappings?: ConfigCustomSqlTypeMapping[];\n    uniqueTableColumnTypes?: ConfigUniqueTableColumnType[];\n}\n\ninterface ConfigColTypesFormat {\n    includeRegionMarker?: boolean;\n    delimiter?: \",\" | \";\";\n}\n\nfunction toColTypesFormat(v: ConfigColTypesFormat): ColTypesFormat {\n    return {\n        includeRegionMarker: v.includeRegionMarker !== undefined ? v.includeRegionMarker : defaultColTypesFormat.includeRegionMarker,\n        delimiter: v.delimiter !== undefined ? v.delimiter : defaultColTypesFormat.delimiter\n    };\n}\n\ninterface ConfigCustomSqlTypeMapping {\n    typeScriptTypeName: string;\n    sqlTypeName: string;\n}\n\nfunction toCustomSqlTypeMapping(v: ConfigCustomSqlTypeMapping): CustomSqlTypeMapping {\n    return {\n        sqlTypeName: SqlType.wrap(v.sqlTypeName),\n        typeScriptTypeName: TypeScriptType.wrap(v.typeScriptTypeName)\n    };\n}\n\ninterface ConfigUniqueTableColumnType {\n    typeScriptTypeName: string;\n    tableName: string;\n    columnName: string;\n}\n\nfunction toUniqueTableColumnType(v: ConfigUniqueTableColumnType): UniqueTableColumnType {\n    return {\n        typeScriptTypeName: TypeScriptType.wrap(v.typeScriptTypeName),\n        tableName: v.tableName,\n        columnName: v.columnName\n    };\n}\n\nexport function equalsUniqueTableColumnType(lhs: UniqueTableColumnType, rhs: UniqueTableColumnType) {\n    return lhs.typeScriptTypeName === rhs.typeScriptTypeName &&\n        lhs.tableName === rhs.tableName &&\n        lhs.columnName === rhs.columnName;\n}\n\nexport function equalsUniqueTableColumnTypes(lhs: UniqueTableColumnType[], rhs: UniqueTableColumnType[]) {\n    if (lhs.length !== rhs.length) {\n        return false;\n    }\n\n    for (let i = 0; i < lhs.length; ++i) {\n        if (!equalsUniqueTableColumnType(lhs[i], rhs[i])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport function sqlUniqueTypeName(tableName: string, columnName: string): string {\n    return tableName + \"(\" + columnName + \")\";\n}\n\nexport function makeUniqueColumnTypes(uniqueTableColumnTypes: UniqueTableColumnType[]): Map<SqlType, TypeScriptType> {\n    const result = new Map<SqlType, TypeScriptType>();\n\n    for (const uniqueTableColumnType of uniqueTableColumnTypes) {\n        const sqlTypeName = sqlUniqueTypeName(uniqueTableColumnType.tableName, uniqueTableColumnType.columnName);\n        result.set(SqlType.wrap(sqlTypeName), uniqueTableColumnType.typeScriptTypeName);\n    }\n\n    return result;\n}\n\nexport function loadConfigFile(fileName: string): Either<ErrorDiagnostic, Config> {\n    let fileContents: string;\n    try {\n        fileContents = fs.readFileSync(fileName, { encoding: \"utf8\" });\n    } catch (err) {\n        return {\n            type: \"Left\",\n            value: {\n                fileName: fileName,\n                fileContents: \"\",\n                span: {\n                    type: \"File\"\n                },\n                messages: [`Error opening file ${fileName}`, err.message],\n                epilogue: null,\n                quickFix: null\n            }\n        };\n    }\n\n    const mbConfigFile = parseConfigFile(fileName, fileContents);\n\n    switch (mbConfigFile.type) {\n        case \"Left\":\n            return mbConfigFile;\n        case \"Right\":\n            return {\n                type: \"Right\",\n                value: normalizeConfigFile(mbConfigFile.value)\n            };\n        default:\n            return assertNever(mbConfigFile);\n    }\n}\n\nconst ajv = new Ajv();\n// tslint:disable-next-line:no-var-requires no-require-imports no-submodule-imports\najv.addMetaSchema(require(\"ajv/lib/refs/json-schema-draft-06.json\"));\n\nexport function parseConfigFile(fileName: string, fileContents: string): Either<ErrorDiagnostic, ConfigFile> {\n    function error<T>(messages: string[]): Either<ErrorDiagnostic, T> {\n        return {\n            type: \"Left\", value: {\n                fileContents: fileContents,\n                fileName: fileName,\n                span: {\n                    type: \"File\"\n                },\n                messages: messages,\n                epilogue: null,\n                quickFix: null\n            }\n        };\n    }\n\n    let json: any;\n    try {\n        json = JSON.parse(fileContents);\n    } catch (err) {\n        return error([\"JSON Parser Error\", err.message]);\n    }\n\n    const valid = ajv.validate(configFileSchema, json);\n    if (!valid) {\n        if (ajv.errors === null || ajv.errors === undefined) {\n            throw new Error(\"The Impossible Happened\");\n        }\n        return error(ajv.errors.map(e => JSON.stringify(e, null, 2)));\n    }\n\n    return {\n        type: \"Right\",\n        value: json\n    };\n}\n\n// This schema was auto-generated using this Visual Studio Code extension:\n// <https://marketplace.visualstudio.com/items?itemName=marcoq.vscode-typescript-to-json-schema>\nconst configFileSchema = {\n    \"$schema\": \"http://json-schema.org/draft-06/schema#\",\n    \"definitions\": {\n        \"ConfigFile\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"migrationsDir\": {\n                    \"type\": \"string\"\n                },\n                \"postgresVersion\": {\n                    \"type\": \"string\"\n                },\n                \"colTypesFormat\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"includeRegionMarker\": {\n                            \"type\": \"boolean\"\n                        },\n                        \"delimiter\": {\n                            \"type\": \"string\",\n                            \"enum\": [\n                                \",\",\n                                \";\"\n                            ]\n                        }\n                    },\n                    \"additionalProperties\": false\n                },\n                \"strictDateTimeChecking\": {\n                    \"type\": \"boolean\"\n                },\n                \"customSqlTypeMappings\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"typeScriptTypeName\": {\n                                \"type\": \"string\"\n                            },\n                            \"sqlTypeName\": {\n                                \"type\": \"string\"\n                            }\n                        },\n                        \"required\": [\n                            \"typeScriptTypeName\",\n                            \"sqlTypeName\"\n                        ],\n                        \"additionalProperties\": false\n                    }\n                },\n                \"uniqueTableColumnTypes\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"typeScriptTypeName\": {\n                                \"type\": \"string\"\n                            },\n                            \"tableName\": {\n                                \"type\": \"string\"\n                            },\n                            \"columnName\": {\n                                \"type\": \"string\"\n                            }\n                        },\n                        \"required\": [\n                            \"typeScriptTypeName\",\n                            \"tableName\",\n                            \"columnName\"\n                        ],\n                        \"additionalProperties\": false\n                    }\n                }\n            },\n            \"additionalProperties\": false\n        }\n    },\n    \"$ref\": \"#/definitions/ConfigFile\"\n};\n","import { assertNever } from \"assert-never\";\nimport chalk from \"chalk\";\nimport * as ts from \"typescript\";\nimport { Either } from \"./either\";\nimport { ErrorDiagnostic, nodeErrorDiagnostic, SrcSpan } from \"./ErrorDiagnostic\";\nimport { escapeIdentifier } from \"./pg_extra\";\nimport { QualifiedSqlViewName, resolveViewIdentifier, tryTypeSqlFrag } from \"./views\";\n\nexport interface QueryCallExpression {\n    readonly fileName: string;\n    readonly fileContents: string;\n\n    /**\n     * If `null` then we have a type parameter. Otherwise contains the name of\n     * the method name that was called\n     */\n    readonly queryMethodName: string | null;\n\n    readonly typeArgument: ts.TypeNode | null;\n    readonly typeArgumentSpan: SrcSpan;\n\n    /**\n     * Number of space characters that the line is indented (4, 8, 12, etc...)\n     *\n     * Currently we only supported 4-space indentation style\n     */\n    readonly indentLevel: number;\n\n    readonly queryFragments: QueryCallExpression.QueryFragment[];\n}\n\nexport namespace QueryCallExpression {\n    export type QueryFragment\n        = { readonly type: \"StringFragment\"; readonly text: string; readonly sourcePosStart: number }\n        | { readonly type: \"Expression\"; readonly exp: ts.Expression };\n}\n\nexport interface InsertManyExpression {\n    readonly fileName: string;\n    readonly fileContents: string;\n\n    /**\n     * If `null` then we have a type parameter. Otherwise contains the name of\n     * the method name that was called\n     */\n    readonly queryMethodName: string | null;\n\n    readonly typeArgument: ts.TypeNode | null;\n    readonly typeArgumentSpan: SrcSpan;\n    readonly tableName: string;\n    readonly tableNameExprSpan: SrcSpan;\n    readonly insertExprSpan: SrcSpan;\n\n    /**\n     * Number of space characters that the line is indented (4, 8, 12, etc...)\n     *\n     * Currently we only supported 4-space indentation style\n     */\n    readonly indentLevel: number;\n\n    readonly insertColumns: Map<string, [TypeScriptType, boolean]>;\n    readonly epilougeFragments: QueryCallExpression.QueryFragment[];\n}\n\nexport type ResolvedQuery\n    = { type: \"ResolvedSelect\"; value: ResolvedSelect }\n    | { type: \"ResolvedInsert\"; value: ResolvedInsert };\n\nexport interface ResolvedSelect {\n    readonly fileName: string;\n    readonly fileContents: string;\n\n    readonly text: string;\n\n    readonly sourceMap: [number, number, number][];\n\n    /**\n     * `null` means that the typeArgument was explicitly declared as `any`\n     * indicating that we are requested not to type-check the return column\n     * types\n     */\n    readonly colTypes: Map<string, [ColNullability, TypeScriptType]> | null;\n\n    /**\n     * If `null` then we have a type parameter. Otherwise contains the name of\n     * the method name that was called\n     */\n    readonly queryMethodName: string | null;\n\n    readonly colTypeSpan: SrcSpan;\n\n    /**\n     * Number of space characters that the line is indented (4, 8, 12, etc...)\n     *\n     * Currently we only supported 4-space indentation style\n     */\n    readonly indentLevel: number;\n\n    /**\n     * Errors that were discovered that should be reported\n     */\n    readonly errors: ErrorDiagnostic[];\n}\n\nexport interface ResolvedInsert {\n    readonly fileName: string;\n    readonly fileContents: string;\n\n    readonly tableName: string;\n    readonly insertColumns: Map<string, [TypeScriptType, boolean]>;\n\n    readonly text: string;\n\n    readonly sourceMap: [number, number, number][];\n\n    /**\n     * `null` means that the typeArgument was explicitly declared as `any`\n     * indicating that we are requested not to type-check the return column\n     * types\n     */\n    readonly colTypes: Map<string, [ColNullability, TypeScriptType]> | null;\n\n    /**\n     * If `null` then we have a type parameter. Otherwise contains the name of\n     * the method name that was called\n     */\n    readonly queryMethodName: string | null;\n\n    readonly colTypeSpan: SrcSpan;\n\n    /**\n     * Number of space characters that the line is indented (4, 8, 12, etc...)\n     *\n     * Currently we only supported 4-space indentation style\n     */\n    readonly indentLevel: number;\n\n    readonly tableNameExprSpan: SrcSpan;\n    readonly insertExprSpan: SrcSpan;\n\n    /**\n     * Errors that were discovered that should be reported\n     */\n    readonly errors: ErrorDiagnostic[];\n}\n\nfunction buildQueryFragments(sqlExp: ts.Expression): Either<ErrorDiagnostic[], QueryCallExpression.QueryFragment[]> {\n    if (!ts.isTaggedTemplateExpression(sqlExp)) {\n        return {\n            type: \"Left\",\n            value: [\n                nodeErrorDiagnostic(sqlExp, \"Argument must be a Tagged Template Expression\")\n            ]\n        };\n    }\n\n    // Explanation for strange sourcePosStart formula below:\n    //\n    // When encountering a template string literal, if there is whitespace\n    // before the opening quote (`) then the \"pos\" starts at the beginning of\n    // the whitespace. So instead of relying on \"pos\", we use a formula that\n    // guarantees that we get the position of the start of the opening quote\n    // (`) char, by going backwards from the end\n\n    if (ts.isNoSubstitutionTemplateLiteral(sqlExp.template)) {\n        return {\n            type: \"Right\",\n            value: [{\n                type: \"StringFragment\",\n                text: sqlExp.template.text,\n                sourcePosStart: sqlExp.template.end - sqlExp.template.text.length\n            }]\n        };\n    } else if (ts.isTemplateExpression(sqlExp.template)) {\n        const fragments: QueryCallExpression.QueryFragment[] = [];\n        fragments.push({\n            type: \"StringFragment\",\n            text: sqlExp.template.head.text,\n            sourcePosStart: sqlExp.template.head.end - sqlExp.template.head.text.length - 1\n        });\n\n        for (let i = 0; i < sqlExp.template.templateSpans.length; ++i) {\n            const span = sqlExp.template.templateSpans[i];\n            fragments.push({ type: \"Expression\", exp: span.expression });\n            fragments.push({\n                type: \"StringFragment\",\n                text: span.literal.text,\n                sourcePosStart: span.literal.end - span.literal.text.length\n                    - (i < sqlExp.template.templateSpans.length - 1 ? 1 : 0) // The end of the last template span is different from the others\n            });\n        }\n\n        return {\n            type: \"Right\",\n            value: fragments\n        };\n    } else {\n        return assertNever(sqlExp.template);\n    }\n}\n\nfunction nodeLineAndColSpan(sourceFile: ts.SourceFile, node: ts.Node): SrcSpan.LineAndColRange {\n    const start = sourceFile.getLineAndCharacterOfPosition(node.pos);\n    const end = sourceFile.getLineAndCharacterOfPosition(node.end);\n    return {\n        type: \"LineAndColRange\",\n        startLine: start.line + 1,\n        startCol: start.character + 1,\n        endLine: end.line + 1,\n        endCol: end.character + 1\n    };\n}\n\nfunction buildTypeArgumentData(sourceFile: ts.SourceFile, node: ts.CallExpression): [ts.TypeNode | null, SrcSpan] {\n    if (node.typeArguments === undefined || node.typeArguments.length === 0) {\n        return [null, nodeLineAndColSpan(sourceFile, (<any>node.expression).name)];\n    } else {\n        const start = sourceFile.getLineAndCharacterOfPosition(node.expression.end);\n        const end = sourceFile.getLineAndCharacterOfPosition(node.arguments.pos - 1);\n\n        const span: SrcSpan.LineAndColRange = {\n            type: \"LineAndColRange\",\n            startLine: start.line + 1,\n            startCol: start.character + 1,\n            endLine: end.line + 1,\n            endCol: end.character + 1\n        };\n\n        return [node.typeArguments[0], span];\n    }\n}\n\nfunction getIndentLevel(sourceFile: ts.SourceFile, node: ts.Node): number {\n    const sourceFileText = sourceFile.getFullText();\n    const nlPos = sourceFileText.lastIndexOf(\"\\n\", node.pos);\n    const lineText = sourceFileText.substring(nlPos + 1, node.pos);\n    const indentLevel = lineText.search(/\\S/);\n\n    // This happens if the node starts at the beginning of the line\n    if (indentLevel === -1) {\n        const pos = node.end - node.getText().length;\n        const nlPos2 = sourceFileText.lastIndexOf(\"\\n\", pos);\n        const lineText2 = sourceFileText.substring(nlPos2 + 1, pos);\n        return lineText2.length;\n    }\n\n    return indentLevel;\n}\n\n/**\n * Expects a node that looks something like this:\n *\n *     query<{name: string}>(conn, sql`SELECT age FROM person WHERE id = ${theId}`);\n *\n * @param node Must be a call expression to the \"query\" function (from the sql\n * checker lib)\n */\nexport function buildQueryCallExpression(methodName: string, node: ts.CallExpression): Either<ErrorDiagnostic[], QueryCallExpression> {\n    if (node.arguments.length < 1) {\n        // The TypeScript typechecker will catch this error, so we don't need\n        // to emit our own error message\n        return {\n            type: \"Left\",\n            value: []\n        };\n    }\n\n    const sourceFile = node.getSourceFile();\n\n    const [typeArgument, typeArgumentSpan] = buildTypeArgumentData(sourceFile, node);\n\n    const sqlExp: ts.Expression = node.arguments[0];\n    const queryFragments = buildQueryFragments(sqlExp);\n    switch (queryFragments.type) {\n        case \"Left\":\n            return {\n                type: \"Left\",\n                value: queryFragments.value\n            };\n        case \"Right\":\n            return {\n                type: \"Right\",\n                value: {\n                    fileName: sourceFile.fileName,\n                    fileContents: sourceFile.text,\n                    queryMethodName: typeArgument === null ? methodName : null,\n                    typeArgument: typeArgument,\n                    typeArgumentSpan: typeArgumentSpan,\n                    indentLevel: getIndentLevel(sourceFile, node),\n                    queryFragments: queryFragments.value\n                }\n            };\n        default:\n            return assertNever(queryFragments);\n    }\n}\n\nexport function buildInsertCallExpression(checker: ts.TypeChecker, methodName: string, node: ts.CallExpression): Either<ErrorDiagnostic[], InsertManyExpression> {\n    if (node.arguments.length < 2) {\n        // The TypeScript typechecker will catch this error, so we don't need\n        // to emit our own error message\n        return {\n            type: \"Left\",\n            value: []\n        };\n    }\n\n    const tableNameArg = node.arguments[0];\n    if (!(ts.isStringLiteral(tableNameArg) || ts.isNoSubstitutionTemplateLiteral(tableNameArg))) {\n        return {\n            type: \"Left\",\n            value: [nodeErrorDiagnostic(tableNameArg, \"Argument must be a String Literal\")]\n        };\n    }\n\n    const valuesArg = node.arguments[1];\n    const valuesType = checker.getTypeAtLocation(valuesArg);\n\n    if (getArrayType(valuesType) !== null) {\n        return {\n            type: \"Left\",\n            value: [nodeErrorDiagnostic(valuesArg, \"Argument must not be an array (must be a single object)\")]\n        };\n    }\n    const valuesElemType = valuesType;\n\n    const sourceFile = node.getSourceFile();\n\n    const [typeArgument, typeArgumentSpan] = buildTypeArgumentData(sourceFile, node);\n\n    let epilougeFragments: QueryCallExpression.QueryFragment[];\n    if (node.arguments.length >= 3) {\n        const epilougeSqlExp: ts.Expression = node.arguments[2];\n        const queryFragments = buildQueryFragments(epilougeSqlExp);\n        switch (queryFragments.type) {\n            case \"Left\":\n                return {\n                    type: \"Left\",\n                    value: queryFragments.value\n                };\n            case \"Right\":\n                epilougeFragments = queryFragments.value;\n                break;\n            default:\n                return assertNever(queryFragments);\n        }\n    } else {\n        epilougeFragments = [];\n    }\n\n    const objectFieldTypes = getObjectFieldTypes(checker, valuesElemType);\n    switch (objectFieldTypes.type) {\n        case \"Left\":\n            return {\n                type: \"Left\",\n                value: [nodeErrorDiagnostic(valuesArg, objectFieldTypes.value)]\n            };\n        case \"Right\":\n            return {\n                type: \"Right\",\n                value: {\n                    fileName: sourceFile.fileName,\n                    fileContents: sourceFile.text,\n                    queryMethodName: typeArgument === null ? methodName : null,\n                    typeArgument: typeArgument,\n                    typeArgumentSpan: typeArgumentSpan,\n                    tableName: tableNameArg.text,\n                    tableNameExprSpan: nodeLineAndColSpan(sourceFile, tableNameArg),\n                    insertExprSpan: nodeLineAndColSpan(sourceFile, valuesArg),\n                    indentLevel: getIndentLevel(sourceFile, node),\n                    insertColumns: objectFieldTypes.value,\n                    epilougeFragments: epilougeFragments\n                }\n            };\n        default:\n            return assertNever(objectFieldTypes);\n    }\n}\n\nfunction buildInsertManyCallExpression(checker: ts.TypeChecker, methodName: string, node: ts.CallExpression): Either<ErrorDiagnostic[], InsertManyExpression> {\n    if (node.arguments.length < 2) {\n        // The TypeScript typechecker will catch this error, so we don't need\n        // to emit our own error message\n        return {\n            type: \"Left\",\n            value: []\n        };\n    }\n\n    const tableNameArg = node.arguments[0];\n    if (!(ts.isStringLiteral(tableNameArg) || ts.isNoSubstitutionTemplateLiteral(tableNameArg))) {\n        return {\n            type: \"Left\",\n            value: [nodeErrorDiagnostic(tableNameArg, \"Argument must be a String Literal\")]\n        };\n    }\n\n    const valuesArg = node.arguments[1];\n    const valuesType = checker.getTypeAtLocation(valuesArg);\n\n    const valuesElemType = getArrayType(valuesType);\n\n    if (valuesElemType === null) {\n        // The \"values\" argument is not an array. The TypeScript typechecker\n        // will catch this error, so we don't need to emit our own error\n        // message\n        return {\n            type: \"Left\",\n            value: []\n        };\n    }\n\n    const sourceFile = node.getSourceFile();\n\n    const [typeArgument, typeArgumentSpan] = buildTypeArgumentData(sourceFile, node);\n\n    let epilougeFragments: QueryCallExpression.QueryFragment[];\n    if (node.arguments.length >= 3) {\n        const epilougeSqlExp: ts.Expression = node.arguments[2];\n        const queryFragments = buildQueryFragments(epilougeSqlExp);\n        switch (queryFragments.type) {\n            case \"Left\":\n                return {\n                    type: \"Left\",\n                    value: queryFragments.value\n                };\n            case \"Right\":\n                epilougeFragments = queryFragments.value;\n                break;\n            default:\n                return assertNever(queryFragments);\n        }\n    } else {\n        epilougeFragments = [];\n    }\n\n    const objectFieldTypes = getObjectFieldTypes(checker, valuesElemType);\n    switch (objectFieldTypes.type) {\n        case \"Left\":\n            return {\n                type: \"Left\",\n                value: [nodeErrorDiagnostic(valuesArg, objectFieldTypes.value)]\n            };\n        case \"Right\":\n            return {\n                type: \"Right\",\n                value: {\n                    fileName: sourceFile.fileName,\n                    fileContents: sourceFile.text,\n                    queryMethodName: typeArgument === null ? methodName : null,\n                    typeArgument: typeArgument,\n                    typeArgumentSpan: typeArgumentSpan,\n                    tableName: tableNameArg.text,\n                    tableNameExprSpan: nodeLineAndColSpan(sourceFile, tableNameArg),\n                    insertExprSpan: nodeLineAndColSpan(sourceFile, valuesArg),\n                    indentLevel: getIndentLevel(sourceFile, node),\n                    insertColumns: objectFieldTypes.value,\n                    epilougeFragments: epilougeFragments\n                }\n            };\n        default:\n            return assertNever(objectFieldTypes);\n    }\n}\n\nexport function findAllQueryCalls(typeScriptUniqueColumnTypes: Map<TypeScriptType, SqlType>, projectDir: string, checker: ts.TypeChecker, lookupViewName: (qualifiedSqlViewName: QualifiedSqlViewName) => string | undefined, sourceFile: ts.SourceFile): [ResolvedQuery[], ErrorDiagnostic[]] {\n    const resolvedQueries: ResolvedQuery[] = [];\n    const errorDiagnostics: ErrorDiagnostic[] = [];\n\n    function visit(node: ts.Node) {\n        if (ts.isCallExpression(node)) {\n            if (ts.isPropertyAccessExpression(node.expression)) {\n                if (ts.isIdentifier(node.expression.name)) {\n                    const queryMethodNames = [\"query\", \"queryOne\", \"queryOneOrNone\"];\n                    const insertMethodNames = [\"insert\", \"insertMaybe\"];\n                    if (queryMethodNames.indexOf(node.expression.name.text) >= 0) {\n                        const type = checker.getTypeAtLocation(node.expression.expression);\n                        if (type.getProperty(\"MfConnectionTypeTag\") !== undefined) {\n                            const query = buildQueryCallExpression(node.expression.name.text, node);\n                            switch (query.type) {\n                                case \"Left\":\n                                    for (const e of query.value) {\n                                        errorDiagnostics.push(e);\n                                    }\n                                    break;\n                                case \"Right\":\n                                    const resolvedQuery = resolveQueryFragment(typeScriptUniqueColumnTypes, projectDir, checker, query.value, lookupViewName);\n                                    switch (resolvedQuery.type) {\n                                        case \"Left\":\n                                            for (const e of resolvedQuery.value) {\n                                                errorDiagnostics.push(e);\n                                            }\n                                            break;\n                                        case \"Right\":\n                                            resolvedQueries.push({\n                                                type: \"ResolvedSelect\",\n                                                value: resolvedQuery.value\n                                            });\n                                            break;\n                                        default:\n                                            assertNever(resolvedQuery);\n                                    }\n                                    break;\n                                default:\n                                    assertNever(query);\n                            }\n                        }\n                    } else if (node.expression.name.text === \"insertMany\") {\n                        const type = checker.getTypeAtLocation(node.expression.expression);\n                        if (type.getProperty(\"MfConnectionTypeTag\") !== undefined) {\n                            const query = buildInsertManyCallExpression(checker, node.expression.name.text, node);\n                            switch (query.type) {\n                                case \"Left\":\n                                    for (const e of query.value) {\n                                        errorDiagnostics.push(e);\n                                    }\n                                    break;\n                                case \"Right\":\n                                    const resolvedQuery = resolveInsertMany(typeScriptUniqueColumnTypes, projectDir, checker, query.value, lookupViewName);\n                                    switch (resolvedQuery.type) {\n                                        case \"Left\":\n                                            for (const e of resolvedQuery.value) {\n                                                errorDiagnostics.push(e);\n                                            }\n                                            break;\n                                        case \"Right\":\n                                            resolvedQueries.push({\n                                                type: \"ResolvedInsert\",\n                                                value: resolvedQuery.value\n                                            });\n                                            break;\n                                        default:\n                                            assertNever(resolvedQuery);\n                                    }\n                                    break;\n                                default:\n                                    assertNever(query);\n                            }\n                        }\n                    } else if (insertMethodNames.indexOf(node.expression.name.text) >= 0) {\n                        const type = checker.getTypeAtLocation(node.expression.expression);\n                        if (type.getProperty(\"MfConnectionTypeTag\") !== undefined) {\n                            const query = buildInsertCallExpression(checker, node.expression.name.text, node);\n                            switch (query.type) {\n                                case \"Left\":\n                                    for (const e of query.value) {\n                                        errorDiagnostics.push(e);\n                                    }\n                                    break;\n                                case \"Right\":\n                                    const resolvedQuery = resolveInsertMany(typeScriptUniqueColumnTypes, projectDir, checker, query.value, lookupViewName);\n                                    switch (resolvedQuery.type) {\n                                        case \"Left\":\n                                            for (const e of resolvedQuery.value) {\n                                                errorDiagnostics.push(e);\n                                            }\n                                            break;\n                                        case \"Right\":\n                                            resolvedQueries.push({\n                                                type: \"ResolvedInsert\",\n                                                value: resolvedQuery.value\n                                            });\n                                            break;\n                                        default:\n                                            assertNever(resolvedQuery);\n                                    }\n                                    break;\n                                default:\n                                    assertNever(query);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        ts.forEachChild(node, visit);\n    }\n\n    ts.forEachChild(sourceFile, visit);\n\n    return [resolvedQueries, errorDiagnostics];\n}\n\nfunction isTypeSqlView(type: ts.Type): boolean {\n    // TODO This should be more robust: make sure that it is the \"SqlView\"\n    // type defined in the sql library (and not some other user-defined type\n    // that happens to have the same name)\n\n    const symbol: ts.Symbol | undefined = <ts.Symbol | undefined>type.symbol;\n\n    if (symbol === undefined) {\n        return false;\n    }\n    return symbol.name === \"SqlView\";\n}\n\nexport function isNullableType(type: ts.Type): boolean {\n    if (!type.isUnion()) {\n        return type.flags === ts.TypeFlags.Null;\n    }\n\n    for (const typ of type.types) {\n        if (typ.flags === ts.TypeFlags.Null) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Convert a type of the form `(T | null)` -> `T`\n *\n * Returns the original type if it is not of that exact form.\n */\nexport function nonNullType(type: ts.Type): ts.Type {\n    if (!type.isUnion()) {\n        return type;\n    }\n\n    // We can only handle a holy union of exactly two types.\n    if (type.types.length !== 2) {\n        return type;\n    }\n\n    // Check which of the sides is `null` (if any), and return the other side\n    if (type.types[0].flags === ts.TypeFlags.Null) {\n        return type.types[1];\n    } else if (type.types[1].flags === ts.TypeFlags.Null) {\n        return type.types[0];\n    } else {\n        return type;\n    }\n}\n\nexport class TypeScriptType {\n    static wrap(val: string): TypeScriptType {\n        return val as any;\n    }\n\n    static unwrap(val: TypeScriptType): string {\n        return val as any;\n    }\n\n    protected _dummy: TypeScriptType[];\n}\n\nexport class SqlType {\n    static wrap(val: string): SqlType {\n        return val as any;\n    }\n\n    static unwrap(val: SqlType): string {\n        return val as any;\n    }\n\n    protected _dummy: SqlType[];\n}\n\nexport const enum ColNullability {\n    REQ,\n    OPT\n}\n\nfunction getArrayType(type: ts.Type): ts.Type | null {\n    if (type.symbol.name === \"Array\") {\n        if ((<any>type).typeArguments !== undefined) {\n            const typeArguments: ReadonlyArray<ts.Type> = (<any>type).typeArguments;\n            if (typeArguments.length === 1) {\n                return typeArguments[0];\n            }\n        }\n    }\n\n    return null;\n}\n\nfunction getObjectFieldTypes(checker: ts.TypeChecker, type: ts.Type): Either<string, Map<string, [TypeScriptType, boolean]>> {\n    const errors: string[] = [];\n    const result = new Map<string, [TypeScriptType, boolean]>();\n\n    const addResult = (fieldName: string, typ: ts.Type) => {\n        if ((typ.flags & ts.TypeFlags.StringLiteral) !== 0 || // tslint:disable-line:no-bitwise\n            isUnionOfStringLiterals(typ)) {\n            result.set(fieldName, [TypeScriptType.wrap(\"string\"), !isNullableType(typ)]);\n        } else if ((typ.flags & ts.TypeFlags.BooleanLiteral) !== 0 || // tslint:disable-line:no-bitwise\n            isUnionOfBooleanLiterals(typ)) {\n            result.set(fieldName, [TypeScriptType.wrap(\"boolean\"), !isNullableType(typ)]);\n        } else {\n            result.set(fieldName, [TypeScriptType.wrap(checker.typeToString(nonNullType(typ))), !isNullableType(typ)]);\n        }\n    };\n\n    type.getProperties().forEach((value) => {\n        if (value.valueDeclaration === undefined) {\n            throw new Error(\"valueDeclaration is undefined\");\n        }\n\n        addResult(value.name, checker.getTypeAtLocation(value.valueDeclaration));\n\n    });\n\n    if (errors.length > 0) {\n        return {\n            type: \"Left\",\n            value: \"Values array argument element type has invalid fields:\\n\" + errors.join(\"\\n\")\n        };\n    } else {\n        return {\n            type: \"Right\",\n            value: result\n        };\n    }\n}\n\n/**\n * Checks if the type is something like: \"Yes\" | \"No\" | \"Maybe\"\n *\n * One of the union members is also allowed to be `null`: \"High\" | \"Low\" | null\n */\nfunction isUnionOfStringLiterals(type: ts.Type): boolean {\n    if ((type.flags & ts.TypeFlags.Union) === 0) { // tslint:disable-line:no-bitwise\n        return false;\n    }\n\n    const types: ReadonlyArray<ts.Type> = (<any>type).types;\n    for (const unionType of types) {\n        if (!((unionType.flags & ts.TypeFlags.String) !== 0 || // tslint:disable-line:no-bitwise\n            (unionType.flags & ts.TypeFlags.StringLiteral) !== 0 || // tslint:disable-line:no-bitwise\n            (unionType.flags & ts.TypeFlags.Null) !== 0)) { // tslint:disable-line:no-bitwise\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks if the type is something like: \"true | false\".\n *\n * One of the union members is also allowed to be `null`: \"true | false |\n * null\"\n *\n * We would expect TypeScript to report the above forms as \"boolean\" and\n * \"boolean | null\", but sometimes they do look this like\n */\nfunction isUnionOfBooleanLiterals(type: ts.Type): boolean {\n    if ((type.flags & ts.TypeFlags.Union) === 0) { // tslint:disable-line:no-bitwise\n        return false;\n    }\n\n    const types: ReadonlyArray<ts.Type> = (<any>type).types;\n    for (const unionType of types) {\n        if (!((unionType.flags & ts.TypeFlags.Boolean) !== 0 || // tslint:disable-line:no-bitwise\n            (unionType.flags & ts.TypeFlags.BooleanLiteral) !== 0 || // tslint:disable-line:no-bitwise\n            (unionType.flags & ts.TypeFlags.Null) !== 0)) { // tslint:disable-line:no-bitwise\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * @returns Empty string means SQL \"NULL\" literal. `null` means an error\n */\nfunction typescriptTypeToSqlType(typeScriptUniqueColumnTypes: Map<TypeScriptType, SqlType>, type: ts.Type): SqlType | null {\n    if (type.flags === ts.TypeFlags.Any) {\n        // TODO Would be better to return some special value here, in order to\n        // give a nicer error message (instead of getting the error from\n        // postgresql 'type \"ts_any\" does not exist)\n        return SqlType.wrap(\"ts_any\");\n    } else if (type.flags === ts.TypeFlags.Null) {\n        return SqlType.wrap(\"\");\n    } else if ((type.flags & ts.TypeFlags.Never) !== 0) { // tslint:disable-line:no-bitwise\n        return null;\n    } else if ((type.flags & ts.TypeFlags.Boolean) !== 0 || (type.flags & ts.TypeFlags.BooleanLiteral) !== 0) { // tslint:disable-line:no-bitwise\n        return SqlType.wrap(\"bool\");\n    } else if (isUnionOfBooleanLiterals(type)) {\n        return SqlType.wrap(\"bool\");\n    } else if ((type.flags & ts.TypeFlags.Number) !== 0 || (type.flags & ts.TypeFlags.NumberLiteral) !== 0) { // tslint:disable-line:no-bitwise\n        return SqlType.wrap(\"int4\");\n    } else if ((type.flags & ts.TypeFlags.String) !== 0 || (type.flags & ts.TypeFlags.StringLiteral) !== 0) { // tslint:disable-line:no-bitwise\n        return SqlType.wrap(\"text\");\n    } else if (isUnionOfStringLiterals(type)) {\n        return SqlType.wrap(\"text\");\n    }\n\n    if ((type.flags & ts.TypeFlags.Union) !== 0) { // tslint:disable-line:no-bitwise\n        return null;\n    }\n\n    if ((<any>type).symbol === undefined) {\n        throw new Error(\"TODO figure out when this happens\");\n    }\n\n    const arrayType = getArrayType(type);\n    if (arrayType !== null) {\n        const name = typescriptTypeToSqlType(typeScriptUniqueColumnTypes, arrayType);\n        if (name === null) {\n            return null;\n        }\n        return SqlType.wrap(SqlType.unwrap(name) + \"[]\");\n    }\n\n    const sqlType = typeScriptUniqueColumnTypes.get(TypeScriptType.wrap(type.symbol.name));\n    if (sqlType !== undefined) {\n        return sqlType;\n    }\n\n    // TODO Temporary\n    if (type.symbol.name === \"DbJson\") {\n        return SqlType.wrap(\"jsonb\");\n    } else if (type.symbol.name === \"Instant\") {\n        return SqlType.wrap(\"timestamptz\");\n    } else if (type.symbol.name === \"LocalDateTime\") {\n        return SqlType.wrap(\"timestamp\");\n    } else if (type.symbol.name === \"LocalDate\") {\n        return SqlType.wrap(\"date\");\n    } else if (type.symbol.name === \"LocalTime\") {\n        return SqlType.wrap(\"time\");\n    } else if (type.symbol.name === \"UUID\") {\n        return SqlType.wrap(\"uuid\");\n    }\n\n    return null;\n}\n\nfunction readTypeScriptType(checker: ts.TypeChecker, type: ts.Type): TypeScriptType | null {\n    if ((type.flags & ts.TypeFlags.Any) !== 0) { // tslint:disable-line:no-bitwise\n        // TODO hm....\n        return TypeScriptType.wrap(\"any\");\n    } else if ((type.flags & ts.TypeFlags.Null) !== 0) { // tslint:disable-line:no-bitwise\n        return TypeScriptType.wrap(\"null\");\n    } else if ((type.flags & ts.TypeFlags.Boolean) !== 0 || (type.flags & ts.TypeFlags.BooleanLiteral) !== 0) { // tslint:disable-line:no-bitwise\n        return TypeScriptType.wrap(\"boolean\");\n    } else if ((type.flags & ts.TypeFlags.Number) !== 0 || (type.flags & ts.TypeFlags.NumberLiteral) !== 0) { // tslint:disable-line:no-bitwise\n        return TypeScriptType.wrap(\"number\");\n    } else if ((type.flags & ts.TypeFlags.String) !== 0 || (type.flags & ts.TypeFlags.StringLiteral) !== 0) { // tslint:disable-line:no-bitwise\n        return TypeScriptType.wrap(\"string\");\n    }\n\n    return TypeScriptType.wrap(checker.typeToString(type));\n}\n\n\nfunction getColNullability(memberType: ts.TypeReferenceNode): ColNullability | null {\n    // This just does a crude string comparison on the result of \"getText()\". It\n    // is not robust because even if the name is \"Req\" (or \"Opt\") it does not\n    // necessarily refer to the same \"Req\" (or \"Opt\") type that we are talking\n    // about.\n    //\n    // But this crude check is acceptable, because in the unexpected case where\n    // it's referring to some other \"Req\" (or \"Opt\") type, then the regular\n    // TypeScript type-checker will catch the error.\n    const name = memberType.typeName.getText();\n    if (name === \"Req\") {\n        return ColNullability.REQ;\n    } else if (name === \"Opt\") {\n        return ColNullability.OPT;\n    } else {\n        return null;\n    }\n}\n\nfunction typescriptRowTypeToColTypes(checker: ts.TypeChecker, typeNode: ts.TypeNode, errorReporter: (error: ErrorDiagnostic) => void): Map<string, [ColNullability, TypeScriptType]> | null {\n    if (ts.isTypeLiteralNode(typeNode)) {\n        return typeLiteralNodeToColTypes(checker, typeNode, errorReporter);\n    } else {\n        const typ = checker.getTypeAtLocation(typeNode);\n        if (typ.flags === ts.TypeFlags.Any) {\n            return null;\n        } else {\n            if ((<any>typ).symbol !== undefined && typ.symbol.members !== undefined) {\n                return typeSymbolMembersToColTypes(checker, typeNode, <any>typ.symbol.members, errorReporter);\n            } else {\n                errorReporter(nodeErrorDiagnostic(typeNode, \"Invalid type argument (must be a Type Literal or interface type)\"));\n                return new Map<string, [ColNullability, TypeScriptType]>();\n            }\n        }\n    }\n}\n\nfunction typeLiteralNodeToColTypes(checker: ts.TypeChecker, typeLiteral: ts.TypeLiteralNode, errorReporter: (error: ErrorDiagnostic) => void): Map<string, [ColNullability, TypeScriptType]> {\n    const results = new Map<string, [ColNullability, TypeScriptType]>();\n    for (const member of typeLiteral.members) {\n        if (!ts.isPropertySignature(member)) {\n            errorReporter(nodeErrorDiagnostic(member, \"Type argument member must be a property\"));\n        } else {\n            if (member.type === undefined) {\n                errorReporter(nodeErrorDiagnostic(member, \"Property must have a type\"));\n            } else {\n                if (!ts.isTypeReferenceNode(member.type)) {\n                    errorReporter(nodeErrorDiagnostic(member, \"Property type is not a TypeReferenceNode\"));\n                } else if (!ts.isIdentifier(member.name)) {\n                    errorReporter(nodeErrorDiagnostic(member, \"Property name is not an identifier\"));\n                } else {\n                    const colTypes = getTypeMemberColTypes(checker, member, member.name.text, member.type);\n                    switch (colTypes.type) {\n                        case \"Left\":\n                            errorReporter(colTypes.value);\n                            break;\n                        case \"Right\":\n                            results.set(member.name.text, colTypes.value);\n                            break;\n                        default:\n                            assertNever(colTypes);\n                    }\n                }\n            }\n        }\n    }\n    return results;\n}\n\nfunction typeSymbolMembersToColTypes(checker: ts.TypeChecker, node: ts.Node, members: Map<string, ts.Symbol>, errorReporter: (error: ErrorDiagnostic) => void): Map<string, [ColNullability, TypeScriptType]> {\n    const results = new Map<string, [ColNullability, TypeScriptType]>();\n    members.forEach((value, key) => {\n        if (value.valueDeclaration === undefined) {\n            errorReporter(nodeErrorDiagnostic(node, `Symbol \"${key}\" has no valueDeclaration`));\n        } else if (!ts.isPropertySignature(value.valueDeclaration)) {\n            errorReporter(nodeErrorDiagnostic(node, \"valueDeclaration is not a PropertySignature\"));\n        } else if (value.valueDeclaration.type === undefined) {\n            errorReporter(nodeErrorDiagnostic(node, \"valueDeclaration is missing type\"));\n        } else if (!ts.isTypeReferenceNode(value.valueDeclaration.type)) {\n            errorReporter(nodeErrorDiagnostic(node, \"valueDeclaration type is not a TypeReferenceNode\"));\n        } else {\n            const colTypes = getTypeMemberColTypes(checker, node, key, value.valueDeclaration.type);\n            switch (colTypes.type) {\n                case \"Left\":\n                    errorReporter(colTypes.value);\n                    break;\n                case \"Right\":\n                    results.set(key, colTypes.value);\n                    break;\n                default:\n                    assertNever(colTypes);\n            }\n        }\n    });\n    return results;\n}\n\nfunction getTypeMemberColTypes(checker: ts.TypeChecker, node: ts.Node, propName: string, memberType: ts.TypeReferenceNode): Either<ErrorDiagnostic, [ColNullability, TypeScriptType]> {\n    const colNullability = getColNullability(memberType);\n    if (colNullability === null) {\n        return {\n            type: \"Left\",\n            value: nodeErrorDiagnostic(node, `Invalid type for property \"${propName}\", it must be \\`Req<T>\\` or \\`Opt<T>\\``)\n        };\n    } else {\n        if (memberType.typeArguments === undefined || memberType.typeArguments.length < 1) {\n            return {\n                type: \"Left\",\n                value: nodeErrorDiagnostic(node, `Invalid type for property \"${propName}\", it must be \\`Req<T>\\` or \\`Opt<T>\\``)\n            };\n        } else {\n            const typeArgument = memberType.typeArguments[0];\n            const typeArgumentType = checker.getTypeFromTypeNode(typeArgument);\n            const type = readTypeScriptType(checker, typeArgumentType);\n            if (type === null) {\n                return {\n                    type: \"Left\",\n                    value: nodeErrorDiagnostic(node, `Invalid type for property \"${propName}\": ${checker.typeToString(typeArgumentType)}`)\n                };\n            } else {\n                return {\n                    type: \"Right\",\n                    value: [colNullability, type]\n                };\n            }\n        }\n    }\n}\n\nexport function resolveQueryFragment(typeScriptUniqueColumnTypes: Map<TypeScriptType, SqlType>, projectDir: string, checker: ts.TypeChecker, query: QueryCallExpression, lookupViewName: (qualifiedSqlViewName: QualifiedSqlViewName) => string | undefined): Either<ErrorDiagnostic[], ResolvedSelect> {\n    const errors: ErrorDiagnostic[] = [];\n\n    let text = \"\";\n    const sourceMap: [number, number, number][] = [];\n    let numParams = 0;\n    for (const frag of query.queryFragments) {\n        switch (frag.type) {\n            case \"StringFragment\":\n                sourceMap.push([frag.sourcePosStart, text.length, text.length + frag.text.length]);\n                text += frag.text;\n                break;\n            case \"Expression\":\n                const type = checker.getTypeAtLocation(frag.exp);\n                const maybeSqlFrag = tryTypeSqlFrag(type);\n                switch (maybeSqlFrag.type) {\n                    case \"Left\":\n                        errors.push(nodeErrorDiagnostic(frag.exp, maybeSqlFrag.value));\n                        break;\n                    case \"Right\":\n                        if (maybeSqlFrag.value !== null) {\n                            text += maybeSqlFrag.value;\n                        } else if (isTypeSqlView(type)) {\n                            if (!ts.isIdentifier(frag.exp)) {\n                                errors.push(nodeErrorDiagnostic(frag.exp, \"SQL View Reference must be an identifier (not an expression)\"));\n                            } else {\n                                const qualifiedSqlViewName = resolveViewIdentifier(projectDir, frag.exp.getSourceFile(), frag.exp);\n                                const viewName = lookupViewName(qualifiedSqlViewName);\n                                if (viewName === undefined) {\n                                    errors.push(nodeErrorDiagnostic(frag.exp, \"SQL View Reference not found or has errors: \\\"\" + chalk.bold(QualifiedSqlViewName.viewName(qualifiedSqlViewName)) + \"\\\"\"));\n                                } else {\n                                    text += '\"' + viewName + '\"';\n                                }\n                            }\n                        } else {\n                            const sqlType = typescriptTypeToSqlType(typeScriptUniqueColumnTypes, nonNullType(type));\n                            if (sqlType === null) {\n                                const typeStr = checker.typeToString(type, frag.exp);\n                                errors.push(nodeErrorDiagnostic(frag.exp, `Invalid type for SQL parameter: ${typeStr}`));\n                            } else {\n                                numParams++;\n                                const sqlTypeStr = SqlType.unwrap(sqlType);\n\n                                // Ugly hack for detecing an sql array type\n                                //\n                                // WRONG: \"myType[]\" RIGHT: \"myType\"[]\n                                //\n                                // The correct (non-hacky) way to do this is to change\n                                // \"SqlType\" from a string to a real type with an\n                                // (isArray: boolean) prop\n\n                                const escapedSqlTypeStr = sqlTypeStr.endsWith(\"[]\")\n                                    ? escapeIdentifier(sqlTypeStr.substring(0, sqlTypeStr.length - 2)) + \"[]\"\n                                    : escapeIdentifier(sqlTypeStr);\n\n                                text += \"($\" + numParams + (sqlTypeStr !== \"\" ? \"::\" + escapedSqlTypeStr : \"\") + \")\";\n                            }\n                        }\n                        break;\n                    default:\n                        assertNever(maybeSqlFrag);\n                }\n                break;\n            default:\n                assertNever(frag);\n        }\n    }\n\n    if (errors.length === 0) {\n        let colTypes: Map<string, [ColNullability, TypeScriptType]> | null;\n        if (query.typeArgument === null) {\n            // If no type argument was specified, then for our purposes it is\n            // equivalent to <{}>\n            colTypes = new Map<string, [ColNullability, TypeScriptType]>();\n        } else {\n            colTypes = typescriptRowTypeToColTypes(checker, query.typeArgument, e => errors.push(e));\n        }\n\n        return {\n            type: \"Right\",\n            value: {\n                fileName: query.fileName,\n                fileContents: query.fileContents,\n                text: text,\n                sourceMap: sourceMap,\n                colTypes: colTypes,\n                queryMethodName: query.queryMethodName,\n                colTypeSpan: query.typeArgumentSpan,\n                indentLevel: query.indentLevel,\n                errors: errors\n            }\n        };\n    } else {\n        return {\n            type: \"Left\",\n            value: errors\n        };\n    }\n}\n\n\nexport function resolveInsertMany(typeScriptUniqueColumnTypes: Map<TypeScriptType, SqlType>, projectDir: string, checker: ts.TypeChecker, query: InsertManyExpression, lookupViewName: (qualifiedSqlViewName: QualifiedSqlViewName) => string | undefined): Either<ErrorDiagnostic[], ResolvedInsert> {\n    // TODO This contains lots of copy&pasted code from\n    // `resolveQueryFragment`. The common code should be refactored into\n    // helper functions\n\n    const errors: ErrorDiagnostic[] = [];\n\n    let text = \"\";\n\n    const insertFragment: QueryCallExpression.QueryFragment[] = [{\n        type: \"StringFragment\",\n        text: `INSERT INTO ${escapeIdentifier(query.tableName)} DEFAULT VALUES `,\n        sourcePosStart: 0\n    }];\n\n    const queryFragments: QueryCallExpression.QueryFragment[] = insertFragment.concat(query.epilougeFragments);\n\n    const sourceMap: [number, number, number][] = [];\n    let numParams = 0;\n    for (const frag of queryFragments) {\n        switch (frag.type) {\n            case \"StringFragment\":\n                sourceMap.push([frag.sourcePosStart, text.length, text.length + frag.text.length]);\n                text += frag.text;\n                break;\n            case \"Expression\":\n                const type = checker.getTypeAtLocation(frag.exp);\n                const maybeSqlFrag = tryTypeSqlFrag(type);\n                switch (maybeSqlFrag.type) {\n                    case \"Left\":\n                        errors.push(nodeErrorDiagnostic(frag.exp, maybeSqlFrag.value));\n                        break;\n                    case \"Right\":\n                        if (maybeSqlFrag.value !== null) {\n                            text += maybeSqlFrag.value;\n                        } else if (isTypeSqlView(type)) {\n                            if (!ts.isIdentifier(frag.exp)) {\n                                errors.push(nodeErrorDiagnostic(frag.exp, \"SQL View Reference must be an identifier (not an expression)\"));\n                            } else {\n                                const qualifiedSqlViewName = resolveViewIdentifier(projectDir, frag.exp.getSourceFile(), frag.exp);\n                                const viewName = lookupViewName(qualifiedSqlViewName);\n                                if (viewName === undefined) {\n                                    errors.push(nodeErrorDiagnostic(frag.exp, \"SQL View Reference not found or has errors: \\\"\" + chalk.bold(QualifiedSqlViewName.viewName(qualifiedSqlViewName)) + \"\\\"\"));\n                                } else {\n                                    text += '\"' + viewName + '\"';\n                                }\n                            }\n                        } else {\n                            const sqlType = typescriptTypeToSqlType(typeScriptUniqueColumnTypes, nonNullType(type));\n                            if (sqlType === null) {\n                                const typeStr = checker.typeToString(type, frag.exp);\n                                errors.push(nodeErrorDiagnostic(frag.exp, `Invalid type for SQL parameter: ${typeStr}`));\n                            } else {\n                                numParams++;\n                                const sqlTypeStr = SqlType.unwrap(sqlType);\n\n                                // Ugly hack for detecing an sql array type\n                                //\n                                // WRONG: \"myType[]\" RIGHT: \"myType\"[]\n                                //\n                                // The correct (non-hacky) way to do this is to change\n                                // \"SqlType\" from a string to a real type with an\n                                // (isArray: boolean) prop\n\n                                const escapedSqlTypeStr = sqlTypeStr.endsWith(\"[]\")\n                                    ? escapeIdentifier(sqlTypeStr.substring(0, sqlTypeStr.length - 2)) + \"[]\"\n                                    : escapeIdentifier(sqlTypeStr);\n\n                                text += \"($\" + numParams + (sqlTypeStr !== \"\" ? \"::\" + escapedSqlTypeStr : \"\") + \")\";\n                            }\n                        }\n                        break;\n                    default:\n                        assertNever(maybeSqlFrag);\n                }\n                break;\n            default:\n                assertNever(frag);\n        }\n    }\n\n    if (errors.length === 0) {\n        let colTypes: Map<string, [ColNullability, TypeScriptType]> | null;\n        if (query.typeArgument === null) {\n            // If no type argument was specified, then for our purposes it is\n            // equivalent to <{}>\n            colTypes = new Map<string, [ColNullability, TypeScriptType]>();\n        } else {\n            colTypes = typescriptRowTypeToColTypes(checker, query.typeArgument, e => errors.push(e));\n        }\n\n        return {\n            type: \"Right\",\n            value: {\n                fileName: query.fileName,\n                fileContents: query.fileContents,\n                insertColumns: query.insertColumns,\n                tableName: query.tableName,\n                text: text,\n                sourceMap: sourceMap,\n                colTypes: colTypes,\n                queryMethodName: query.queryMethodName,\n                colTypeSpan: query.typeArgumentSpan,\n                tableNameExprSpan: query.tableNameExprSpan,\n                insertExprSpan: query.insertExprSpan,\n                indentLevel: query.indentLevel,\n                errors: errors\n            }\n        };\n    } else {\n        return {\n            type: \"Left\",\n            value: errors\n        };\n    }\n}\n","import chalk from \"chalk\";\nimport * as ts from \"typescript\";\nimport { PostgreSqlError } from \"./pg_extra\";\n\nexport interface QuickFix {\n    name: string;\n    replacementText: string;\n}\n\nexport interface ErrorDiagnostic {\n    fileName: string;\n    fileContents: string;\n    span: SrcSpan;\n    messages: string[];\n    epilogue: string | null;\n\n    /**\n     * Replace the `span` with this text\n     */\n    quickFix: QuickFix | null;\n}\n\nexport function fileLineCol(fileContents: string, position: number): SrcSpan.LineAndCol {\n    let line = 1;\n    let col = 1;\n    for (let i = 0; i < position; ++i) {\n        if (fileContents.codePointAt(i) === 0x0A /* \"\\n\" */) {\n            line++;\n            col = 0;\n        }\n        col++;\n    }\n    return {\n        type: \"LineAndCol\",\n        line: line,\n        col: col\n    };\n}\n\nexport function toSrcSpan(fileContents: string, position: number): SrcSpan.LineAndCol {\n    return fileLineCol(fileContents, position - 1);\n}\n\nexport function postgresqlErrorDiagnostic(fileName: string, fileContents: string, err: PostgreSqlError, span: SrcSpan, message: string | null): ErrorDiagnostic {\n    return {\n        fileName: fileName,\n        fileContents: fileContents,\n        span: span,\n        messages: (message !== null ? [message] : []).concat([\n            chalk.bold(err.message),\n            chalk.bold(\"code:\") + \" \" + err.code\n        ]).concat(err.detail !== null && err.detail !== err.message ? chalk.bold(\"detail:\") + \" \" + err.detail : []),\n        epilogue: err.hint !== null ? chalk.bold(\"hint:\") + \" \" + err.hint : null,\n        quickFix: null\n    };\n}\n\nexport function nodeErrorDiagnostic(node: ts.Node, message: string): ErrorDiagnostic {\n    const sourceFile = node.getSourceFile();\n    return {\n        fileName: sourceFile.fileName,\n        fileContents: sourceFile.text,\n        span: nodeSourceSpan(node),\n        messages: [chalk.bold(message)],\n        epilogue: null,\n        quickFix: null\n    };\n}\n\nexport function nodeSourceSpan(node: ts.Node): SrcSpan {\n    const sourceFile = node.getSourceFile();\n    const pos = ts.getLineAndCharacterOfPosition(sourceFile, node.pos);\n    const end = ts.getLineAndCharacterOfPosition(sourceFile, node.end);\n    return {\n        type: \"LineAndColRange\",\n        startLine: pos.line + 1,\n        startCol: pos.character + 1,\n        endLine: end.line + 1,\n        endCol: end.character + 1\n    };\n}\n\nexport type SrcSpan = SrcSpan.LineAndColRange | SrcSpan.LineAndCol | SrcSpan.File;\n\nexport namespace SrcSpan {\n    export interface LineAndColRange {\n        type: \"LineAndColRange\";\n\n        /**\n         * First line of the file is 1\n         */\n        startLine: number;\n\n        /**\n         * First column is 1\n         */\n        startCol: number;\n\n        /**\n         * First line of the file is 1\n         */\n        endLine: number;\n\n        /**\n         * First column is 1\n         */\n        endCol: number;\n    }\n\n    export interface LineAndCol {\n        type: \"LineAndCol\";\n\n        /**\n         * First line of the file is 1\n         */\n        line: number;\n\n        /**\n         * First column is 1\n         */\n        col: number;\n    }\n\n    export interface File {\n        type: \"File\";\n    }\n}\n","import * as crypto from \"crypto\";\nimport postgres from \"postgres\";\n\nexport function connectPg(url: string): postgres.Sql {\n    return postgres(url, {\n        onnotice: () => {\n            /* do nothing */\n        }\n    });\n}\n\nexport function closePg(conn: postgres.Sql): Promise<void> {\n    return conn.end();\n}\n\nexport function escapeIdentifier(str: string) {\n    // See:\n    // <https://github.com/brianc/node-postgres/blob/60d8df659c5481723abada2344ac14d77377338c/lib/client.js#L401>\n    return '\"' + str.replace(/\"/g, '\"\"') + '\"';\n}\n\nexport async function pgDescribeQuery(client: postgres.Sql, text: string): Promise<postgres.ColumnList<string> | null> {\n    const result = await client.unsafe(text).describe();\n    return result.columns;\n}\n\n/**\n * !!! WARNING !!!\n *\n * Warning this deletes all data in the database!\n *\n * to delete routines, need to run manually:\n * http://www.postgresonline.com/journal/archives/74-How-to-delete-many-functions.html\n */\nexport async function dropAllTables(client: postgres.Sql) {\n    // http://stackoverflow.com/questions/3327312/drop-all-tables-in-postgresql/36023359#36023359\n\n    await client.unsafe(\n        `\n        DO $$ DECLARE\n            r RECORD;\n        BEGIN\n            -- if the schema you operate on is not \"current\", you will want to\n            -- replace current_schema() in query with 'schematodeletetablesfrom'\n            -- *and* update the generate 'DROP...' accordingly.\n            FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = current_schema()) LOOP\n                EXECUTE 'DROP TABLE IF EXISTS ' || quote_ident(r.tablename) || ' CASCADE';\n            END LOOP;\n        END $$;\n        `);\n}\n\nexport async function dropAllSequences(client: postgres.Sql) {\n    await client.unsafe(\n        `\n        DO $$ DECLARE\n            r RECORD;\n        BEGIN\n            -- if the schema you operate on is not \"current\", you will want to\n            -- replace current_schema() in query with 'schematodeletetablesfrom'\n            -- *and* update the generate 'DROP...' accordingly.\n            FOR r IN (SELECT pg_class.relname FROM pg_class, pg_namespace WHERE pg_class.relnamespace = pg_namespace.oid AND pg_namespace.nspname = current_schema() AND pg_class.relkind = 'S') LOOP\n                EXECUTE 'DROP SEQUENCE IF EXISTS ' || quote_ident(r.relname) || ' CASCADE';\n            END LOOP;\n        END $$;\n        `);\n}\n\nexport async function dropAllFunctions(client: postgres.Sql) {\n    await client.unsafe(\n        `\n        DO $$ DECLARE\n            r RECORD;\n        BEGIN\n            -- if the schema you operate on is not \"current\", you will want to\n            -- replace current_schema() in query with 'schematodeletetablesfrom'\n            -- *and* update the generate 'DROP...' accordingly.\n            FOR r IN (SELECT pg_proc.proname, pg_proc.proargtypes FROM pg_proc, pg_namespace WHERE pg_proc.pronamespace = pg_namespace.oid AND pg_namespace.nspname = current_schema()) LOOP\n                EXECUTE 'DROP FUNCTION IF EXISTS ' || quote_ident(r.proname) || '(' || oidvectortypes(r.proargtypes) || ')' || ' CASCADE';\n            END LOOP;\n        END $$;\n        `);\n}\n\nexport async function dropAllTypes(client: postgres.Sql) {\n    await client.unsafe(\n        `\n        DO $$ DECLARE\n            r RECORD;\n        BEGIN\n            -- if the schema you operate on is not \"current\", you will want to\n            -- replace current_schema() in query with 'schematodeletetablesfrom'\n            -- *and* update the generate 'DROP...' accordingly.\n            FOR r IN (SELECT pg_type.typname FROM pg_type, pg_namespace WHERE pg_namespace.oid = pg_type.typnamespace AND pg_namespace.nspname = current_schema()) LOOP\n                EXECUTE 'DROP TYPE IF EXISTS ' || quote_ident(r.typname) || ' CASCADE';\n            END LOOP;\n        END $$;\n        `);\n}\n\n/**\n * Checks if `err` is a PostgreSQL error, and returns the error code.\n *\n * See: <https://www.postgresql.org/docs/9.6/static/errcodes-appendix.html>\n *\n * If `err` is not a PostgreSQL error, then returns `null`\n */\nexport function getPostgreSqlErrorCode(err: any): string | null {\n    if (typeof err !== \"object\") {\n        return null;\n    }\n\n    // The best technique I could think of to check if this is a pg error\n    // (rather than some other type of error), is to see if it is an object with\n    // all of the following fields that are always set\n\n    // List of fields is from the \"parseE\" function from \"connection.js\" file\n    // from \"node-pg\" npm package:\n    const pgErrFields = [\n        \"severity\",\n        \"code\",\n        \"detail\",\n        \"hint\",\n        \"position\",\n        \"internalPosition\",\n        \"internalQuery\",\n        \"where\",\n        \"schema\",\n        \"table\",\n        \"column\",\n        \"dataType\",\n        \"constraint\",\n        \"file\",\n        \"line\",\n        \"routine\"\n    ];\n\n    for (const field of pgErrFields) {\n        if (!(field in err)) {\n            return null;\n        }\n    }\n\n    const code = err.code;\n    if (typeof code !== \"string\") {\n        return null;\n    }\n\n    return err.code;\n}\n\nexport interface PostgreSqlError {\n    code: string;\n    position: number | null;\n    message: string;\n    detail: string | null;\n    hint: string | null;\n}\n\n/**\n *\n * If `err` is not a PostgreSQL error, then returns `null`\n */\nexport function parsePostgreSqlError(err: unknown): PostgreSqlError | null {\n    if (!(err instanceof postgres.PostgresError)) {\n        return null;\n    }\n\n    return {\n        code: err.code,\n        position: parseInt(err.position, 10),\n        message: err.message,\n        detail: err.detail !== undefined ? err.detail : null,\n        hint: err.hint !== undefined ? err.hint : null\n    };\n}\n\nclass Savepoint {\n    public constructor(public readonly name: string) { }\n}\n\n/**\n * Generates a cryptographically random token\n */\nfunction randomSavepointName(): Promise<string> {\n    return new Promise<string>((resolve, reject) => {\n        crypto.randomBytes(24, (err, buf) => {\n            if (<boolean>(<any>err)) {\n                reject(err);\n                return;\n            }\n\n            const token = buf.toString(\"hex\");\n            resolve(\"savepoint_\" + token);\n        });\n    });\n}\n\nexport async function newSavepoint(conn: postgres.Sql): Promise<Savepoint> {\n    const savepointName = await randomSavepointName();\n\n    await conn.unsafe(`SAVEPOINT ${savepointName}`);\n\n    return new Savepoint(savepointName);\n}\n\nexport async function rollbackToAndReleaseSavepoint(conn: postgres.Sql, savepoint: Savepoint): Promise<void> {\n    await conn.unsafe(`ROLLBACK TO SAVEPOINT ${savepoint.name}; RELEASE SAVEPOINT ${savepoint.name}`);\n}\n","import { assertNever } from \"assert-never\";\nimport * as path from \"path\";\nimport * as ts from \"typescript\";\nimport { Either } from \"./either\";\nimport { ErrorDiagnostic, fileLineCol, nodeErrorDiagnostic } from \"./ErrorDiagnostic\";\nimport { escapeIdentifier } from \"./pg_extra\";\nimport { identifierImportedFrom, ModuleId } from \"./ts_extra\";\nimport { calcViewName } from \"./view_names\";\nimport * as E from \"fp-ts/Either\";\nimport {pipe} from \"fp-ts/function\";\n\nfunction viewNameLength(varName: string | null): number {\n    return escapeIdentifier(calcViewName(varName, \"\")).length;\n}\n\nexport function resolveViewIdentifier(projectDir: string, sourceFile: ts.SourceFile, ident: ts.Identifier): QualifiedSqlViewName {\n    const importedFromModule = identifierImportedFrom(sourceFile, ident);\n    if (importedFromModule !== null) {\n        return QualifiedSqlViewName.create(importedModuleName(projectDir, sourceFile, importedFromModule), ident.text);\n    } else {\n        // TODO Validate that the referenced view was actually\n        // defined in the current file. For now we just assume that\n        // it was\n        return QualifiedSqlViewName.create(sourceFileModuleName(projectDir, sourceFile), ident.text);\n    }\n}\n\nexport class SqlViewDefinition {\n    static parseFromTemplateExpression(projectDir: string, sourceFile: ts.SourceFile, checker: ts.TypeChecker, varName: string | null, node: ts.TemplateLiteral): Either<ErrorDiagnostic, SqlViewDefinition> {\n        if (ts.isNoSubstitutionTemplateLiteral(node)) {\n            const sourceMap: [number, number, number][] = [[node.end - node.text.length, 0, node.text.length]];\n            return {\n                type: \"Right\",\n                value: new SqlViewDefinition(sourceFile.fileName, sourceFile.text, varName, [{ type: \"StringFragment\", text: node.text }], sourceMap)\n            };\n        } else if (ts.isTemplateExpression(node)) {\n            const sourceMap: [number, number, number][] = [];\n\n            const fragments: SqlViewDefinition.Fragment[] = [];\n            fragments.push({ type: \"StringFragment\", text: node.head.text });\n\n            let c = 0;\n\n            // If there is whitespace before the opening quote (`) then \"pos\"\n            // starts at the beginning of the whitespace (so we use this\n            // formula to guarantee that we get the position of the start of\n            // the opening quote (`) char)\n            sourceMap.push([node.head.end - node.head.text.length - 1, c, c + node.head.text.length]);\n\n            c += node.head.text.length;\n\n            for (let i = 0; i < node.templateSpans.length; ++i) {\n                const span = node.templateSpans[i];\n\n                const type = checker.getTypeAtLocation(span.expression);\n                const maybeSqlFrag = tryTypeSqlFrag(type);\n                switch (maybeSqlFrag.type) {\n                    case \"Left\":\n                        return {\n                            type: \"Left\",\n                            value: nodeErrorDiagnostic(span, maybeSqlFrag.value)\n                        };\n                    case \"Right\":\n                        if (maybeSqlFrag.value !== null) {\n                            fragments.push({ type: \"StringFragment\", text: maybeSqlFrag.value });\n\n                            c += maybeSqlFrag.value.length;\n                        } else {\n                            if (!ts.isIdentifier(span.expression)) {\n                                return {\n                                    type: \"Left\",\n                                    value: nodeErrorDiagnostic(span, \"defineSqlView template spans can only be identifiers (no other expressions allowed)\")\n                                };\n                            }\n\n                            const qualifiedSqlViewName = resolveViewIdentifier(projectDir, sourceFile, span.expression);\n                            fragments.push({ type: \"ViewReference\", qualifiedSqlViewName: qualifiedSqlViewName });\n\n                            c += viewNameLength(span.expression.text);\n                        }\n                        break;\n                    default:\n                        assertNever(maybeSqlFrag);\n                }\n\n                fragments.push({ type: \"StringFragment\", text: span.literal.text });\n                sourceMap.push([span.literal.end - span.literal.text.length -\n                    (i < node.templateSpans.length - 1 ? 1 : 0) // The end of the last template span is different from the others\n                    , c, c + span.literal.text.length]);\n\n                c += span.literal.text.length;\n            }\n\n            return {\n                type: \"Right\",\n                value: new SqlViewDefinition(sourceFile.fileName, sourceFile.text, varName, fragments, sourceMap)\n            };\n        } else {\n            return assertNever(node);\n        }\n    }\n\n    isFullyResolved(): boolean {\n        for (const frag of this.fragments) {\n            if (frag.type === \"ViewReference\") {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Only call this if `isFullyResolved` returns true\n     */\n    fullyResolvedQuery(): string {\n        let result: string = \"\";\n        for (const frag of this.fragments) {\n            if (frag.type === \"ViewReference\") {\n                throw new Error(`SqlViewDefinition \"${frag.qualifiedSqlViewName}\" is not fully resolved`);\n            }\n            result += frag.text;\n        }\n        return result;\n    }\n\n    getDependencies(): QualifiedSqlViewName[] {\n        return this.dependencies;\n    }\n\n    inject(dependency: QualifiedSqlViewName, viewName: string): void {\n        for (let i = 0; i < this.fragments.length; ++i) {\n            const frag = this.fragments[i];\n            if (frag.type === \"ViewReference\" && frag.qualifiedSqlViewName === dependency) {\n                this.fragments[i] = { type: \"StringFragment\", text: escapeIdentifier(viewName) };\n            }\n        }\n    }\n\n    /**\n     * Only call this if `isFullyResolved` returns true\n     */\n    getName(): string {\n        if (this.viewName === null) {\n            this.viewName = calcViewName(this.varName, this.fullyResolvedQuery());\n        }\n\n        return this.viewName;\n    }\n\n    getFileName(): string {\n        return this.fileName;\n    }\n\n    getFileContents(): string {\n        return this.fileContents;\n    }\n\n    getSourceMap(): [number, number, number][] {\n        return this.sourceMap;\n    }\n\n    /**\n     * Call this if any of the dependencies have changed\n     */\n    resetToInitialFragments(): void {\n        this.viewName = null;\n        this.fragments = [...this.initialFragments];\n    }\n\n    isEqual(other: SqlViewDefinition): boolean {\n        if (this.initialFragments.length !== other.initialFragments.length) {\n            return false;\n        }\n\n        for (let i = 0; i < this.initialFragments.length; ++i) {\n            if (!SqlViewDefinition.fragmentsEqual(this.initialFragments[i], other.initialFragments[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    debugDump(): string {\n        return `${this.varName} ${JSON.stringify(this.dependencies)} ${JSON.stringify(this.fragments)}`;\n    }\n\n    private constructor(fileName: string, fileContents: string, varName: string | null, fragments: SqlViewDefinition.Fragment[], sourceMap: [number, number, number][]) {\n        this.fileName = fileName;\n        this.fileContents = fileContents;\n        this.sourceMap = sourceMap;\n        this.varName = varName;\n        this.initialFragments = fragments;\n        this.fragments = [...fragments];\n        this.dependencies = [];\n        for (let i = 0; i < fragments.length; ++i) {\n            const frag = this.fragments[i];\n            if (frag.type === \"ViewReference\") {\n                this.dependencies.push(frag.qualifiedSqlViewName);\n            }\n        }\n    }\n\n    private readonly fileName: string;\n    private readonly fileContents: string;\n    private readonly sourceMap: [number, number, number][];\n    private readonly varName: string | null;\n    private readonly initialFragments: SqlViewDefinition.Fragment[];\n    private readonly dependencies: QualifiedSqlViewName[];\n\n    // Mutable\n    private fragments: SqlViewDefinition.Fragment[];\n    private viewName: string | null = null;\n\n    static fragmentsEqual(lhs: SqlViewDefinition.Fragment, rhs: SqlViewDefinition.Fragment): boolean {\n        switch (lhs.type) {\n            case \"StringFragment\":\n                return rhs.type === \"StringFragment\" && lhs.text === rhs.text;\n            case \"ViewReference\":\n                return rhs.type === \"ViewReference\" && lhs.qualifiedSqlViewName === rhs.qualifiedSqlViewName;\n            default:\n                return assertNever(lhs);\n        }\n    }\n}\n\nnamespace SqlViewDefinition {\n    export type Fragment\n        = { readonly type: \"StringFragment\"; readonly text: string }\n        | { readonly type: \"ViewReference\"; readonly qualifiedSqlViewName: QualifiedSqlViewName };\n}\n\nexport interface SqlCreateView {\n    readonly qualifiedViewname: QualifiedSqlViewName;\n    readonly viewName: string;\n    readonly createQuery: string;\n    readonly fileName: string;\n    readonly fileContents: string;\n    readonly sourceMap: [number, number, number][];\n}\n\nfunction fullyResolveSqlViewDefinition(v: SqlViewDefinition, myName: QualifiedSqlViewName, library: Map<QualifiedSqlViewName, SqlViewDefinition>): ErrorDiagnostic[] {\n    if (v.isFullyResolved()) {\n        return [];\n    }\n\n    for (const depName of v.getDependencies()) {\n        // Make sure we don't get stuck in infinite recursion!\n        if (depName === myName) {\n            return [{\n                fileName: v.getFileName(),\n                fileContents: v.getFileContents(),\n                span: fileLineCol(v.getFileContents(), v.getSourceMap()[0][0]),\n                messages: [`View depends on itself: \"${QualifiedSqlViewName.viewName(myName)}\"`],\n                epilogue: null,\n                quickFix: null\n            }];\n        }\n\n        const dep = library.get(depName);\n        if (dep === undefined) {\n            return [{\n                fileName: v.getFileName(),\n                fileContents: v.getFileContents(),\n                span: fileLineCol(v.getFileContents(), v.getSourceMap()[0][0]),\n                messages: [`Missing dependency in view \"${QualifiedSqlViewName.viewName(myName)}\": \"${QualifiedSqlViewName.viewName(depName)}\" (from module \"${QualifiedSqlViewName.moduleId(depName)}\"`],\n                epilogue: null,\n                quickFix: null\n            }];\n        }\n        if (!dep.isFullyResolved()) {\n            fullyResolveSqlViewDefinition(dep, depName, library);\n        }\n        v.inject(depName, dep.getName());\n    }\n\n    return [];\n}\n\ntype FileName = string;\n\nexport function resolveAllViewDefinitions(library: Map<QualifiedSqlViewName, SqlViewDefinition>): [Map<FileName, SqlCreateView[]>, ErrorDiagnostic[]] {\n    let errorDiagnostics: ErrorDiagnostic[] = [];\n\n    // Fully resolve all of the views (using the above recursive algorithm)\n\n    library.forEach((value, key) => {\n        const errors = fullyResolveSqlViewDefinition(value, key, library);\n        errorDiagnostics = errorDiagnostics.concat(errors);\n    });\n\n    // Topological sort of the views, so that they are created in\n    // reverse-dependency order (otherwise we will get an error if we try to\n    // create a view before its dependencies have been created)\n\n    const result: Map<string, SqlCreateView[]> = new Map();\n    const added = new Set<QualifiedSqlViewName>();\n\n    function addView(name: QualifiedSqlViewName, view: SqlViewDefinition) {\n        if (added.has(name)) {\n            return;\n        }\n\n        for (const depName of view.getDependencies()) {\n            const dep = library.get(depName);\n            if (dep === undefined) {\n                // This should never happen, because the dependencies were\n                // already correctly resolved in the previous step\n                throw new Error(`The Impossible happened: Missing dependency in view ${name}: ${depName}`);\n            }\n\n            addView(depName, dep);\n        }\n\n        if (!result.has(view.getFileName())) {\n            result.set(view.getFileName(), []);\n        }\n        \n        result.get(view.getFileName())!.push({\n            qualifiedViewname: name,\n            viewName: view.getName(),\n            createQuery: view.fullyResolvedQuery(),\n            fileName: view.getFileName(),\n            fileContents: view.getFileContents(),\n            sourceMap: view.getSourceMap()\n        });\n\n        added.add(name);\n    }\n\n    library.forEach((value, key) => {\n        if (value.isFullyResolved()) {\n            addView(key, value);\n        }\n    });\n\n    return [result, errorDiagnostics];\n}\n\n/**\n * Pair of ModuleId + string\n */\nexport class QualifiedSqlViewName {\n    static create(moduleId: ModuleId, viewName: string): QualifiedSqlViewName {\n        return (moduleId + \" \" + viewName) as any;\n    }\n\n    static moduleId(val: QualifiedSqlViewName): ModuleId {\n        return (val as any).split(\" \")[0];\n    }\n\n    static viewName(val: QualifiedSqlViewName): string {\n        return (val as any).split(\" \")[1];\n    }\n\n    protected _dummy: QualifiedSqlViewName[];\n}\n\nexport function sourceFileModuleName(projectDir: string, sourceFile: ts.SourceFile): ModuleId {\n    const relFile = path.relative(projectDir, sourceFile.fileName);\n\n    // Strip the \".ts\" extension (TODO This should be done more robustly)\n    const modName = relFile.slice(0, -3);\n    return ModuleId.wrap(modName);\n}\n\nfunction importedModuleName(projectDir: string, sourceFile: ts.SourceFile, importedModule: string): ModuleId {\n    return ModuleId.wrap(path.join(path.dirname(ModuleId.unwrap(sourceFileModuleName(projectDir, sourceFile))), importedModule));\n}\n\n/**\n * @returns `null` if the type is not an SqlFrag<T>\n */\nexport function tryTypeSqlFrag(type: ts.Type): Either<string, string | null> {\n    // TODO This should be more robust: make sure that it is the \"SqlFrag\" (or\n    // \"SqlFragAuth\") type defined in the sql library (and not some other\n    // user-defined type that happens to have the same name)\n\n    const symbol: ts.Symbol | undefined = <ts.Symbol | undefined>type.symbol;\n    if (symbol === undefined) {\n        return {\n            type: \"Right\",\n            value: null\n        };\n    }\n\n    if (symbol.name === \"SqlFrag\") {\n        const typeArguments = (<any>type).typeArguments;\n        if (Array.isArray(typeArguments)) {\n            if (typeArguments.length === 1) {\n                if (typeArguments[0].flags === ts.TypeFlags.String) {\n                    return {\n                        type: \"Left\",\n                        value: \"Invalid call to `sqlFrag`: argument must be a String Literal (not a dynamic string)\"\n                    };\n                } else if (typeArguments[0].flags === ts.TypeFlags.StringLiteral) {\n                    if (typeof typeArguments[0].value === \"string\") {\n                        return {\n                            type: \"Right\",\n                            value: typeArguments[0].value\n                        };\n                    }\n                }\n            }\n        }\n    }\n\n    if (symbol.name === \"SqlFragAuth\") {\n        const typeArguments = (<any>type).typeArguments;\n        if (Array.isArray(typeArguments)) {\n            if (typeArguments.length === 2) {\n                if (typeArguments[0].flags === ts.TypeFlags.String) {\n                    return {\n                        type: \"Left\",\n                        value: \"Invalid call to `sqlFragAuth`: argument must be a String Literal (not a dynamic string)\"\n                    };\n                } else if (typeArguments[0].flags === ts.TypeFlags.StringLiteral) {\n                    if (typeof typeArguments[0].value === \"string\") {\n                        return {\n                            type: \"Right\",\n                            value: typeArguments[0].value\n                        };\n                    }\n                }\n            }\n        }\n    }\n\n    return {\n        type: \"Right\",\n        value: null\n    };\n}\n\nexport function isSqlViewDefinition(checker: ts.TypeChecker, decl: ts.VariableDeclaration): boolean {\n    const name = checker.getTypeAtLocation(decl).symbol.name;\n\n    // TODO This should be more robust: make sure that it is the \"SqlView\" type\n    // defined in the sql library (and not some other user-defined type that\n    // happens to have the same name)\n\n    return name === \"SqlView\";\n}\n\nexport function getSqlDefinitionE(params: {\n    projectDir: string;\n    sf: ts.SourceFile;\n    checker: ts.TypeChecker;\n    node: ts.Node;\n}): undefined | E.Either<ErrorDiagnostic, {\n    viewName: string;\n    qualifiedSqlViewName: QualifiedSqlViewName;\n    sqlViewDefinition: SqlViewDefinition;\n}> {\n    const { projectDir, sf, checker, node } = params;\n\n    if (!ts.isVariableStatement(node)) {\n        return;\n    }\n\n    for (const decl of node.declarationList.declarations) {\n        if (decl.initializer === undefined || !ts.isTaggedTemplateExpression(decl.initializer)) {\n            return;\n        }\n\n        if (!ts.isIdentifier(decl.initializer.tag) || !isSqlViewDefinition(checker, decl) || !ts.isIdentifier(decl.name)) {\n            return;\n        }\n\n        if ((node.declarationList.flags & ts.NodeFlags.Const) === 0) {\n            return E.left(nodeErrorDiagnostic(decl.name, \"defineSqlView assigned to a non-const variable\"));\n        }\n        \n        const viewName = decl.name.text;\n        const qualifiedSqlViewName = QualifiedSqlViewName.create(sourceFileModuleName(projectDir, sf), viewName);\n        const sqlViewDefinition = SqlViewDefinition.parseFromTemplateExpression(projectDir, sf, checker, viewName, decl.initializer.template);\n\n        switch (sqlViewDefinition.type) {\n            case \"Left\":\n                return E.left(sqlViewDefinition.value);\n            case \"Right\":\n                return E.right({\n                    viewName: viewName,\n                    qualifiedSqlViewName: qualifiedSqlViewName,\n                    sqlViewDefinition: sqlViewDefinition.value\n                })\n            default:\n                assertNever(sqlViewDefinition);\n        }\n    }\n\n    return;\n}\n\nexport function sqlViewsLibraryAddFromSourceFile(projectDir: string, checker: ts.TypeChecker, sourceFile: ts.SourceFile): [Map<QualifiedSqlViewName, SqlViewDefinition>, ErrorDiagnostic[]] {\n    const viewLibrary = new Map<QualifiedSqlViewName, SqlViewDefinition>();\n    const errorDiagnostics: ErrorDiagnostic[] = [];\n\n    function visit(sf: ts.SourceFile, node: ts.Node) {\n        const sqlDefinitionE = getSqlDefinitionE({ projectDir, sf, checker, node });\n\n        if (sqlDefinitionE !== undefined) {\n            pipe(\n                sqlDefinitionE,\n                E.match(\n                    (diagnostic) => {\n                        errorDiagnostics.push(diagnostic);\n                    },\n                    ({ sqlViewDefinition, qualifiedSqlViewName }) => {\n                        viewLibrary.set(qualifiedSqlViewName, sqlViewDefinition);\n                    }\n                )\n            );\n        }\n    }\n\n    ts.forEachChild(sourceFile, (node: ts.Node) => visit(sourceFile, node));\n\n    return [viewLibrary, errorDiagnostics];\n}\n\nexport function sqlViewLibraryResetToInitialFragmentsIncludingDeps(viewName: QualifiedSqlViewName, viewLibrary: Map<QualifiedSqlViewName, SqlViewDefinition>): void {\n    const view = viewLibrary.get(viewName);\n    if (view !== undefined) {\n        view.resetToInitialFragments();\n        viewLibrary.forEach((value, key) => {\n            if (value.getDependencies().indexOf(viewName) >= 0) {\n                // Make sure we don't get stuck in infinite recursion!\n                if (key !== viewName) {\n                    sqlViewLibraryResetToInitialFragmentsIncludingDeps(key, viewLibrary);\n                }\n            }\n        });\n    }\n}\n","import * as ts from \"typescript\";\n\n/**\n * Pair of ModuleId + string\n */\nexport class ModuleId {\n    static wrap(moduleId: string): ModuleId {\n        return moduleId as any;\n    }\n\n    static unwrap(val: ModuleId): string {\n        return val as any;\n    }\n\n    protected _dummy: ModuleId[];\n}\n\nexport function identifierImportedFrom(sourceFile: ts.SourceFile, ident: ts.Identifier): string | null {\n    let moduleSpecifierText: string | null = null;\n    let foundMultiple = false;\n\n    ts.forEachChild(sourceFile, node => {\n        if (ts.isImportDeclaration(node)) {\n            if (node.importClause !== undefined && node.importClause.namedBindings !== undefined) {\n                if (ts.isNamedImports(node.importClause.namedBindings)) {\n                    for (const elem of node.importClause.namedBindings.elements) {\n                        if (elem.name.text === ident.text) {\n                            if (moduleSpecifierText !== null) {\n                                foundMultiple = true;\n                            }\n                            moduleSpecifierText = (<ts.StringLiteral>node.moduleSpecifier).text;\n                        }\n                    }\n                }\n            }\n        }\n    });\n\n    if (foundMultiple) {\n        return null;\n    } else {\n        return moduleSpecifierText;\n    }\n}\n","import * as crypto from \"crypto\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport { parse } from \"pg-connection-string\";\nimport * as postgres from \"postgres\";\nimport { closePg, connectPg } from \"./pg_extra\";\n\nconst migrationsRegex = /^V\\d+__.*\\.sql$/;\n\nexport function isMigrationFile(fileName: string): boolean {\n    return migrationsRegex.test(fileName);\n}\n\nexport async function calcDbMigrationsHash(migrationsDir: string): Promise<string> {\n\n    const hash = await calcDirectoryContentsHash(\"sha1\", migrationsDir, isMigrationFile);\n    return hash;\n}\n\n/**\n * Calculate a cryptographic hash of the contents of a directory. This can be\n * used to detect if any files in the directory have changed (or were\n * added/removed).\n *\n * @param hashAlgorithm An algorithm supported by the crypto module. For\n * example, \"sha1\" or \"md5\"\n *\n * @param dir The directory to be scanned. NOTE: There is currently a limitation\n * where this directory can only contain files (no subdirectories)\n *\n * @param fileFilter A filter that can be used to ignore certain files. Only\n * files that pass the filter will be used.\n */\nasync function calcDirectoryContentsHash(hashAlgorithm: string, dir: string, fileFilter: (fileName: string) => boolean): Promise<string> {\n    const allFiles = await readdirAsync(dir);\n\n    const matchingFiles = allFiles.filter(fileFilter).sort();\n\n    const shasum = crypto.createHash(hashAlgorithm);\n    for (const fileName of matchingFiles) {\n        shasum.update(fileName);\n        const fileHash = await calcFileHash(path.join(dir, fileName), hashAlgorithm);\n        shasum.update(fileHash);\n    }\n\n    return shasum.digest(\"hex\");\n}\n\n/**\n * Connect to the same database cluster, but a different database\n */\nexport function connReplaceDbName(url: string, dbName: string): string {\n    const p = parse(url);\n    return `postgres://${p.user}:${p.password}@${p.host}:${p.port}/${dbName}${p.ssl === true ? \"?ssl=true\" : \"\"}`;\n}\n\n/**\n * Safety feature to prevent us messing with or deleting the production database!!!!\n */\nexport function isTestDatabaseCluster(url: string): boolean {\n    const p = parse(url);\n    return p.host === \"localhost\" || p.host === \"127.0.0.1\";\n}\n\nasync function logWithTiming<A>(message: string, action: () => Promise<A>) {\n    const startTime = new Date();\n    const result = await action();\n    const endTime = new Date();\n    const totalTime = endTime.getTime() - startTime.getTime();\n    console.log(`${totalTime}ms ${message}`);\n    return result;\n}\n\nexport function validateTestDatabaseCluster(url: string): void {\n    if (!isTestDatabaseCluster(url)) {\n        let err: string = \"\";\n        err += \"About to run tests, but I have detected that this is not a test database cluster!\\n\";\n        err += \"Aborting for your safety!\\n\";\n        err += `This is the database you requested to connect to: ${JSON.stringify(url)}`;\n        throw new Error(err);\n    }\n}\n\n/**\n * @param testDb the name of the database, as returned from `createTestDb`\n */\nexport async function destroyTestDb(adminUrl: string, testDb: string): Promise<void> {\n    validateTestDatabaseCluster(adminUrl);\n\n    const adminConn2 = connectPg(adminUrl);\n    try {\n        await logWithTiming(`Drop test db: ${testDb}`, async () => {\n            await dropDatabase(adminConn2, testDb);\n        });\n    } finally {\n        await closePg(adminConn2);\n    }\n}\n\nexport async function databaseExists(conn: postgres.Sql, dbName: string): Promise<boolean> {\n    const rows = await conn.unsafe(\"SELECT 1 FROM pg_database WHERE datname=$1\", [dbName]);\n\n    return rows.count > 0;\n}\n\nexport async function createBlankDatabase(conn: postgres.Sql, dbName: string): Promise<void> {\n    await conn.unsafe(`CREATE DATABASE ${dbName} WITH TEMPLATE template0`);\n}\n\nexport async function dropDatabase(conn: postgres.Sql, dbName: string): Promise<void> {\n    await conn.unsafe(\n        `\n        SELECT pg_terminate_backend(pg_stat_activity.pid)\n        FROM pg_stat_activity\n        WHERE pg_stat_activity.datname = '${dbName}'\n        `);\n\n    await conn.unsafe(`DROP DATABASE IF EXISTS ${dbName}`);\n}\n\nexport function readdirAsync(dir: string): Promise<string[]> {\n    return new Promise<string[]>((resolve, reject) => {\n        fs.readdir(dir, (err, files) => {\n            if (<any>err) {\n                reject(err);\n                return;\n            }\n\n            resolve(files);\n        });\n    });\n}\n\nfunction calcFileHash(filename: string, hashAlgorithm: string): Promise<string> {\n    return new Promise((resolve, reject) => {\n        const shasum = crypto.createHash(hashAlgorithm);\n        try {\n            const s = fs.createReadStream(filename, { encoding: \"utf8\" });\n            s.on(\"data\", (data) => {\n                shasum.update(data);\n            });\n            s.on(\"error\", (err) => {\n                reject(err);\n            });\n            s.on(\"end\", () => {\n                const hash = shasum.digest(\"hex\");\n                resolve(hash);\n            });\n        } catch (error) {\n            reject(\"calc fail\");\n        }\n    });\n}\n\nexport function testDatabaseName(): Promise<string> {\n    return new Promise<string>((resolve, reject) => {\n        crypto.randomBytes(16, (err, buf) => {\n            if (<boolean>(<any>err)) {\n                reject(err);\n                return;\n            }\n\n            const dbName = \"db_test_\" + buf.toString(\"hex\");\n            resolve(dbName);\n        });\n    });\n}\n","import { assertNever } from \"assert-never\";\nimport chalk from \"chalk\";\nimport * as E from \"fp-ts/Either\";\nimport { pipe } from \"fp-ts/function\";\nimport * as TE from \"fp-ts/TaskEither\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as postgres from \"postgres\";\nimport invariant from \"tiny-invariant\";\n\nimport {\n    ColTypesFormat,\n    defaultColTypesFormat,\n    equalsUniqueTableColumnTypes,\n    makeUniqueColumnTypes,\n    sqlUniqueTypeName,\n    UniqueTableColumnType\n} from \"../../mfsqlchecker/ConfigFile\";\nimport {\n    ErrorDiagnostic,\n    postgresqlErrorDiagnostic,\n    SrcSpan,\n    toSrcSpan\n} from \"../../mfsqlchecker/ErrorDiagnostic\";\nimport {\n    closePg,\n    connectPg,\n    dropAllFunctions,\n    dropAllSequences,\n    dropAllTables,\n    dropAllTypes,\n    escapeIdentifier,\n    parsePostgreSqlError,\n    pgDescribeQuery,\n    PostgreSqlError\n} from \"../../mfsqlchecker/pg_extra\";\nimport {\n    calcDbMigrationsHash,\n    connReplaceDbName,\n    createBlankDatabase,\n    dropDatabase,\n    isMigrationFile,\n    readdirAsync,\n    testDatabaseName\n} from \"../../mfsqlchecker/pg_test_db\";\nimport {\n    ColNullability,\n    ResolvedInsert,\n    ResolvedSelect,\n    SqlType,\n    TypeScriptType\n} from \"../../mfsqlchecker/queries\";\nimport { resolveFromSourceMap } from \"../../mfsqlchecker/source_maps\";\nimport { QualifiedSqlViewName, SqlCreateView } from \"../../mfsqlchecker/views\";\nimport { InvalidQueryError } from \"./errors\";\nimport { customLog } from \"./log\";\n\ntype QueryRunnerConfig = {\n    migrationsDir: string;\n    client: postgres.Sql;\n};\n\nexport class QueryRunner {\n    private migrationsDir: string;\n    private client: postgres.Sql;\n\n    constructor(config: QueryRunnerConfig) {\n        this.migrationsDir = config.migrationsDir;\n        this.client = config.client;\n    }\n\n    static async Connect(params: {\n        sql: postgres.Sql;\n        adminUrl: string;\n        name?: string;\n        migrationsDir: string;\n    }) {\n        const client = await newConnect(params.sql, params.adminUrl, params.name);\n        return new QueryRunner({ migrationsDir: params.migrationsDir, client });\n    }\n\n    static ConnectTE(params: {\n        sql: postgres.Sql;\n        adminUrl: string;\n        name?: string;\n        migrationsDir: string;\n    }) {\n        return pipe(\n            TE.tryCatch(() => QueryRunner.Connect(params), E.toError),\n            TE.mapLeft(formatPgError)\n        );\n    }\n\n    private dbMigrationsHash: string = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\";\n    private prevUniqueTableColumnTypes: UniqueTableColumnType[] = [];\n    private queryCache = new QueryMap<SelectAnswer>();\n    private insertCache = new InsertMap<InsertAnswer>();\n    private viewNames: [string, ViewAnswer][] = [];\n    private pgTypes = new Map<number, SqlType>();\n    private uniqueColumnTypes = new Map<SqlType, TypeScriptType>();\n    private tableColsLibrary = new TableColsLibrary();\n    private prevStrictDateTimeChecking: boolean | null = null;\n\n    initializeTE(params: {\n        uniqueTableColumnTypes: UniqueTableColumnType[];\n        strictDateTimeChecking: boolean;\n        sqlViews: SqlCreateView[];\n    }): TE.TaskEither<Error | InvalidQueryError, undefined> {\n        return pipe(\n            TE.Do,\n            TE.chain(() => TE.tryCatch(() => this.initialize(params), E.toError)),\n            TE.match(\n                (error) => E.left(error),\n                (result) => {\n                    return result.length === 0\n                        ? E.right(undefined)\n                        : E.left(new InvalidQueryError(result));\n                }\n            )\n        );\n    }\n\n    async updateViews(params: { strictDateTimeChecking: boolean; sqlViews: SqlCreateView[] }) {\n        if (params.strictDateTimeChecking !== this.prevStrictDateTimeChecking) {\n            await this.dropViews();\n        }\n\n        this.prevStrictDateTimeChecking = params.strictDateTimeChecking;\n\n        let queryErrors: ErrorDiagnostic[] = [];\n\n        const [updated, newViewNames] = await updateViews(\n            this.client,\n            params.strictDateTimeChecking,\n            this.viewNames,\n            params.sqlViews\n        );\n\n        if (updated) {\n            await this.tableColsLibrary.refreshViews(this.client);\n        }\n\n        this.viewNames = newViewNames;\n\n        for (const [viewName, viewAnswer] of this.viewNames) {\n            const createView = params.sqlViews.find((x) => x.viewName === viewName);\n            invariant(createView !== undefined, `view ${viewName} not found (probably a bug).`);\n            queryErrors = queryErrors.concat(viewAnswerToErrorDiagnostics(createView, viewAnswer));\n        }\n\n        return queryErrors;\n    }\n\n    async initialize(params: {\n        uniqueTableColumnTypes: UniqueTableColumnType[];\n        strictDateTimeChecking: boolean;\n        sqlViews: SqlCreateView[];\n    }) {\n        this.queryCache = new QueryMap<SelectAnswer>();\n        this.insertCache = new InsertMap<InsertAnswer>();\n\n        const hash = await calcDbMigrationsHash(this.migrationsDir);\n\n        if (\n            this.dbMigrationsHash !== hash ||\n            !equalsUniqueTableColumnTypes(\n                params.uniqueTableColumnTypes,\n                this.prevUniqueTableColumnTypes\n            )\n        ) {\n            this.dbMigrationsHash = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\";\n            this.queryCache.clear();\n            this.insertCache.clear();\n            await this.dropViews();\n\n            await dropAllTables(this.client);\n            await dropAllSequences(this.client);\n            await dropAllTypes(this.client);\n            await dropAllFunctions(this.client);\n\n            const allFiles = await readdirAsync(this.migrationsDir);\n            const matchingFiles = allFiles.filter(isMigrationFile).sort();\n            for (const matchingFile of matchingFiles) {\n                customLog.info(\"running migration\", matchingFile);\n                const text = await readFileAsync(path.join(this.migrationsDir, matchingFile));\n                try {\n                    await this.client.unsafe(text);\n                } catch (err) {\n                    const postgresError = parsePostgreSqlError(err);\n                    if (postgresError === null) {\n                        throw err;\n                    }\n\n                    const errorDiagnostic = postgresqlErrorDiagnostic(\n                        path.join(this.migrationsDir, matchingFile),\n                        text,\n                        postgresError,\n                        postgresError.position !== null\n                            ? toSrcSpan(text, postgresError.position)\n                            : { type: \"File\" },\n                        \"Error in migration file\"\n                    );\n\n                    return [errorDiagnostic];\n                }\n            }\n\n            this.prevUniqueTableColumnTypes = params.uniqueTableColumnTypes;\n\n            this.uniqueColumnTypes = makeUniqueColumnTypes(this.prevUniqueTableColumnTypes);\n            customLog.success(\"start applying unique table column types...\");\n            await applyUniqueTableColumnTypes(this.client, this.prevUniqueTableColumnTypes);\n            customLog.success(\"done applying unique table column types\");\n\n            await this.tableColsLibrary.refreshTables(this.client);\n\n            this.pgTypes = new Map<number, SqlType>();\n            const pgTypesResult = await this.client.unsafe(\n                `\n                SELECT\n                    oid,\n                    typname\n                FROM pg_type\n                ORDER BY oid\n                `\n            );\n            for (const row of pgTypesResult) {\n                const oid: number = row[\"oid\"];\n                const typname: string = row[\"typname\"];\n                this.pgTypes.set(oid, SqlType.wrap(typname));\n            }\n            this.dbMigrationsHash = hash;\n        }\n\n        const diagnostics = await this.updateViews(params);\n\n        // We modify the system catalogs only inside a transaction, so that we\n        // can ROLLBACK the changes later. This is needed so that in the\n        // future if we need to run our migrations again, they can be run on\n        // the original system catalogs.\n        // await this.client.unsafe(\"BEGIN\");\n\n        if (params.strictDateTimeChecking) {\n            await modifySystemCatalogs(this.client);\n        }\n\n        return diagnostics;\n    }\n\n    async runQuery(params: { resolved: ResolvedSelect }) {\n        const answer = await processQuery(\n            this.client,\n            defaultColTypesFormat,\n            this.pgTypes,\n            this.tableColsLibrary,\n            this.uniqueColumnTypes,\n            params.resolved\n        );\n\n        return queryAnswerToErrorDiagnostics(params.resolved, answer, defaultColTypesFormat);\n    }\n\n    async runInsert(params: { resolved: ResolvedInsert }) {\n        const answer = await processInsert(\n            this.client,\n            defaultColTypesFormat,\n            this.pgTypes,\n            this.tableColsLibrary,\n            this.uniqueColumnTypes,\n            params.resolved\n        );\n\n        return insertAnswerToErrorDiagnostics(params.resolved, answer, defaultColTypesFormat);\n    }\n\n    async end() {\n        await this.client.end();\n    }\n\n    private async dropViews(): Promise<void> {\n        for (let i = this.viewNames.length - 1; i >= 0; --i) {\n            const viewName = this.viewNames[i];\n            await dropView(this.client, viewName[0]);\n        }\n        this.viewNames = [];\n    }\n}\n\nasync function dropView(client: postgres.Sql, viewName: string): Promise<void> {\n    await client.unsafe(`DROP VIEW IF EXISTS ${escapeIdentifier(viewName)}`);\n}\n\n/**\n * @returns Array with the same length as `newViews`, with a matching element\n * for each view in `newViews`\n */\nasync function updateViews(\n    client: postgres.Sql,\n    strictDateTimeChecking: boolean,\n    oldViews: [string, ViewAnswer][],\n    newViews: SqlCreateView[]\n): Promise<[boolean, [string, ViewAnswer][]]> {\n    let updated: boolean = false;\n\n    const newViewNames = new Set<string>();\n    newViews.forEach((v) => newViewNames.add(v.viewName));\n\n    for (let i = oldViews.length - 1; i >= 0; --i) {\n        const viewName = oldViews[i];\n        if (!newViewNames.has(viewName[0])) {\n            await dropView(client, viewName[0]);\n            updated = true;\n        }\n    }\n\n    const oldViewAnswers = new Map<string, ViewAnswer>();\n    oldViews.forEach(([viewName, viewAnswer]) => oldViewAnswers.set(viewName, viewAnswer));\n\n    const result: [string, ViewAnswer][] = [];\n\n    for (const view of newViews) {\n        const oldAnswer = oldViewAnswers.get(view.viewName);\n        if (oldAnswer !== undefined) {\n            result.push([view.viewName, oldAnswer]);\n        } else {\n            const answer = await processCreateView(client, strictDateTimeChecking, view);\n            result.push([view.viewName, answer]);\n            updated = true;\n        }\n    }\n\n    return [updated, result];\n}\n\n// This regexp is a bit of a hack, but hopefully works. The goal is to still\n// allow COUNT(*) as well as multiplication\nconst SELECT_STAR_REGEX = new RegExp(\"(select|\\\\.|\\\\,)\\\\s*\\\\*\", \"i\");\n\nfunction validateViewFeatures(view: SqlCreateView): ViewAnswer {\n    // We don't allow using `SELECT *` in views.\n    //\n    // The reason is that PostgreSQL will expand the star only once, at\n    // view-create time (not each time the view is queried). This can cause bad\n    // inconsistencies where old views will not have the expected columns. Even\n    // worse, it can cause the DB migration to fail on the \"CREATE OR REPLACE\n    // VIEW ...\" call when an existing view exists but the expanded column lists\n    // differ.\n\n    const searchIndex = view.createQuery.search(SELECT_STAR_REGEX);\n    if (searchIndex >= 0) {\n        return {\n            type: \"InvalidFeatureError\",\n            viewName: view.viewName,\n            message: \"SELECT * not allowed in views. List all columns explicitly\",\n            position: view.createQuery.indexOf(\"*\", searchIndex) + 1\n        };\n    }\n\n    return {\n        type: \"NoErrors\"\n    };\n}\n\nasync function processCreateView(\n    client: postgres.Sql,\n    strictDateTimeChecking: boolean,\n    view: SqlCreateView\n): Promise<ViewAnswer> {\n    // await client.unsafe(\"BEGIN\");\n    if (strictDateTimeChecking) {\n        await modifySystemCatalogs(client);\n    }\n    try {\n        await client.unsafe(\n            `CREATE OR REPLACE VIEW ${escapeIdentifier(view.viewName)} AS ${view.createQuery}`\n        );\n    } catch (err) {\n        const perr = parsePostgreSqlError(err);\n        if (perr === null) {\n            throw err;\n        } else {\n            await client.unsafe(\"ROLLBACK\");\n            if (perr.position !== null) {\n                // A bit hacky but does the trick:\n                perr.position -= `CREATE OR REPLACE VIEW ${escapeIdentifier(\n                    view.viewName\n                )} AS `.length;\n            }\n            return {\n                type: \"CreateError\",\n                viewName: QualifiedSqlViewName.viewName(view.qualifiedViewname),\n                perr: perr\n            };\n        }\n    }\n\n    // We need to ROLLBACK in order to restore the system catalogs, but the\n    // rollback will also undo the VIEW we just created. So after the rollback\n    // we need to create the VIEW again. Since it succeeded the first time, it\n    // should also succeed the second time (the modifications we make to the\n    // system catalogs only make things more restrictive)\n\n    await client.unsafe(\"ROLLBACK\");\n    await client.unsafe(\n        `CREATE OR REPLACE VIEW ${escapeIdentifier(view.viewName)} AS ${view.createQuery}`\n    );\n\n    const invalidFeatureError = validateViewFeatures(view);\n    if (invalidFeatureError.type !== \"NoErrors\") {\n        return invalidFeatureError;\n    }\n\n    return {\n        type: \"NoErrors\"\n    };\n}\n\ntype ViewAnswer = ViewAnswer.NoErrors | ViewAnswer.CreateError | ViewAnswer.InvalidFeatureError;\n\nnamespace ViewAnswer {\n    export interface NoErrors {\n        type: \"NoErrors\";\n    }\n\n    export interface CreateError {\n        type: \"CreateError\";\n        viewName: string;\n        perr: PostgreSqlError;\n    }\n\n    export interface InvalidFeatureError {\n        type: \"InvalidFeatureError\";\n        viewName: string;\n        message: string;\n        position: number;\n    }\n}\n\nfunction viewAnswerToErrorDiagnostics(\n    createView: SqlCreateView,\n    viewAnswer: ViewAnswer\n): ErrorDiagnostic[] {\n    switch (viewAnswer.type) {\n        case \"NoErrors\":\n            return [];\n        case \"CreateError\": {\n            const message = 'Error in view \"' + chalk.bold(viewAnswer.viewName) + '\"';\n            if (viewAnswer.perr.position !== null) {\n                const srcSpan = resolveFromSourceMap(\n                    createView.fileContents,\n                    viewAnswer.perr.position - 1,\n                    createView.sourceMap\n                );\n                return [\n                    postgresqlErrorDiagnostic(\n                        createView.fileName,\n                        createView.fileContents,\n                        viewAnswer.perr,\n                        srcSpan,\n                        message\n                    )\n                ];\n            } else {\n                return [\n                    postgresqlErrorDiagnostic(\n                        createView.fileName,\n                        createView.fileContents,\n                        viewAnswer.perr,\n                        querySourceStart(createView.fileContents, createView.sourceMap),\n                        message\n                    )\n                ];\n            }\n        }\n        case \"InvalidFeatureError\": {\n            const srcSpan = resolveFromSourceMap(\n                createView.fileContents,\n                viewAnswer.position - 1,\n                createView.sourceMap\n            );\n            return [\n                {\n                    fileName: createView.fileName,\n                    fileContents: createView.fileContents,\n                    span: srcSpan,\n                    messages: [\n                        chalk.bold('Error in view \"' + chalk.bold(viewAnswer.viewName) + '\"'),\n                        viewAnswer.message\n                    ],\n                    epilogue: null,\n                    quickFix: null\n                }\n            ];\n        }\n        default:\n            return assertNever(viewAnswer);\n    }\n}\n\n/**\n * Type safe \"Map\"-like from queries to some T\n */\nclass QueryMap<T> {\n    set(\n        text: string,\n        colTypes: Map<string, [ColNullability, TypeScriptType]> | null,\n        value: T\n    ): void {\n        this.internalMap.set(QueryMap.toKey(text, colTypes), value);\n    }\n\n    get(\n        text: string,\n        colTypes: Map<string, [ColNullability, TypeScriptType]> | null\n    ): T | undefined {\n        return this.internalMap.get(QueryMap.toKey(text, colTypes));\n    }\n\n    clear(): void {\n        this.internalMap = new Map<string, T>();\n    }\n\n    private static toKey(\n        text: string,\n        colTypes: Map<string, [ColNullability, TypeScriptType]> | null\n    ): string {\n        // TODO Will this really always give a properly unique key?\n        return text + (colTypes === null ? \"[NULL]\" : stringifyColTypes(colTypes));\n    }\n\n    private internalMap = new Map<string, T>();\n}\n\n/**\n * Type safe \"Map\"-like from insert queries to some T\n */\nclass InsertMap<T> {\n    set(\n        text: string,\n        colTypes: Map<string, [ColNullability, TypeScriptType]> | null,\n        tableName: string,\n        insertColumns: Map<string, [TypeScriptType, boolean]>,\n        value: T\n    ): void {\n        this.internalMap.set(InsertMap.toKey(text, colTypes, tableName, insertColumns), value);\n    }\n\n    get(\n        text: string,\n        colTypes: Map<string, [ColNullability, TypeScriptType]> | null,\n        tableName: string,\n        insertColumns: Map<string, [TypeScriptType, boolean]>\n    ): T | undefined {\n        return this.internalMap.get(InsertMap.toKey(text, colTypes, tableName, insertColumns));\n    }\n\n    clear(): void {\n        this.internalMap = new Map<string, T>();\n    }\n\n    private static toKey(\n        text: string,\n        colTypes: Map<string, [ColNullability, TypeScriptType]> | null,\n        tableName: string,\n        insertColumns: Map<string, [TypeScriptType, boolean]>\n    ): string {\n        // TODO Will this really always give a properly unique key?\n        return (\n            text +\n            (colTypes === null ? \"\" : stringifyColTypes(colTypes)) +\n            '\"' +\n            tableName +\n            '\"' +\n            stringifyInsertColumns(insertColumns)\n        );\n    }\n\n    private internalMap = new Map<string, T>();\n}\n\nfunction stringifyInsertColumns(insertColumns: Map<string, [TypeScriptType, boolean]>): string {\n    const keys = [...insertColumns.keys()];\n    keys.sort();\n    let result = \"\";\n    for (const key of keys) {\n        const value = insertColumns.get(key);\n        if (value === undefined) {\n            throw new Error(\"The Impossible Happened\");\n        }\n        result += `${JSON.stringify(key)}:[${value[0]}, ${value[1]}]\\n`;\n    }\n    return result;\n}\n\nexport type SelectAnswer =\n    | QueryAnswer.NoErrors\n    | QueryAnswer.DescribeError\n    | QueryAnswer.DuplicateColNamesError\n    | QueryAnswer.WrongColumnTypes;\n\ntype InsertAnswer =\n    | QueryAnswer.NoErrors\n    | QueryAnswer.DescribeError\n    | QueryAnswer.DuplicateColNamesError\n    | QueryAnswer.WrongColumnTypes\n    | QueryAnswer.InvalidTableName\n    | QueryAnswer.InvalidInsertCols;\n\nnamespace QueryAnswer {\n    export interface NoErrors {\n        type: \"NoErrors\";\n    }\n\n    export interface DescribeError {\n        type: \"DescribeError\";\n        perr: PostgreSqlError;\n    }\n\n    export interface DuplicateColNamesError {\n        type: \"DuplicateColNamesError\";\n        duplicateResultColumns: string[];\n    }\n\n    export interface WrongColumnTypes {\n        type: \"WrongColumnTypes\";\n        renderedColTypes: string;\n    }\n\n    export interface InvalidTableName {\n        type: \"InvalidTableName\";\n    }\n\n    export type InvalidInsertCol =\n        | InvalidInsertCol.MissingRequiredCol\n        | InvalidInsertCol.ColWrongType\n        | InvalidInsertCol.ColNotFound;\n\n    export namespace InvalidInsertCol {\n        export interface MissingRequiredCol {\n            type: \"MissingRequiredCol\";\n            tableName: string;\n            colName: string;\n            colType: TypeScriptType;\n        }\n\n        export interface ColWrongType {\n            type: \"ColWrongType\";\n            tableName: string;\n            colName: string;\n            colType: TypeScriptType;\n            invalidType: TypeScriptType;\n        }\n\n        export interface ColNotFound {\n            type: \"ColNotFound\";\n            tableName: string;\n            colName: string;\n            invalidType: TypeScriptType;\n        }\n    }\n\n    export interface InvalidInsertCols {\n        type: \"InvalidInsertCols\";\n        invalidCols: InvalidInsertCol[];\n    }\n}\n\nfunction querySourceStart(fileContents: string, sourceMap: [number, number, number][]): SrcSpan {\n    return toSrcSpan(\n        fileContents,\n        fileContents.slice(sourceMap[0][0] + 1).search(/\\S/) + sourceMap[0][0] + 2\n    );\n}\n\nfunction queryAnswerToErrorDiagnostics(\n    query: ResolvedSelect,\n    queryAnswer: SelectAnswer,\n    colTypesFormat: ColTypesFormat\n): ErrorDiagnostic[] {\n    switch (queryAnswer.type) {\n        case \"NoErrors\":\n            return [];\n        case \"DescribeError\":\n            if (queryAnswer.perr.position !== null) {\n                const srcSpan = resolveFromSourceMap(\n                    query.fileContents,\n                    queryAnswer.perr.position - 1,\n                    query.sourceMap\n                );\n                return [\n                    postgresqlErrorDiagnostic(\n                        query.fileName,\n                        query.fileContents,\n                        queryAnswer.perr,\n                        srcSpan,\n                        null\n                    )\n                ];\n            } else {\n                return [\n                    postgresqlErrorDiagnostic(\n                        query.fileName,\n                        query.fileContents,\n                        queryAnswer.perr,\n                        querySourceStart(query.fileContents, query.sourceMap),\n                        null\n                    )\n                ];\n            }\n        case \"DuplicateColNamesError\":\n            return [\n                {\n                    fileName: query.fileName,\n                    fileContents: query.fileContents,\n                    span: querySourceStart(query.fileContents, query.sourceMap),\n                    messages: [\n                        `Query return row contains duplicate column names:\\n${JSON.stringify(\n                            queryAnswer.duplicateResultColumns,\n                            null,\n                            2\n                        )}`\n                    ],\n                    epilogue:\n                        chalk.bold(\"hint\") +\n                        ': Specify a different name for the column using the Sql \"AS\" keyword',\n                    quickFix: null\n                }\n            ];\n        case \"WrongColumnTypes\":\n            let replacementText: string;\n\n            let colTypes = queryAnswer.renderedColTypes.split(\"\\n\");\n\n            // `colTypes` looks something like:\n            //\n            //     [ \"{\",\n            //       \"    foo: Req<number>,\",\n            //       \"    bar: Opt<string>\",\n            //       \"}\"\n            //     ]\n\n            if (colTypes.length <= 2) {\n                // {\n                // }\n                replacementText = \"<{}>\";\n            } else if (colTypes.length === 3) {\n                // {\n                //   foo: Req<number>\n                // }\n                colTypes = colTypes.map((c) => c.trimLeft());\n                colTypes[1] = \" \".repeat(query.indentLevel + 4) + colTypes[1];\n                colTypes[2] = \" \".repeat(query.indentLevel) + colTypes[2];\n                replacementText = \"<\" + colTypes.join(\"\\n\") + \">\";\n            } else if (colTypes.length > 3) {\n                // {\n                //   foo: Req<number>,\n                //   bar: Opt<string>\n                // }\n                colTypes = colTypes.map((c) => c.trimLeft());\n                for (let i = 1; i < colTypes.length - 1; ++i) {\n                    colTypes[i] = \" \".repeat(query.indentLevel + 4) + colTypes[i];\n                }\n                colTypes[colTypes.length - 1] =\n                    \" \".repeat(query.indentLevel) + colTypes[colTypes.length - 1];\n\n                if (colTypesFormat.includeRegionMarker) {\n                    colTypes.splice(1, 0, \" \".repeat(query.indentLevel + 4) + \"//#region ColTypes\");\n                    colTypes.splice(\n                        colTypes.length - 1,\n                        0,\n                        \" \".repeat(query.indentLevel + 4) + \"//#endregion\"\n                    );\n                }\n\n                replacementText = \"<\" + colTypes.join(\"\\n\") + \">\";\n            } else {\n                throw new Error(`Invalid colTypes.length: ${queryAnswer.renderedColTypes}`);\n            }\n\n            if (query.queryMethodName !== null) {\n                replacementText = query.queryMethodName + replacementText;\n            }\n\n            return [\n                {\n                    fileName: query.fileName,\n                    fileContents: query.fileContents,\n                    span: query.colTypeSpan,\n                    messages: [\"Wrong Column Types\"],\n                    epilogue: chalk.bold(\"Fix it to:\") + \"\\n\" + queryAnswer.renderedColTypes,\n                    quickFix: {\n                        name: \"Fix Column Types\",\n                        replacementText: replacementText\n                    }\n                }\n            ];\n        default:\n            return assertNever(queryAnswer);\n    }\n}\n\nfunction insertAnswerToErrorDiagnostics(\n    query: ResolvedInsert,\n    queryAnswer: InsertAnswer,\n    colTypesFormat: ColTypesFormat\n): ErrorDiagnostic[] {\n    switch (queryAnswer.type) {\n        case \"NoErrors\":\n            return [];\n        case \"DescribeError\":\n        case \"DuplicateColNamesError\":\n        case \"WrongColumnTypes\":\n            return queryAnswerToErrorDiagnostics(query, queryAnswer, colTypesFormat);\n        case \"InvalidTableName\":\n            return [\n                {\n                    fileName: query.fileName,\n                    fileContents: query.fileContents,\n                    span: query.tableNameExprSpan,\n                    messages: [`Table does not exist: \"${query.tableName}\"`],\n                    epilogue: null,\n                    quickFix: null\n                }\n            ];\n        case \"InvalidInsertCols\":\n            return [\n                {\n                    fileName: query.fileName,\n                    fileContents: query.fileContents,\n                    span: query.insertExprSpan,\n                    messages: [\"Inserted columns are invalid:\"].concat(\n                        queryAnswer.invalidCols.map((e) => {\n                            switch (e.type) {\n                                case \"MissingRequiredCol\":\n                                    return `Insert to table \"${e.tableName}\" is missing the required column: \"${e.colName}\" (type \"${e.colType}\")`;\n                                case \"ColWrongType\":\n                                    return `Insert to table \"${e.tableName}\" has the wrong type for column \"${e.colName}\". It should be \"${e.colType}\" (instead of \"${e.invalidType}\")`;\n                                case \"ColNotFound\":\n                                    return `Column \"${e.colName}\" does not exist on table \"${e.tableName}\"`;\n                                default:\n                                    return assertNever(e);\n                            }\n                        })\n                    ),\n                    epilogue: null,\n                    quickFix: null\n                }\n            ];\n        default:\n            return assertNever(queryAnswer);\n    }\n}\n\nasync function processQuery(\n    client: postgres.Sql,\n    colTypesFormat: ColTypesFormat,\n    pgTypes: Map<number, SqlType>,\n    tableColsLibrary: TableColsLibrary,\n    uniqueColumnTypes: Map<SqlType, TypeScriptType>,\n    query: Pick<ResolvedSelect, \"colTypes\" | \"text\">\n): Promise<SelectAnswer> {\n    let fields: postgres.ColumnList<string> | null;\n    // const savepoint = await newSavepoint(client);\n    try {\n        fields = await pgDescribeQuery(client, query.text);\n    } catch (err) {\n        const perr = parsePostgreSqlError(err);\n        if (perr === null) {\n            throw err;\n        } else {\n            // await rollbackToAndReleaseSavepoint(client, savepoint);\n            return {\n                type: \"DescribeError\",\n                perr: perr\n            };\n        }\n    }\n    // await rollbackToAndReleaseSavepoint(client, savepoint);\n\n    const duplicateResultColumns: string[] = [];\n    if (fields === null) {\n        if (query.colTypes !== null && query.colTypes.size !== 0) {\n            return {\n                type: \"WrongColumnTypes\",\n                renderedColTypes: \"{} (Or no type argument at all)\"\n            };\n        }\n    } else {\n        for (let i = 0; i < fields.length; ++i) {\n            const field = fields[i];\n            if (\n                fields.slice(i + 1).findIndex((f) => f.name === field.name) >= 0 &&\n                duplicateResultColumns.indexOf(field.name) < 0\n            ) {\n                duplicateResultColumns.push(field.name);\n            }\n        }\n\n        if (duplicateResultColumns.length > 0) {\n            return {\n                type: \"DuplicateColNamesError\",\n                duplicateResultColumns: duplicateResultColumns\n            };\n        }\n\n        const sqlFields = resolveFieldDefs(tableColsLibrary, pgTypes, uniqueColumnTypes, fields);\n        if (\n            query.colTypes !== null &&\n            stringifyColTypes(query.colTypes) !== stringifyColTypes(sqlFields)\n        ) {\n            return {\n                type: \"WrongColumnTypes\",\n                renderedColTypes: renderColTypesType(colTypesFormat, sqlFields)\n            };\n        }\n    }\n\n    return {\n        type: \"NoErrors\"\n    };\n}\n\nasync function processInsert(\n    client: postgres.Sql,\n    colTypesFormat: ColTypesFormat,\n    pgTypes: Map<number, SqlType>,\n    tableColsLibrary: TableColsLibrary,\n    uniqueColumnTypes: Map<SqlType, TypeScriptType>,\n    query: ResolvedInsert\n): Promise<InsertAnswer> {\n    const tableQuery = await client.unsafe(\n        `\n        select\n            pg_attribute.attname,\n            pg_type.typname,\n            pg_attribute.atthasdef,\n            pg_attribute.attnotnull\n        from\n            pg_attribute,\n            pg_class,\n            pg_type\n        where\n        pg_attribute.attrelid = pg_class.oid\n        AND pg_attribute.attnum >= 1\n        AND pg_attribute.atttypid = pg_type.oid\n        AND pg_class.relname = $1\n        ORDER BY pg_attribute.attname\n        `,\n        [query.tableName]\n    );\n\n    // Assume that tables with no columns cannot exist\n    if (tableQuery.count === 0) {\n        return {\n            type: \"InvalidTableName\"\n        };\n    }\n\n    const result = await processQuery(\n        client,\n        colTypesFormat,\n        pgTypes,\n        tableColsLibrary,\n        uniqueColumnTypes,\n        query\n    );\n    if (result.type !== \"NoErrors\") {\n        return result;\n    }\n\n    const insertColumnFields = [...query.insertColumns.keys()];\n    insertColumnFields.sort();\n\n    const invalidInsertCols: QueryAnswer.InvalidInsertCol[] = [];\n\n    for (const field of insertColumnFields) {\n        const suppliedType = query.insertColumns.get(field);\n        if (suppliedType === undefined) {\n            throw new Error(\"The Impossible Happened\");\n        }\n\n        const [suppliedTypeName, suppliedTypeNotNull] = suppliedType;\n\n        const row = tableQuery.find((r) => r[\"attname\"] === field);\n        if (row === undefined) {\n            invalidInsertCols.push({\n                type: \"ColNotFound\",\n                tableName: query.tableName,\n                colName: field,\n                invalidType: suppliedTypeName\n            });\n        } else {\n            const typname: string = row[\"typname\"];\n            const attnotnull: boolean = row[\"attnotnull\"];\n            const tblType = sqlTypeToTypeScriptType(uniqueColumnTypes, SqlType.wrap(typname));\n            if (\n                (suppliedTypeName !== TypeScriptType.wrap(\"null\") &&\n                    suppliedTypeName !== tblType) ||\n                (attnotnull && !suppliedTypeNotNull)\n            ) {\n                let suppliedTypeStr = TypeScriptType.unwrap(suppliedTypeName);\n                if (!suppliedTypeNotNull && suppliedTypeStr !== \"null\") {\n                    suppliedTypeStr += \" | null\";\n                }\n\n                let typStr = TypeScriptType.unwrap(tblType);\n                if (!attnotnull) {\n                    typStr += \" | null\";\n                }\n\n                invalidInsertCols.push({\n                    type: \"ColWrongType\",\n                    tableName: query.tableName,\n                    colName: field,\n                    colType: TypeScriptType.wrap(typStr),\n                    invalidType: TypeScriptType.wrap(suppliedTypeStr)\n                });\n            }\n        }\n    }\n\n    for (const row of tableQuery) {\n        const attname: string = row[\"attname\"];\n        const typname: string = row[\"typname\"];\n        const atthasdef: boolean = row[\"atthasdef\"];\n        const attnotnull: boolean = row[\"attnotnull\"];\n        if (!atthasdef) {\n            if (!query.insertColumns.has(attname)) {\n                let typStr = TypeScriptType.unwrap(\n                    sqlTypeToTypeScriptType(uniqueColumnTypes, SqlType.wrap(typname))\n                );\n                if (!attnotnull) {\n                    typStr += \" | null\";\n                }\n\n                invalidInsertCols.push({\n                    type: \"MissingRequiredCol\",\n                    tableName: query.tableName,\n                    colName: attname,\n                    colType: TypeScriptType.wrap(typStr)\n                });\n            }\n        }\n    }\n\n    if (invalidInsertCols.length > 0) {\n        return {\n            type: \"InvalidInsertCols\",\n            invalidCols: invalidInsertCols\n        };\n    } else {\n        return {\n            type: \"NoErrors\"\n        };\n    }\n}\n\nfunction psqlOidSqlType(pgTypes: Map<number, SqlType>, oid: number): SqlType {\n    const name = pgTypes.get(oid);\n    if (name === undefined) {\n        throw new Error(`pg_type oid ${oid} not found`);\n    }\n    return name;\n}\n\nclass TableColsLibrary {\n    /**\n     * After calling this method, you should also call `refreshViews`\n     */\n    public async refreshTables(client: postgres.Sql): Promise<void> {\n        this.tableLookupTable = new Map<string, boolean>();\n\n        // <https://www.postgresql.org/docs/current/catalog-pg-class.html>\n        //     pg_catalog.pg_class.relkind char:\n        //     r = ordinary table\n        //     i = index\n        //     S = sequence\n        //     t = TOAST table\n        //     v = view\n        //     m = materialized view\n        //     c = composite type\n        //     f = foreign table\n        //     p = partitioned table\n        //     I = partitioned index\n\n        const queryResult = await client.unsafe(\n            `\n            SELECT\n                a.attrelid,\n                a.attnum,\n                a.attnotnull\n            FROM\n            pg_catalog.pg_attribute a,\n            pg_catalog.pg_class c\n            WHERE\n            c.oid = a.attrelid\n            AND a.attnum > 0\n            AND c.relkind = 'r'\n            `\n        );\n\n        for (const row of queryResult) {\n            const attrelid: number = row[\"attrelid\"];\n            const attnum: number = row[\"attnum\"];\n            const attnotnull: boolean = row[\"attnotnull\"];\n\n            this.tableLookupTable.set(`${attrelid}-${attnum}`, attnotnull);\n        }\n    }\n\n    public async refreshViews(client: postgres.Sql): Promise<void> {\n        this.viewLookupTable = new Map<string, boolean>();\n\n        // This query was taken from here and (slightly) adapted:\n        // <https://github.com/PostgREST/postgrest/blob/5c75f0dcc295e6bd847af6d9703fad5b9c3d76c9/src/PostgREST/DbStructure.hs#L782>\n        //\n        // Changes from the original query:\n        //   1. Changed returned columns to oid format instead of names\n        //   2. Return all columns (not just primary and foreign keys)\n        const queryResult = await client.unsafe(\n            `\n            with recursive\n            views as (\n              select\n                c.oid       as view_id,\n                n.nspname   as view_schema,\n                c.relname   as view_name,\n                c.oid       as view_oid,\n                r.ev_action as view_definition\n              from pg_class c\n              join pg_namespace n on n.oid = c.relnamespace\n              join pg_rewrite r on r.ev_class = c.oid\n              where c.relkind in ('v', 'm') and n.nspname = 'public'\n            ),\n            transform_json as (\n              select\n                view_id, view_schema, view_name, view_oid,\n                -- the following formatting is without indentation on purpose\n                -- to allow simple diffs, with less whitespace noise\n                replace(\n                  replace(\n                  replace(\n                  replace(\n                  replace(\n                  replace(\n                  replace(\n                  replace(\n                  regexp_replace(\n                  replace(\n                  replace(\n                  replace(\n                  replace(\n                  replace(\n                  replace(\n                  replace(\n                  replace(\n                  replace(\n                  replace(\n                    view_definition::text,\n                  -- This conversion to json is heavily optimized for performance.\n                  -- The general idea is to use as few regexp_replace() calls as possible.\n                  -- Simple replace() is a lot faster, so we jump through some hoops\n                  -- to be able to use regexp_replace() only once.\n                  -- This has been tested against a huge schema with 250+ different views.\n                  -- The unit tests do NOT reflect all possible inputs. Be careful when changing this!\n                  -- -----------------------------------------------\n                  -- pattern           | replacement         | flags\n                  -- -----------------------------------------------\n                  -- \",\" is not part of the pg_node_tree format, but used in the regex.\n                  -- This removes all \",\" that might be part of column names.\n                      ','               , ''\n                  -- The same applies for \"{\" and \"}\", although those are used a lot in pg_node_tree.\n                  -- We remove the escaped ones, which might be part of column names again.\n                  ), '\\\\{'              , ''\n                  ), '\\\\}'              , ''\n                  -- The fields we need are formatted as json manually to protect them from the regex.\n                  ), ' :targetList '   , ',\"targetList\":'\n                  ), ' :resno '        , ',\"resno\":'\n                  ), ' :resorigtbl '   , ',\"resorigtbl\":'\n                  ), ' :resorigcol '   , ',\"resorigcol\":'\n                  -- Make the regex also match the node type, e.g. \"{QUERY ...\", to remove it in one pass.\n                  ), '{'               , '{ :'\n                  -- Protect node lists, which start with \"({\" or \"((\" from the greedy regex.\n                  -- The extra \"{\" is removed again later.\n                  ), '(('              , '{(('\n                  ), '({'              , '{({'\n                  -- This regex removes all unused fields to avoid the need to format all of them correctly.\n                  -- This leads to a smaller json result as well.\n                  -- Removal stops at \",\" for used fields (see above) and \"}\" for the end of the current node.\n                  -- Nesting can't be parsed correctly with a regex, so we stop at \"{\" as well and\n                  -- add an empty key for the followig node.\n                  ), ' :[^}{,]+'       , ',\"\":'              , 'g'\n                  -- For performance, the regex also added those empty keys when hitting a \",\" or \"}\".\n                  -- Those are removed next.\n                  ), ',\"\":}'           , '}'\n                  ), ',\"\":,'           , ','\n                  -- This reverses the \"node list protection\" from above.\n                  ), '{('              , '('\n                  -- Every key above has been added with a \",\" so far. The first key in an object doesn't need it.\n                  ), '{,'              , '{'\n                  -- pg_node_tree has \"()\" around lists, but JSON uses \"[]\"\n                  ), '('               , '['\n                  ), ')'               , ']'\n                  -- pg_node_tree has \" \" between list items, but JSON uses \",\"\n                  ), ' '             , ','\n                  -- \"<>\" in pg_node_tree is the same as \"null\" in JSON, but due to very poor performance of json_typeof\n                  -- we need to make this an empty array here to prevent json_array_elements from throwing an error\n                  -- when the targetList is null.\n                  ), '<>'              , '[]'\n                )::json as view_definition\n              from views\n            ),\n            target_entries as(\n              select\n                view_id, view_schema, view_name, view_oid,\n                json_array_elements(view_definition->0->'targetList') as entry\n              from transform_json\n            ),\n            results as(\n              select\n                view_id, view_schema, view_name, view_oid,\n                (entry->>'resno')::int as view_column,\n                (entry->>'resorigtbl')::oid as resorigtbl,\n                (entry->>'resorigcol')::int as resorigcol\n              from target_entries\n            ),\n            recursion as(\n              select r.*\n              from results r\n              where view_schema = 'public'\n              union all\n              select\n                view.view_id,\n                view.view_schema,\n                view.view_name,\n                view.view_oid,\n                view.view_column,\n                tab.resorigtbl,\n                tab.resorigcol\n              from recursion view\n              join results tab on view.resorigtbl=tab.view_id and view.resorigcol=tab.view_column\n            )\n            select\n              -- sch.nspname as table_schema,\n              -- tbl.relname as table_name,\n              tbl.oid as table_oid,\n              -- col.attname as table_column_name,\n              col.attnum as table_column_num,\n              -- rec.view_schema,\n              -- rec.view_name,\n              rec.view_oid,\n              -- vcol.attname as view_column_name,\n              vcol.attnum as view_column_num\n            from recursion rec\n            join pg_class tbl on tbl.oid = rec.resorigtbl\n            join pg_attribute col on col.attrelid = tbl.oid and col.attnum = rec.resorigcol\n            join pg_attribute vcol on vcol.attrelid = rec.view_id and vcol.attnum = rec.view_column\n            join pg_namespace sch on sch.oid = tbl.relnamespace\n            order by view_oid, view_column_num\n            `\n        );\n\n        for (const row of queryResult) {\n            const viewOid: number = row[\"view_oid\"];\n            const viewColumnNum: number = row[\"view_column_num\"];\n            const tableOid: number = row[\"table_oid\"];\n            const tableColumnNum: number = row[\"table_column_num\"];\n\n            const isNotNull = this.isNotNull(tableOid, tableColumnNum);\n            this.viewLookupTable.set(`${viewOid}-${viewColumnNum}`, isNotNull);\n        }\n    }\n\n    public isNotNull(tableID: number, columnID: number): boolean {\n        const notNull1 = this.tableLookupTable.get(`${tableID}-${columnID}`);\n        if (notNull1 !== undefined) {\n            return notNull1;\n        }\n\n        const notNull2 = this.viewLookupTable.get(`${tableID}-${columnID}`);\n        if (notNull2 !== undefined) {\n            return notNull2;\n        }\n\n        return false;\n    }\n\n    private tableLookupTable = new Map<string, boolean>();\n    private viewLookupTable = new Map<string, boolean>();\n}\n\nfunction resolveFieldDefs(\n    tableColsLibrary: TableColsLibrary,\n    pgTypes: Map<number, SqlType>,\n    uniqueColumnTypes: Map<SqlType, TypeScriptType>,\n    fields: postgres.ColumnList<string>\n): Map<string, [ColNullability, TypeScriptType]> {\n    const result = new Map<string, [ColNullability, TypeScriptType]>();\n\n    for (const field of fields) {\n        const sqlType = psqlOidSqlType(pgTypes, field.type);\n        let colNullability: ColNullability = ColNullability.OPT;\n        if (field.table > 0) {\n            const notNull = tableColsLibrary.isNotNull(field.table, field.number);\n            if (notNull) {\n                colNullability = ColNullability.REQ;\n            }\n        }\n        const typeScriptType = sqlTypeToTypeScriptType(uniqueColumnTypes, sqlType);\n        result.set(field.name, [colNullability, typeScriptType]);\n    }\n\n    return result;\n}\n\nfunction sqlTypeToTypeScriptType(\n    uniqueColumnTypes: Map<SqlType, TypeScriptType>,\n    sqlType: SqlType\n): TypeScriptType {\n    // \"The array type typically has the same name as the base type with the\n    // underscore character (_) prepended.\"\n    //\n    // See: <https://www.postgresql.org/docs/12/xtypes.html#id-1.8.3.16.13.1>\n    if (SqlType.unwrap(sqlType).startsWith(\"_\")) {\n        const elemType = sqlTypeToTypeScriptType(\n            uniqueColumnTypes,\n            SqlType.wrap(SqlType.unwrap(sqlType).substring(1))\n        );\n        return TypeScriptType.wrap(`(${TypeScriptType.unwrap(elemType)} | null)[]`);\n    }\n\n    switch (SqlType.unwrap(sqlType)) {\n        case \"int2\":\n        case \"int4\":\n        case \"int8\":\n        case \"numeric\":\n            return TypeScriptType.wrap(\"number\");\n        case \"text\":\n            return TypeScriptType.wrap(\"string\");\n        case \"bool\":\n            return TypeScriptType.wrap(\"boolean\");\n        case \"float4\":\n        case \"float8\":\n            return TypeScriptType.wrap(\"number\");\n\n        // TODO Temporary\n        case \"jsonb\":\n            return TypeScriptType.wrap(\"DbJson\");\n        case \"timestamp\":\n            return TypeScriptType.wrap(\"LocalDateTime\");\n        case \"timestamptz\":\n            return TypeScriptType.wrap(\"Instant\");\n        case \"date\":\n            return TypeScriptType.wrap(\"LocalDate\");\n        case \"time\":\n            return TypeScriptType.wrap(\"LocalTime\");\n        case \"uuid\":\n            return TypeScriptType.wrap(\"UUID\");\n\n        default:\n    }\n\n    const uniqueType = uniqueColumnTypes.get(sqlType);\n\n    if (uniqueType !== undefined) {\n        return uniqueType;\n    }\n\n    return TypeScriptType.wrap(`/* sqlTypeToTypeScriptType Unknown/Invalid type: \"${sqlType}\" */`);\n}\n\nfunction colNullabilityStr(colNullability: ColNullability): string {\n    switch (colNullability) {\n        case ColNullability.REQ:\n            return \"Req\";\n        case ColNullability.OPT:\n            return \"Opt\";\n        default:\n            return assertNever(colNullability);\n    }\n}\n\nfunction renderIdentifier(ident: string): string {\n    // TODO wrap key in double quotes if not a valid JavaScript identifier\n\n    return ident;\n}\n\nfunction renderColTypesType(\n    colTypesFormat: ColTypesFormat,\n    colTypes: Map<string, [ColNullability, TypeScriptType]>\n): string {\n    if (colTypes.size === 0) {\n        return \"{}\";\n    }\n\n    let result = \"{\\n\";\n\n    const delim = colTypesFormat.delimiter;\n\n    colTypes.forEach((value, key) => {\n        result += `  ${renderIdentifier(key)}: ${colNullabilityStr(\n            value[0]\n        )}<${TypeScriptType.unwrap(value[1])}>${delim}\\n`;\n    });\n\n    switch (delim) {\n        case \",\":\n            // Remove trailing comma and newline\n            result = result.substr(0, result.length - 2);\n            break;\n        case \";\":\n            // Remove trailing newline\n            result = result.substr(0, result.length - 1);\n            break;\n        default:\n            return assertNever(delim);\n    }\n\n    result += \"\\n}\";\n    return result;\n}\n\n/**\n * Will return a canonical representation, that can be used for comparisons\n */\nfunction stringifyColTypes(colTypes: Map<string, [ColNullability, TypeScriptType]>): string {\n    const keys = [...colTypes.keys()];\n    keys.sort();\n    let result = \"\";\n    for (const key of keys) {\n        const value = colTypes.get(key);\n        if (value === undefined) {\n            throw new Error(\"The Impossible Happened\");\n        }\n        result += `${JSON.stringify(key)}:${value[0]} ${value[1]}\\n`;\n    }\n    return result;\n}\n\nasync function newConnect(\n    sql: postgres.Sql,\n    adminUrl: string,\n    name?: string\n): Promise<postgres.Sql> {\n    const newDbName = name !== undefined ? name : await testDatabaseName();\n\n    try {\n        if (name !== undefined) {\n            await dropDatabase(sql, name);\n        }\n\n        await createBlankDatabase(sql, newDbName);\n    } finally {\n        await closePg(sql);\n    }\n\n    const client = connectPg(connReplaceDbName(adminUrl, newDbName));\n    return client;\n}\n\nfunction readFileAsync(fileName: string): Promise<string> {\n    return new Promise<string>((resolve, reject) => {\n        fs.readFile(fileName, { encoding: \"utf-8\" }, (err, data) => {\n            if (<boolean>(<any>err)) {\n                reject(err);\n            } else {\n                resolve(data);\n            }\n        });\n    });\n}\n\ninterface TableColumn {\n    tableOid: number;\n    colAttnum: number;\n    typeName: string;\n}\n\nasync function queryTableColumn(\n    client: postgres.Sql,\n    tableName: string,\n    columnName: string\n): Promise<TableColumn | null> {\n    const result = await client.unsafe(\n        `\n        SELECT\n        pg_class.oid AS tbloid,\n        pg_attribute.attnum AS attnum,\n        pg_type.typname AS typname\n        FROM\n        pg_attribute,\n        pg_class,\n        pg_type\n        WHERE TRUE\n        AND pg_class.oid = pg_attribute.attrelid\n        AND pg_type.oid = pg_attribute.atttypid\n        AND pg_class.relname = $1\n        AND pg_attribute.attname = $2\n        `,\n        [tableName, columnName]\n    );\n\n    if (result.length === 0) {\n        return null;\n    } else if (result.length > 1) {\n        throw new Error(\n            `Multiple pg_attribute results found for Table \"${tableName}\" Column \"${columnName}\"`\n        );\n    }\n\n    return {\n        tableOid: result[0].tbloid,\n        colAttnum: result[0].attnum,\n        typeName: result[0].typname\n    };\n}\n\nasync function dropTableConstraints(client: postgres.Sql) {\n    // Reference: <https://www.postgresql.org/docs/10/catalog-pg-constraint.html>\n    const queryResult = await client.unsafe(\n        `\n        select\n            pg_class.relname,\n            pg_constraint.conname\n        from\n            pg_constraint,\n            pg_class\n        WHERE TRUE\n        AND pg_constraint.conrelid = pg_class.oid\n        AND pg_constraint.conrelid > 0\n        AND pg_constraint.contype IN ('c', 'x');\n        `\n    );\n\n    for (const row of queryResult) {\n        const relname: string = row[\"relname\"];\n        const conname: string = row[\"conname\"];\n\n        await client.unsafe(\n            `\n            ALTER TABLE ${escapeIdentifier(relname)} DROP CONSTRAINT IF EXISTS ${escapeIdentifier(\n                conname\n            )} CASCADE\n            `\n        );\n    }\n}\n\nasync function dropTableIndexes(client: postgres.Sql) {\n    const queryResult = await client.unsafe(\n        `\n        SELECT\n            pg_class.relname AS indexname\n        FROM\n            pg_index,\n            pg_class,\n            pg_namespace\n        WHERE\n            pg_class.oid = pg_index.indexrelid\n            AND pg_namespace.oid = pg_class.relnamespace\n            AND pg_namespace.nspname = 'public'\n            AND (\n                indpred IS NOT NULL\n                OR indexprs IS NOT NULL);\n        `\n    );\n\n    for (const row of queryResult) {\n        const indexname: string = row[\"indexname\"];\n\n        await client.unsafe(\n            `\n            DROP INDEX IF EXISTS ${escapeIdentifier(indexname)} CASCADE\n            `\n        );\n    }\n}\n\nasync function applyUniqueTableColumnTypes(\n    client: postgres.Sql,\n    uniqueTableColumnTypes: UniqueTableColumnType[]\n): Promise<void> {\n    // We need to drop all table constraints before converting the id columns.\n    // This is because some constraints might refer to these table columns and\n    // they might not like it if the column type changes.\n    //\n    // Remember that for our purposes constraints serve no purpose because we\n    // never actually insert or update any data in the database.\n    await dropTableConstraints(client);\n    await dropTableIndexes(client);\n\n    for (const uniqueTableColumnType of uniqueTableColumnTypes) {\n        const tableColumn = await queryTableColumn(\n            client,\n            uniqueTableColumnType.tableName,\n            uniqueTableColumnType.columnName\n        );\n\n        if (tableColumn !== null) {\n            const queryResult = await client.unsafe(\n                `\n                SELECT\n                    pg_constraint.conname,\n                    sc.relname,\n                    sa.attname\n                FROM\n                    pg_constraint,\n                    pg_class sc,\n                    pg_attribute sa,\n                    pg_class tc,\n                    pg_attribute ta\n                WHERE TRUE\n                    AND sc.oid = pg_constraint.conrelid\n                    AND tc.oid = pg_constraint.confrelid\n                    AND sa.attrelid = sc.oid\n                    AND ta.attrelid = tc.oid\n                    AND sa.attnum = pg_constraint.conkey[1]\n                    AND ta.attnum = pg_constraint.confkey[1]\n                    AND pg_constraint.contype = 'f'\n                    AND array_length(pg_constraint.conkey, 1) = 1\n                    AND array_length(pg_constraint.confkey, 1) = 1\n                    AND tc.relname = $1\n                    AND ta.attname = $2\n                `,\n                [uniqueTableColumnType.tableName, uniqueTableColumnType.columnName]\n            );\n\n            for (const row of queryResult) {\n                const conname: string = row[\"conname\"];\n                const relname: string = row[\"relname\"];\n\n                await client.unsafe(\n                    `\n                    ALTER TABLE ${escapeIdentifier(relname)} DROP CONSTRAINT ${escapeIdentifier(\n                        conname\n                    )}\n                    `\n                );\n            }\n\n            const typeName = sqlUniqueTypeName(\n                uniqueTableColumnType.tableName,\n                uniqueTableColumnType.columnName\n            );\n\n            await client.unsafe(\n                `\n                CREATE TYPE ${escapeIdentifier(typeName)} AS RANGE (SUBTYPE = ${escapeIdentifier(\n                    tableColumn.typeName\n                )})\n                `\n            );\n\n            const colName = uniqueTableColumnType.columnName;\n\n            const colHasDefault = await tableColHasDefault(\n                client,\n                uniqueTableColumnType.tableName,\n                colName\n            );\n\n            await client.unsafe(\n                `\n                ALTER TABLE ${escapeIdentifier(uniqueTableColumnType.tableName)}\n                    ALTER COLUMN ${escapeIdentifier(colName)} DROP DEFAULT,\n                    ALTER COLUMN ${escapeIdentifier(colName)} SET DATA TYPE ${escapeIdentifier(\n                    typeName\n                )} USING CASE WHEN ${escapeIdentifier(\n                    colName\n                )} IS NULL THEN NULL ELSE ${escapeIdentifier(typeName)}(${escapeIdentifier(\n                    colName\n                )}, ${escapeIdentifier(colName)}, '[]') END\n                `\n            );\n\n            if (colHasDefault) {\n                // Restore the column so that it has a default value\n                await client.unsafe(\n                    `\n                    ALTER TABLE ${escapeIdentifier(uniqueTableColumnType.tableName)}\n                        ALTER COLUMN ${escapeIdentifier(colName)} SET DEFAULT 'empty'\n                    `\n                );\n            }\n\n            for (const row of queryResult) {\n                const relname: string = row[\"relname\"];\n                const attname: string = row[\"attname\"];\n\n                const refColHasDefault = await tableColHasDefault(client, relname, attname);\n\n                await client.unsafe(\n                    `\n                    ALTER TABLE ${escapeIdentifier(relname)}\n                        ALTER COLUMN ${escapeIdentifier(attname)} DROP DEFAULT,\n                        ALTER COLUMN ${escapeIdentifier(attname)} SET DATA TYPE ${escapeIdentifier(\n                        typeName\n                    )} USING CASE WHEN ${escapeIdentifier(\n                        attname\n                    )} IS NULL THEN NULL ELSE ${escapeIdentifier(typeName)}(${escapeIdentifier(\n                        attname\n                    )}, ${escapeIdentifier(attname)}, '[]') END\n                    `\n                );\n\n                if (refColHasDefault) {\n                    // Restore the column so that it has a default value\n                    await client.unsafe(\n                        `\n                        ALTER TABLE ${escapeIdentifier(relname)}\n                            ALTER COLUMN ${escapeIdentifier(attname)} SET DEFAULT 'empty'\n                        `\n                    );\n                }\n            }\n        }\n    }\n}\n\nasync function tableColHasDefault(\n    client: postgres.Sql,\n    tableName: string,\n    colName: string\n): Promise<boolean> {\n    const result = await client.unsafe(\n        `\n        select pg_attribute.atthasdef\n        from\n            pg_attribute,\n            pg_class\n        where\n        pg_attribute.attrelid = pg_class.oid\n        and pg_attribute.attnum >= 1\n        and pg_class.relname = $1\n        and pg_attribute.attname = $2\n        `,\n        [tableName, colName]\n    );\n\n    if (result.count === 0) {\n        throw new Error(`No pg_attribute row found for \"${tableName}\".\"${colName}\"`);\n    }\n    if (result.count > 1) {\n        throw new Error(`Multiple pg_attribute rows found for \"${tableName}\".\"${colName}\"`);\n    }\n\n    const atthasdef: boolean = result[0][\"atthasdef\"];\n    return atthasdef;\n}\n\nasync function modifySystemCatalogs(client: postgres.Sql): Promise<void> {\n    const operatorOids: number[] = [\n        2345, // date_lt_timestamp\n        2346, // date_le_timestamp\n        2347, // date_eq_timestamp\n        2348, // date_ge_timestamp\n        2349, // date_gt_timestamp\n        2350, // date_ne_timestamp\n\n        2358, // date_lt_timestamptz\n        2359, // date_le_timestamptz\n        2360, // date_eq_timestamptz\n        2361, // date_ge_timestamptz\n        2362, // date_gt_timestamptz\n        2363, // date_ne_timestamptz\n\n        2371, // timestamp_lt_date\n        2372, // timestamp_le_date\n        2373, // timestamp_eq_date\n        2374, // timestamp_ge_date\n        2375, // timestamp_gt_date\n        2376, // timestamp_ne_date\n\n        2384, // timestamptz_lt_date\n        2385, // timestamptz_le_date\n        2386, // timestamptz_eq_date\n        2387, // timestamptz_ge_date\n        2388, // timestamptz_gt_date\n        2389, // timestamptz_ne_date\n\n        2534, // timestamp_lt_timestamptz\n        2535, // timestamp_le_timestamptz\n        2536, // timestamp_eq_timestamptz\n        2537, // timestamp_ge_timestamptz\n        2538, // timestamp_gt_timestamptz\n        2539, // timestamp_ne_timestamptz\n\n        2540, // timestamptz_lt_timestamp\n        2541, // timestamptz_le_timestamp\n        2542, // timestamptz_eq_timestamp\n        2543, // timestamptz_ge_timestamp\n        2544, // timestamptz_gt_timestamp\n        2545 // timestamptz_ne_timestamp\n    ];\n\n    const explicitCasts: [number, number][] = [\n        [1114, 1082], // timestamp -> date\n        [1114, 1083] // timestamp -> time\n    ];\n\n    const illegalCasts: [number, number][] = [\n        [1082, 1114], // date -> timestamp\n        [1082, 1184], // date -> timestamptz\n\n        [1114, 1184], // timestamp -> timestamptz\n\n        [1184, 1082], // timestamptz -> date\n        [1184, 1083], // timestamptz -> time\n        [1184, 1114], // timestamptz -> timestamp\n        [1184, 1266] // timestamptz -> timetz\n    ];\n\n    await client.unsafe(\n        `\n        delete from pg_operator\n        where oid = any($1)\n        `,\n        [operatorOids]\n    );\n\n    await client.unsafe(\n        `\n        update pg_cast\n        set castcontext = 'e'\n        where (castsource, casttarget) in (select * from unnest($1::oid[], $2::oid[]));\n        `,\n        [explicitCasts.map((c) => c[0]), explicitCasts.map((c) => c[1])]\n    );\n\n    await client.unsafe(\n        `\n        delete from pg_cast\n        where (castsource, casttarget) in (select * from unnest($1::oid[], $2::oid[]));\n        `,\n        [illegalCasts.map((c) => c[0]), illegalCasts.map((c) => c[1])]\n    );\n}\n\nfunction formatPgError(error: Error | postgres.PostgresError) {\n    const errors: string[] = [];\n    const pgError = parsePostgreSqlError(error);\n\n    if (pgError !== null) {\n        errors.push(\n            \"Error connecting to database cluster:\",\n            pgError.message,\n            `code: ${pgError.code}`\n        );\n\n        if (pgError.detail !== null && pgError.detail !== pgError.message) {\n            errors.push(\"detail: \" + pgError.detail);\n        }\n\n        if (pgError.hint !== null) {\n            errors.push(\"hint: \" + pgError.hint);\n        }\n\n        return new Error(errors.join(\"\\n\"));\n    }\n\n    if (\"code\" in error) {\n        errors.push(\"Error connecting to database cluster:\", error.message);\n\n        return new Error(errors.join(\"\\n\"));\n    }\n\n    return error;\n}\n","import { SrcSpan, toSrcSpan } from \"./ErrorDiagnostic\";\n\n/**\n * @param sourceMap First element of tuple is character position inside\n * `fileContents`. Second element of tuple is is start character position of\n * mapped string. Third element of tuple is end character position of mapped\n * string.\n *\n * @param position first character starts at 0\n */\nexport function resolveFromSourceMap(fileContents: string, position: number, sourceMap: [number, number, number][]): SrcSpan {\n    if (sourceMap.length === 0) {\n        throw new Error(\"Empty sourceMap\");\n    }\n\n    let i = 0;\n    while (true) {\n        if (position >= sourceMap[i][1] && position < sourceMap[i][2]) {\n            return toSrcSpan(fileContents,  sourceMap[i][0] + (position - sourceMap[i][1]));\n        }\n\n        if (position < sourceMap[i][1]) {\n            if (i > 0) {\n                const start = toSrcSpan(fileContents, sourceMap[i - 1][0] + sourceMap[i - 1][2] - sourceMap[i - 1][1]);\n                const end = toSrcSpan(fileContents, sourceMap[i][0]);\n                return {\n                    type: \"LineAndColRange\",\n                    startLine: start.line,\n                    startCol: start.col,\n                    endLine: end.line,\n                    endCol: end.col\n                };\n            } else {\n                return toSrcSpan(fileContents, sourceMap[0][0]);\n            }\n        }\n\n        if (i === sourceMap.length - 1) {\n            return toSrcSpan(fileContents, sourceMap[i][0] + sourceMap[i][2] - sourceMap[i][1] - 1);\n        }\n        i++;\n    }\n}\n","import chalk from \"chalk\";\n\nconst now = () => new Date().toISOString();\n\nexport const customLog = {\n    success: (...args: any[]) => {\n        console.log(chalk.grey(`[${now()}]`), chalk.green(`sql-checker`), ...args);\n    },\n    info: (...args: any[]) => {\n        console.log(chalk.grey(`[${now()}]`), chalk.blue(`sql-checker`), ...args);\n    },\n    error: (...args: any[]) => {\n        console.log(chalk.grey(`[${now()}]`), chalk.red(`sql-checker`), ...args);\n    }\n}\n"],"mappings":"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","names":["E","import_function","TE","chalk","import_assert_never","E","import_function","TE","import_fs","import_assert_never","import_assert_never","import_chalk","ts","import_chalk","chalk","postgres","postgres","import_assert_never","ts","ts","fs","Ajv","fs","path","import_assert_never","import_chalk","E","import_function","fs","path","import_chalk","chalk","invariant","chalk","path","assertNever","EmbeddedPostgres","fs","path","fs"]}